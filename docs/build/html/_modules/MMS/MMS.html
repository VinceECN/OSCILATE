

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MMS.MMS &mdash; MMS_solver 0.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=7026087e"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            MMS_solver
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Application Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">MMS_solver</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">MMS.MMS</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MMS.MMS</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Started on Tue Feb 15 17:25:59 2022</span>

<span class="sd">@author: Vincent MAHE</span>

<span class="sd">Analyse systems of coupled nonlinear equations using the Method of Multiple Scales (MMS).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#%% Imports and initialisation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">conjugate</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> 
                   <span class="n">symbols</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span>
                   <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">srepr</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">simplify</span><span class="p">,</span> 
                   <span class="n">zeros</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">eye</span><span class="p">,</span> <span class="n">Mod</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sympy.simplify.fu</span><span class="w"> </span><span class="kn">import</span> <span class="n">TR5</span><span class="p">,</span> <span class="n">TR8</span><span class="p">,</span> <span class="n">TR10</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">sympy_functions</span> <span class="k">as</span> <span class="n">sfun</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1">#%% Classes and functions</span>
<div class="viewcode-block" id="Dynamical_system">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Dynamical_system">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Dynamical_system</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The dynamical system studied.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : sympy.Symbol</span>
<span class="sd">        time :math:`t`.</span>
<span class="sd">    x : sympy.Function or list of sympy.Function</span>
<span class="sd">        Unknown(s) of the problem.</span>
<span class="sd">    Eq : sympy.Expr or list of sympy.Expr</span>
<span class="sd">        System&#39;s equations without forcing, which can be defined separately (see parameters `F` and `fF`).</span>
<span class="sd">        Eq is the unforced system of equations describing the system&#39;s dynamics. </span>
<span class="sd">    omegas : sympy.Symbol or list of sympy.Symbol</span>
<span class="sd">        The natural frequency of each oscillator.</span>
<span class="sd">    F : sympy.Symbol or 0, optional</span>
<span class="sd">        Forcing amplitude :math:`F`. </span>
<span class="sd">        Default is 0.</span>
<span class="sd">    fF : sympy.Expr or list of sympy.Expr, optional</span>
<span class="sd">        For each oscillator, specify the coefficient multiplying the forcing terms in the equation.</span>
<span class="sd">        It can be used to define parametric forcing. Typically, if the forcing is :math:`x F \cos(\omega t)`, then ``fF = x``.</span>
<span class="sd">        Default is a list of 1, so the forcing is direct. </span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Systems considered are typically composed of :math:`N` coupled nonlinear equations of the form</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \ddot{x}_0 + \omega_0^2 x_0 &amp; = f_0(\boldsymbol{x}, \dot{\boldsymbol{x}}, \ddot{\boldsymbol{x}}, t), \\</span>
<span class="sd">        &amp; \vdots \\</span>
<span class="sd">        \ddot{x}_{N-1} + \omega_{N-1}^2 x_{N-1} &amp; = f_{N-1}(\boldsymbol{x}, \dot{\boldsymbol{x}}, \ddot{\boldsymbol{x}}, t).</span>
<span class="sd">        \end{cases}</span>
<span class="sd">    </span>
<span class="sd">    The :math:`x_i(t)` (:math:`i=0,...,N-1`) are the oscillators&#39; coordinates (dof for degrees of freedom), </span>
<span class="sd">    :math:`\omega_i` are their natural frequencies, </span>

<span class="sd">    .. math::</span>

<span class="sd">        \boldsymbol{x}(t)^\intercal = [x_0(t), x_1(t), \cdots, x_{N-1}(t)]</span>
<span class="sd">         </span>
<span class="sd">    is the vector containing all the oscillators&#39; coordinates (:math:`^\intercal` denotes the transpose), </span>
<span class="sd">    :math:`t` is the time, </span>
<span class="sd">    :math:`\dot{(\bullet)} = \textrm{d}(\bullet)/\textrm{d}t` denotes a time-derivative. </span>
<span class="sd">    :math:`f_i` are functions which can contain:</span>

<span class="sd">    - **Weak linear terms** in :math:`x_i`, :math:`\dot{x}_i`, or :math:`\ddot{x}_i`.</span>
<span class="sd">    </span>
<span class="sd">    - **Weak linear coupling terms** involving :math:`x_j`, :math:`\dot{x}_j`, or :math:`\ddot{x}_j` with :math:`j \neq i`.</span>
<span class="sd">    </span>
<span class="sd">    - **Weak nonlinear terms**. Taylor expansions are performed to approximate nonlinear terms as polynomial nonlinearities.</span>
<span class="sd">    </span>
<span class="sd">    - **Forcing terms**, which can be:</span>
<span class="sd">    </span>
<span class="sd">        - *Hard* (appearing at leading order) or *weak* (small).</span>
<span class="sd">        </span>
<span class="sd">        - Primarily harmonic, e.g., :math:`F \cos(\omega t)`, where :math:`F` and :math:`\omega` are the forcing amplitude and frequency, respectively.</span>
<span class="sd">        </span>
<span class="sd">        - Modulated by any function (constant, linear, or nonlinear) to model parametric forcing (e.g., :math:`x_i(t) F \cos(\omega t)`).</span>

<span class="sd">    Internal resonance relations among oscillators can be specified in a second step by expressing the :math:`\omega_i` as a function of a reference frequency. </span>
<span class="sd">    Detuning can also be introduced during this step.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">omegas</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of the dynamical system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Information</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creation of the dynamical system&#39;</span><span class="p">)</span>
        
        <span class="c1"># Time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
        
        <span class="c1"># Variables and equations</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span>  <span class="o">=</span> <span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Eq</span> <span class="o">=</span> <span class="n">Eq</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">omegas</span> <span class="o">=</span> <span class="n">omegas</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span>    <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Eq</span>   <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">omegas</span> <span class="o">=</span> <span class="p">[</span><span class="n">omegas</span><span class="p">]</span>
            
        <span class="c1"># Forcing</span>
        <span class="n">F</span>  <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">sympify</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">fF</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fF&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fF</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> 
            <span class="n">fF</span> <span class="o">=</span> <span class="p">[</span><span class="n">fF</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fF</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">fF</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">=</span> <span class="n">Forcing</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">fF</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="Forcing">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Forcing">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Forcing</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define the forcing on the system as</span>

<span class="sd">    - A forcing amplitude `F`,</span>
<span class="sd">    </span>
<span class="sd">    - Forcing coefficients `fF`, used to introduce parametric forcing or simply weight the harmonic forcing.</span>
<span class="sd">    </span>
<span class="sd">    For the :math:`i^\textrm{th}` oscillator, denoting `fF[i]` as :math:`f_{F,i}(\boldsymbol{x}(t), \dot{\boldsymbol{x}}(t), \ddot{\boldsymbol{x}}(t))`, </span>
<span class="sd">    the forcing term on that oscillator is :math:`f_{F,i} F \cos(\omega t)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">fF</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span>       <span class="o">=</span> <span class="n">F</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fF</span> <span class="o">=</span> <span class="n">fF</span></div>


        
<div class="viewcode-block" id="scale_parameters">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.scale_parameters">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">scale_parameters</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">scaling</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scale parameters with the scaling parameter :math:`\epsilon`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    param : list of sympy.Symbol and/or sympy.Function</span>
<span class="sd">        Unscaled parameters.</span>
<span class="sd">    scaling : list of int or float</span>
<span class="sd">        The scaling for each parameter.</span>
<span class="sd">    eps : sympy.Symbol</span>
<span class="sd">        Small parameter :math:`\epsilon`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    param_scaled: list of sympy.Symbol and/or sympy.Function</span>
<span class="sd">        Scaled parameters.</span>
<span class="sd">    sub_scaling: list of 2 lists of tuple</span>
<span class="sd">        Substitutions from scaled to unscaled parameters and vice-versa. </span>

<span class="sd">        - :math:`1^{\text{st}}` list: The substitutions to do to introduce the scaled parameters in an expression.</span>
<span class="sd">        </span>
<span class="sd">        - :math:`2^{\text{nd}}` list: The substitutions to do to reintroduce the unscaled parameters in a scaled expression.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For a given parameter :math:`p` and a scaling order :math:`\lambda`, the associated scaled parameter :math:`\tilde{p}` is </span>

<span class="sd">    .. math::</span>
<span class="sd">        p = \epsilon^{\lambda} \tilde{p} .</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">param_scaled</span>     <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sub_scaling</span>      <span class="o">=</span> <span class="p">[[],</span> <span class="p">[]]</span>
    
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pow_p</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="n">param_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbols</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\tilde{{</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="o">**</span><span class="n">p</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
            <span class="n">param_scaled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Function</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\tilde{{</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="o">**</span><span class="n">p</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">)(</span><span class="o">*</span><span class="n">p</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
            
        <span class="n">sub_scaling</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">param_scaled</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">*</span> <span class="n">eps</span><span class="o">**</span><span class="n">pow_p</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">sub_scaling</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">param_scaled</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">p</span> <span class="o">/</span> <span class="n">eps</span><span class="o">**</span><span class="n">pow_p</span><span class="p">)</span> <span class="p">)</span>
        
    <span class="k">return</span> <span class="n">param_scaled</span><span class="p">,</span> <span class="n">sub_scaling</span></div>

        
        
<div class="viewcode-block" id="Multiple_scales_system">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Multiple_scales_system</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The multiple scales system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dynamical_system : Dynamical_system</span>
<span class="sd">        The dynamical system.</span>

<span class="sd">    eps : sympy.Symbol</span>
<span class="sd">        Small perturbation parameter :math:`\epsilon`.</span>

<span class="sd">    Ne : int</span>
<span class="sd">        Truncation order of the asymptotic series and order of the slowest time scale.</span>

<span class="sd">    omega_ref : sympy.Symbol</span>
<span class="sd">        Reference frequency :math:`\omega_{\textrm{ref}}` of the MMS.</span>
<span class="sd">        Not necessarily the frequency around which the MMS is going to be applied, see `ratio_omegaMMS`.</span>

<span class="sd">    sub_scaling : list of tuples</span>
<span class="sd">        Substitutions to do to scale the equations.</span>
<span class="sd">        Links small parameters to their scaled counterpart through :math:`\epsilon`.</span>

<span class="sd">    ratio_omegaMMS : int or sympy.Rational, optional</span>
<span class="sd">        Specify the frequency `omegaMMS` around which the MMS is going to be applied in terms of :math:`\omega_{\textrm{ref}}`.</span>
<span class="sd">        Denoting `ratio_omegaMMS` as :math:`r_{\textrm{MMS}}`, this means that</span>

<span class="sd">        .. math::</span>
<span class="sd">            \omega_{\textrm{MMS}} = r_{\textrm{MMS}} \omega_{\textrm{ref}}.</span>

<span class="sd">        Use ``ratio_omegaMMS=Rational(p,q)`` for</span>

<span class="sd">        .. math::</span>
<span class="sd">            q \omega_{\textrm{MMS}} = p \omega_{\textrm{ref}}</span>

<span class="sd">        to get better-looking results than the float :math:`p/q`.</span>
<span class="sd">        Default is 1.</span>

<span class="sd">    eps_pow_0 : int, optional</span>
<span class="sd">        Order of the leading order term in the asymptotic series of each oscillators&#39; response.</span>
<span class="sd">        For the :math:`i^{\textrm{th}}` oscillator and denoting `eps_pow_0` as :math:`\lambda_0`, this means that</span>

<span class="sd">        .. math::</span>
<span class="sd">            x_i = \epsilon^{\lambda_0} x_{i,0} + \epsilon^{\lambda_0+1} x_{i,1} + \cdots.</span>

<span class="sd">        Default is 0.</span>

<span class="sd">    ratio_omega_osc : list of int or sympy.Rational or None, optional</span>
<span class="sd">        Specify the natural frequencies of the oscillators :math:`\omega_i` in terms of the reference frequency :math:`\omega_{\textrm{ref}}`.</span>
<span class="sd">        Denoting ``ratio_omega_osc[i]`` as :math:`r_i`, this means that</span>

<span class="sd">        .. math::</span>
<span class="sd">            \omega_i \approx r_i \omega_{\textrm{ref}}.</span>

<span class="sd">        Use ``ratio_omega_osc[i]=Rational(p,q)`` for</span>

<span class="sd">        .. math::</span>
<span class="sd">            q \omega_{i} \approx p \omega_{\textrm{ref}}</span>

<span class="sd">        to get better-looking results than the float :math:`p/q`.</span>
<span class="sd">        Default is `None` for each oscillator, so the :math:`\omega_i` are arbitrary and there are no internal resonances.</span>
<span class="sd">        Detuning can be introduced through the `detunings` keyword argument.</span>

<span class="sd">    detunings : list of sympy.Symbol or int, optional</span>
<span class="sd">        The detuning of each oscillator. Denoting ``detunings[i]`` as :math:`\delta_i`, this means that</span>

<span class="sd">        .. math::</span>
<span class="sd">            \omega_i = r_i \omega_{\textrm{ref}} + \delta_i.</span>

<span class="sd">        Default is 0 for each oscillator.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Description of the method of multiple scales.</span>

<span class="sd">    ---------------------------------</span>
<span class="sd">    Asymptotic series and time scales</span>
<span class="sd">    ---------------------------------</span>

<span class="sd">    The starting point is to introduce asymptotic series and multiple time scales in the initial dynamical system.</span>
<span class="sd">    The solution for oscillator :math:`i` is sought as a series expansion up to order :math:`N_e` (for a leading order term :math:`\epsilon^0 = 1`). This expansion takes the form</span>

<span class="sd">    .. math::</span>
<span class="sd">        x_i(t) = x_{i,0}(t) + \epsilon x_{i,1}(t) + \epsilon^2 x_{i,2}(t) + \cdots + \epsilon^{N_e} x_{i,N_e}(t) + \mathcal{O}(\epsilon^{N_e+1}).</span>

<span class="sd">    Time scales are introduced as follows:</span>

<span class="sd">    .. math::</span>
<span class="sd">        t_0 = t, \; t_1 = \epsilon t, \; t_2 = \epsilon^2 t, \cdots, t_{N_e} = \epsilon^{N_e} t,</span>

<span class="sd">    where :math:`t_0` is the fast time, i.e. the time used to describe the oscillations,</span>
<span class="sd">    while :math:`t_1, \; t_2,\; \cdots,\; t_{N_e}` are slow times, associated to amplitude and phase variations of the solutions in time. In addition, the chain rule gives</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{aligned}</span>
<span class="sd">        \dfrac{\textrm{d}(\bullet)}{\textrm{d}t}     &amp; = \sum_{i=0}^{N_e} \epsilon^{i} \dfrac{\partial(\bullet)}{\partial t_i} + \mathcal{O}(\epsilon^{N_e+1}), \\</span>
<span class="sd">        \dfrac{\textrm{d}^2(\bullet)}{\textrm{d}t^2} &amp; = \sum_{j=0}^{N_e}\sum_{i=0}^{N_e} \epsilon^{i+j} \dfrac{\partial}{\partial t_j}\dfrac{\partial(\bullet)}{\partial t_i} + \mathcal{O}(\epsilon^{N_e+1}).</span>
<span class="sd">        \end{aligned}</span>

<span class="sd">    The introduction of asymptotic series and time scales are performed using :func:`asymptotic_series` and :func:`time_scales`.</span>

<span class="sd">    -------</span>
<span class="sd">    Scaling</span>
<span class="sd">    -------</span>

<span class="sd">    The construction of the MMS system requires a scaling of the parameters. Most scalings are already passed to the MMS through the `sub_scaling` parameter. </span>
<span class="sd">    However, the natural frequencies also need to be scaled as they can contain both a leading order term and a detuning term.</span>
<span class="sd">    Natural frequencies :math:`\omega_i` are defined as a function of the reference frequency :math:`\omega_{\textrm{ref}}` through the `ratio_omega_osc` optional parameter, which is then used in :func:`oscillators_frequencies`.</span>
<span class="sd">    This allows to define internal resonance relations among the oscillators. </span>
<span class="sd">    If these internal resonances are not perfect, detunings can be introduced through the `detunings` optional parameter, which needs to be scaled and part of the `sub_scaling` parameter.</span>

<span class="sd">    To write the MMS system it is convenient to introduce the leading order natural frequencies</span>

<span class="sd">    .. math::</span>
<span class="sd">        \omega_{i,0} = r_i \omega_{\textrm{ref}},</span>

<span class="sd">    where :math:`r_i` stands for ``ratio_omega_osc[i]``.</span>

<span class="sd">    --------------------------</span>
<span class="sd">    The multiple scales system</span>
<span class="sd">    --------------------------</span>

<span class="sd">    Introducing the asymptotic series, the time scales and the scaled parameters in the initial dynamical system (see :class:`~MMS.MMS.Dynamical_system`) results in :math:`N_e+1` dynamical systems, each one appearing at different orders of :math:`\epsilon`.</span>
<span class="sd">    Denoting time scales derivatives as</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \textrm{D}_i(\bullet) = \partial (\bullet) / \partial t_i, </span>
<span class="sd">        </span>
<span class="sd">    introducing the vector of time scales</span>
<span class="sd">     </span>
<span class="sd">    .. math::</span>
<span class="sd">        \boldsymbol{t}^\intercal = [t_0, t_1, \cdots, t_{N_e}],</span>

<span class="sd">    where :math:`^\intercal` denotes the transpose, and the vectors of asymptotic coordinates</span>

<span class="sd">    .. math::</span>
<span class="sd">        \boldsymbol{x}_i(\boldsymbol{t})^\intercal = [x_{0,i}(\boldsymbol{t}), x_{1,i}(\boldsymbol{t}), \cdots, x_{N-1, i}(\boldsymbol{t})],</span>

<span class="sd">    which contains all the asymptotic terms of order :math:`i`, the MMS equations can be written as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{aligned}</span>
<span class="sd">        &amp; \epsilon^0 \rightarrow \;</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \textrm{D}_0 x_{0,0} + \omega_{0,0}^2 x_{0,0} &amp; = f_{0,0}(t_0, t_1), \\</span>
<span class="sd">        &amp; \vdots \\</span>
<span class="sd">        \textrm{D}_0 x_{N-1,0} + \omega_{N-1,0}^2 x_{N-1,0} &amp; = f_{N-1,0}(t_0, t_1),</span>
<span class="sd">        \end{cases} \\[15pt]</span>
<span class="sd">        &amp; \epsilon^1 \rightarrow \;</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \textrm{D}_0 x_{0,1} + \omega_{0,0}^2 x_{0,1} &amp; = f_{0,1}  (\boldsymbol{x}_0, \textrm{D}_0 \boldsymbol{x}_0, \textrm{D}_0^2 \boldsymbol{x}_0, \textrm{D}_1 \boldsymbol{x}_0, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_0, t_0, t_1), \\</span>
<span class="sd">        &amp; \vdots \\</span>
<span class="sd">        \textrm{D}_0 x_{N-1,1} + \omega_{N-1,0}^2 x_{N-1,1} &amp; = f_{N-1,1}(\boldsymbol{x}_0, \textrm{D}_0 \boldsymbol{x}_0, \textrm{D}_0^2 \boldsymbol{x}_0, \textrm{D}_1 \boldsymbol{x}_0, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_0, t_0, t_1),</span>
<span class="sd">        \end{cases} \\[15pt]</span>
<span class="sd">        &amp; \epsilon^2 \rightarrow \;</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \textrm{D}_0 x_{0,2} + \omega_{0,0}^2 x_{0,2} &amp; = f_{0,2}  (\boldsymbol{x}_0, \cdots, \textrm{D}_0 \textrm{D}_2 \boldsymbol{x}_0, \boldsymbol{x}_1, \cdots, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_1, t_0, t_1), \\</span>
<span class="sd">        &amp; \vdots \\</span>
<span class="sd">        \textrm{D}_0 x_{N-1,2} + \omega_{N-1,0}^2 x_{N-1,2} &amp; = f_{N-1,2}(\boldsymbol{x}_0, \cdots, \textrm{D}_0 \textrm{D}_2 \boldsymbol{x}_0, \boldsymbol{x}_1, \cdots, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_1, t_0, t_1),</span>
<span class="sd">        \end{cases} \\[10pt]</span>
<span class="sd">        &amp; \hspace{3cm} \vdots \\[10pt]</span>
<span class="sd">        &amp; \epsilon^{N_e} \rightarrow \;</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \textrm{D}_0 x_{0,N_e} + \omega_{0,0}^2 x_{0,N_e} &amp; = f_{0,N_e}  (\boldsymbol{x}_0, \cdots, \textrm{D}_0 \textrm{D}_{N_e} \boldsymbol{x}_0, \cdots, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_{N_e-1}, t_0, t_1), \\</span>
<span class="sd">        &amp; \vdots \\</span>
<span class="sd">        \textrm{D}_0 x_{N-1,N_e} + \omega_{N-1,0}^2 x_{N-1,N_e} &amp; = f_{N-1,N_e}(\boldsymbol{x}_0, \cdots, \textrm{D}_0 \textrm{D}_{N_e} \boldsymbol{x}_0, \cdots, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_{N_e-1}, t_0, t_1).</span>
<span class="sd">        \end{cases}</span>
<span class="sd">        \end{aligned}</span>

<span class="sd">    Consider oscillator :math:`i` at order :math:`j`:</span>

<span class="sd">    - The left-hand side term represents a harmonic oscillator of frequency :math:`\omega_{i,0}` oscillating with respect to the fast time :math:`t_0`.</span>
<span class="sd">    - The right-hand side term :math:`f_{i,j}` is analogous to a forcing generated by all combinations of terms that appear on oscillator :math:`i`&#39;s equation at order :math:`\epsilon^j`.</span>
<span class="sd">      This can involve lower order terms :math:`x_{i,\ell}, \; \ell \leq j`, coupling terms :math:`x_{k, \ell}, \; k \neq j,\; \ell \leq j`, their derivatives and cross-derivatives with respect to the time scales, and physical forcing terms.</span>
<span class="sd">      The later is responsible for the dependency on :math:`t_0,\; t_1`. The reason why slower time scales are not involved will be explained in the following.</span>

<span class="sd">    Function :math:`f_{i,j}` tends to get increasingly complex as the order increases because the initial equations generate more high order terms than low order ones.</span>

<span class="sd">    This operation is performed using :func:`compute_EqMMS`.</span>

<span class="sd">    Note that internal resonance relations can be given through the `ratio_omega_osc` optional parameter, which is then used in :func:`oscillators_frequencies`.</span>

<span class="sd">    ---------------------</span>
<span class="sd">    Frequency of interest</span>
<span class="sd">    ---------------------</span>

<span class="sd">    The response of :math:`x_i` will be analysed at a frequency :math:`\omega`, defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \omega = \omega_{\textrm{MMS}} + \epsilon \sigma,</span>

<span class="sd">    where :math:`\omega_{\textrm{MMS}}` is the **central MMS frequency**, controlled through the `ratio_omegaMMS` optional parameter and expressed in terms of `omega_ref`, </span>
<span class="sd">    and :math:`\sigma` is a detuning about that frequency.</span>
<span class="sd">    In case the forced response is studied, :math:`\omega` corresponds to the forcing frequency.</span>
<span class="sd">    In case the free response is studied, :math:`\omega` corresponds to the frequency of free oscillations, which generates the backbone curve of the forced response.</span>
<span class="sd">    Note that :math:`\omega t = \omega_{\textrm{MMS}} t_0 + \sigma t_1`. This is the reason why the forcing only involves these two time scales in the right-hand side functions of the MMS system.</span>

<span class="sd">    ----------------------------------</span>
<span class="sd">    Iteratively solving the MMS system</span>
<span class="sd">    ----------------------------------</span>
<span class="sd">    </span>
<span class="sd">    The multiple scales system can be solved iteratively by solving successively the systems of equations at each order.</span>
<span class="sd">    </span>
<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">    Leading order solution</span>
<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^</span>

<span class="sd">    The leading order solution for oscillator :math:`i` must satisfy</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \textrm{D}_0 x_{i,0} + \omega_{i,0}^2 x_{i,0} = f_{i,0}(t_0, t_1).</span>
<span class="sd">    </span>
<span class="sd">    It is sought as</span>

<span class="sd">    .. math::</span>
<span class="sd">        x_{i,0}(\boldsymbol{t}) = x_{i,0}^\textrm{h}(\boldsymbol{t}) + x_{i,0}^\textrm{p}(t_0, t_1),</span>

<span class="sd">    where :math:`x_{i,0}^\textrm{h}(\boldsymbol{t})` and :math:`x_{i,0}^\textrm{p}(t_0, t_1)` are the leading order homogeneous and particular sollutions, respectively.</span>

<span class="sd">    It is now conveninent to introduce the slow times vector</span>

<span class="sd">    .. math::</span>
<span class="sd">        \boldsymbol{t}_s^\intercal = [t_1, \cdots, t_{N_e}].</span>

<span class="sd">    This way, one can express the leading order solutions as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        x_{i,0}^\textrm{h}(\boldsymbol{t}) &amp; = A_i(\boldsymbol{t}_s) e^{\textrm{j} \omega_{i,0} t_0} + cc = |A_i(\boldsymbol{t}_s)| \cos(\omega_{i,0} t_0 + \arg{A_i(\boldsymbol{t}_s)}), </span>
<span class="sd">        \\</span>
<span class="sd">        x_{i,0}^\textrm{p}(t_0, t_1) &amp; = B_i e^{\textrm{j} \omega t} + cc = B_i e^{\textrm{j} (\omega_{\textrm{MMS}} t_0 + \sigma t_1)} + cc = |B_i| \cos(\omega_{\textrm{MMS}} t_0 + \sigma t_1 + \arg{B_i}),</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    where :math:`A_i` is a slow time-dependent complex amplitude to be determined while :math:`B_i` is a time-independent function of the forcing parameters. </span>
<span class="sd">    :math:`cc` denotes the complex conjugate. </span>
<span class="sd">    Note that in most situations, forcing does not appear at leading order (i.e. forcing is weak), so :math:`B_i=0`.</span>

<span class="sd">    In the following it will be convenient to use the notations</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{split}</span>
<span class="sd">        \boldsymbol{A}(\boldsymbol{t}_s)^\intercal &amp; = [A_0(\boldsymbol{t}_s), A_1(\boldsymbol{t}_s), \cdots, A_{N-1}(\boldsymbol{t}_s)], \\</span>
<span class="sd">        \boldsymbol{B}^\intercal &amp; = [B_0, B_1, \cdots, B_{N-1}].</span>
<span class="sd">        \end{split}</span>

<span class="sd">    The leading order solutions are defined in :func:`sol_order_0`.</span>

<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">    Higher order solutions</span>
<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^</span>

<span class="sd">    Once the leading order solutions are computed, they can be injected in the :math:`1^\textrm{st}` higher order equations, where they (and their derivatives) appear as *forcing terms*, potentially together with physical forcing.</span>
<span class="sd">    The :math:`1^\textrm{st}` higher order equation for oscillator :math:`i` is </span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \textrm{D}_0 x_{i,1} + \omega_{i,0}^2 x_{i,1} = f_{i,1}(\boldsymbol{x}_0, \textrm{D}_0 \boldsymbol{x}_0, \textrm{D}_0^2 \boldsymbol{x}_0, \textrm{D}_1 \boldsymbol{x}_0, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_0, t_0, t_1).</span>
<span class="sd">    </span>
<span class="sd">    The forcing terms that involve oscillations at :math:`\omega_{i,0}` would force the oscillator on its natural frequency. Moreover, damping is always weak in the MMS, so damping terms of the form </span>
<span class="sd">    :math:`c \textrm{D}_0 x_{i,1}` do not appear at this order. </span>
<span class="sd">    The aforementioned forcing terms would thus lead to unbounded solutions, which is unphysical. </span>
<span class="sd">    These forcing terms, called **secular terms**, must therefore be eliminated. </span>
<span class="sd">    For instance, the :math:`1^\textrm{st}` higher order equation for oscillator :math:`i` with the secular terms cancelled is</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \textrm{D}_0 x_{i,1} + \omega_{i,0}^2 x_{i,1} = \bar{f}_{i,1}(\boldsymbol{x}_0, \textrm{D}_0 \boldsymbol{x}_0, \textrm{D}_0^2 \boldsymbol{x}_0, \textrm{D}_1 \boldsymbol{x}_0, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_0, t_0, t_1).</span>
<span class="sd">    </span>
<span class="sd">    where :math:`\bar{f}_{i,1}` is :math:`f_{i,1}` with the secular terms cancelled, i.e. without terms oscillating as :math:`\omega_{i,0}`.</span>
<span class="sd">    After cancelation of the secular terms, each oscillator&#39;s equation can be solved as a forced harmonic oscillator with the independent variable :math:`t_0`.</span>
<span class="sd">    </span>
<span class="sd">    Note that only the particular solutions are considered when solving higher order terms, i.e.</span>

<span class="sd">    .. math::</span>
<span class="sd">        x_{i,1}(\boldsymbol{t}) = \underbrace{x_{i,1}^\textrm{h}(\boldsymbol{t})}_{=0} + x_{i,1}^\textrm{p}(t_0, t_1).</span>

<span class="sd">    This choice can be justified if one assumes that initial conditions are of leading order. Though this is questionable, it is assumed here.</span>
<span class="sd">    </span>
<span class="sd">    The higher order solutions :math:`x_{i,1}(\boldsymbol{t})` are expressed as a function of the leading order unknown amplitudes :math:`\boldsymbol{A}(\boldsymbol{t}_s)`, </span>
<span class="sd">    their slow time derivatives :math:`\textrm{D}_i\boldsymbol{A}(\boldsymbol{t}_s), \; i=1, ..., N_e`, and forcing terms if any (including the hard forcing amplitudes :math:`\boldsymbol{B}`).  </span>
<span class="sd">    </span>
<span class="sd">    This process is repeated successively at each order, i.e. the computed solutions are introduced in the next higher order system of equations, </span>
<span class="sd">    secular terms are cancelled and the next higher order solutions are computed. </span>

<span class="sd">    </span>
<span class="sd">    The secular terms are identified in :func:`secular_analysis` and the leading order solutions are computed in :func:`sol_higher_order`. </span>
<span class="sd">    Note that :func:`sol_higher_order` is applied on equations with only :math:`t_0` as the independent variable so as to allow the use of :func:`~sympy.solvers.ode.dsolve`. </span>
<span class="sd">    This is enforced using :func:`system_t0`, which temporarily ignores the dependency of :math:`\boldsymbol{A}(\boldsymbol{t}_s)` on the slow time scales.</span>

<span class="sd">    ^^^^^^^^^^^^^^^^</span>
<span class="sd">    Secular analysis</span>
<span class="sd">    ^^^^^^^^^^^^^^^^</span>

<span class="sd">    At this stage, the solutions are all expressed in terms of the unknown amplitudes :math:`\boldsymbol{A}(\boldsymbol{t}_s)` and their slow time derivatives :math:`\textrm{D}_1 A_i(\boldsymbol{t}_s),\; \cdots,\; \textrm{D}_{N_e} A_i(\boldsymbol{t}_s)`. </span>
<span class="sd">    These can be obtained from the elimination of the secular terms (called **secular conditions**), as described below. </span>
<span class="sd">    </span>
<span class="sd">    The :math:`i^\textrm{th}` MMS equation at :math:`1^\textrm{st}` higher order involves the slow time derivative :math:`\textrm{D}_1 A_i(\boldsymbol{t}_s)`, which appears </span>
<span class="sd">    in the secular term. It is coming from the chain rule </span>

<span class="sd">    .. math::</span>
<span class="sd">        \dfrac{\textrm{d}^2 x_i(t)}{\textrm{d}t^2} = \dfrac{\partial^2 x_{i,0}(\boldsymbol{t})}{\partial t_0^2} + \epsilon \dfrac{\partial^2 x_{i,1}(\boldsymbol{t})}{\partial t_0^2} + 2 \epsilon \dfrac{\partial^2 x_{i,0}(\boldsymbol{t})}{\partial t_0 \partial t_1} + \mathcal{O}(\epsilon^2).</span>

<span class="sd">    In addition, the :math:`\textrm{D}_1 A_j(\boldsymbol{t}_s),\; j\neq i` do not appear in the :math:`i^\textrm{th}` MMS equation as couplings among oscillators are weak. </span>
<span class="sd">    It is thus possible to use the secular conditions in order to express the :math:`\textrm{D}_1 A_i(\boldsymbol{t}_s)` as a function of :math:`\boldsymbol{A}(\boldsymbol{t}_s)`. </span>
<span class="sd">    </span>
<span class="sd">    This process can be done successively at each order to obtain the system of complex evolution equations</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \textrm{D}_1 A_i(\boldsymbol{t}_s) &amp; = f_{A_i}^{(1)}(\boldsymbol{A}, t_1), \\</span>
<span class="sd">        &amp; \vdots \\</span>
<span class="sd">        \textrm{D}_{N_e} A_i(\boldsymbol{t}_s) &amp; = f_{A_i}^{(N_e)}(\boldsymbol{A}, t_1).</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    :math:`f_{A_i}^{(j)}(\boldsymbol{A}, t_1)` are functions governing the evolution of :math:`A_i` with respect to the slow time :math:`t_j`. </span>
<span class="sd">    Note the dependency of :math:`f_{A_i}^{(j)}` on :math:`t_1` due to the possible presence of forcing. The complex evolution equations are derived in :func:`secular_analysis`.</span>
<span class="sd">    </span>
<span class="sd">    The above system of :math:`1^\textrm{st}` order PDE can theoretically be solved to obtain the complex amplitudes :math:`\boldsymbol{A}`. </span>
<span class="sd">    However, this approach is not the prefered one as </span>

<span class="sd">    - It is more convenient to deal with real variables than complex ones to get a physical meaning from the analysis,</span>

<span class="sd">    - It is more convenient to deal with autonomous systems (without the explicit :math:`t_1`-dependency) than nonautonomous ones,</span>

<span class="sd">    - The PDEs are complex.</span>

<span class="sd">    The first two points can be achieved introducing new coordinates, as described thereafter.</span>

<span class="sd">    -------------------</span>
<span class="sd">    Evolution equations</span>
<span class="sd">    -------------------</span>

<span class="sd">    ^^^^^^^^^^^^^^^^^</span>
<span class="sd">    Polar coordinates</span>
<span class="sd">    ^^^^^^^^^^^^^^^^^</span>

<span class="sd">    As discussed previously, it is more convenient to deal with real variables than complex ones. This can be done introducing the polar coordinates :math:`a_i` and :math:`\phi_i` for oscillator :math:`i` such that</span>

<span class="sd">    .. math::</span>
<span class="sd">        A_i(\boldsymbol{t}_s) = \dfrac{1}{2} a_i(\boldsymbol{t}_s) e^{\textrm{j} \phi_i(\boldsymbol{t}_s)}.</span>

<span class="sd">    :math:`a_i` and :math:`\phi_i` correspond to the amplitude and phase of the leading solution for oscillator :math:`i`, respectively. </span>
<span class="sd">    With these new coordinates and introducing</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \begin{aligned}</span>
<span class="sd">        \boldsymbol{a}(\boldsymbol{t}_s)^\intercal &amp; = [a_0(\boldsymbol{t}_s), a_1(\boldsymbol{t}_s), \cdots, a_{N-1}(\boldsymbol{t}_s)], \\</span>
<span class="sd">        \boldsymbol{\phi}(\boldsymbol{t}_s)^\intercal &amp; = [\phi_0(\boldsymbol{t}_s), \phi_1(\boldsymbol{t}_s), \cdots, \phi_{N-1}(\boldsymbol{t}_s)],</span>
<span class="sd">        \end{aligned}</span>

<span class="sd">    the evolution equations on the :math:`A_i(\boldsymbol{t}_s)` can be split into real and imaginary terms, leading to</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \begin{aligned}</span>
<span class="sd">        &amp; \epsilon^1 \rightarrow \;</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \textrm{D}_1 a_i &amp; = \hat{f}_{a_i}^{(1)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1), \\</span>
<span class="sd">        a_i \textrm{D}_1 \phi_i &amp; = \hat{f}_{\phi_i}^{(1)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1), </span>
<span class="sd">        \end{cases}</span>
<span class="sd">        \\[5pt]</span>
<span class="sd">        &amp; \hspace{3cm} \vdots \\[5pt]</span>
<span class="sd">        &amp; \epsilon^{N_e} \rightarrow \;</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \textrm{D}_{N_e} a_i &amp; = \hat{f}_{a_i}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1), \\</span>
<span class="sd">        a_i \textrm{D}_{N_e} \phi_i &amp; = \hat{f}_{\phi_i}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1).</span>
<span class="sd">        \end{cases}</span>
<span class="sd">        \end{aligned}</span>
<span class="sd">    </span>
<span class="sd">    The :math:`\epsilon^j \rightarrow` indicate a system of 2 equations originating from the secular analysis at order :math:`j`.</span>
<span class="sd">    As one has</span>

<span class="sd">    .. math::</span>
<span class="sd">        \textrm{D}_j A_i = \textrm{D}_j \dfrac{1}{2} a_i e^{\textrm{j} \phi_i} = \dfrac{1}{2} \textrm{D}_j \left( a_i \right) e^{\textrm{j} \phi_i} + \textrm{j} \dfrac{1}{2} a_i e^{\textrm{j} \phi_i} \textrm{D}_j \left( \phi_i \right),</span>

<span class="sd">    it is convenient to pre-multiply the evolution equations on the :math:`A_i(\boldsymbol{t}_s)` by :math:`e^{-\textrm{j} \phi_i(\boldsymbol{t}_s)}` or even :math:`\gamma e^{-\textrm{j} \phi_i(\boldsymbol{t}_s)}` with, for instance, :math:`\gamma = 2`. </span>
<span class="sd">    This avoids the presence of :math:`\cos(\phi_i)`, :math:`\sin(\phi_i)` and many :math:`1/2` terms in the evolution equations. </span>
<span class="sd">    The evolution functions on polar coordinates are therefore defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \hat{f}_{a_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1) &amp; = \Re\left[ 2 e^{-\textrm{j} \phi_i(\boldsymbol{t}_s)} f_{A_i}^{(j)}(\boldsymbol{A}, t_1) \right], \\</span>
<span class="sd">        \hat{f}_{\phi_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1) &amp; = \Im\left[ 2 e^{-\textrm{j} \phi_i(\boldsymbol{t}_s)} f_{A_i}^{(j)}(\boldsymbol{A}, t_1) \right].</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    The evolution equations system on the polar coordinates involves only real variables, but functions :math:`\hat{f}_{a_i}^{(j)}` and :math:`\hat{f}_{\phi_i}^{(j)}` are</span>
<span class="sd">    still nonautonomous due to the explicit dependency on :math:`t_1`. </span>

<span class="sd">    The polar coordinates are introduced in :func:`polar_coordinates`. The real evolution equations are only computed for the autonomous system, as described below. </span>

<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">    Autonomous phase coordinates</span>
<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

<span class="sd">    The presence of nonautonomous terms stems from forcing terms, which involve :math:`\cos(\sigma t_1 - \phi_i), \; \sin(\sigma t_1 - \phi_i)` in the polar evolution functions of oscillator :math:`i`. </span>
<span class="sd">    A change of phase coordinates is required to make this autonomous.</span>
<span class="sd">    Moreover, the change of phase coordinate is necessary even in the absence of forcing for a convenient representation of the leading order solution. </span>
<span class="sd">    Indeed, the solution for :math:`x^{\textrm{h}}_{i,0}(\boldsymbol{t})` written in terms of the current polar coordinates is</span>

<span class="sd">    .. math::</span>
<span class="sd">        x^{\textrm{h}}_{i,0}(\boldsymbol{t}) = a_i(\boldsymbol{t}_s) \cos(\omega_{i,0} t_0 + \phi_i(\boldsymbol{t}_s)).</span>

<span class="sd">    However, one would eventually like to express the oscillations of oscillator :math:`i` in terms of the frequency :math:`\omega`. To force its appearance, we recall that</span>

<span class="sd">    .. math::</span>
<span class="sd">        \omega_{i,0} = r_i \omega_{\textrm{ref}}, \quad \omega_{\textrm{ref}} = \frac{1}{r_{\textrm{MMS}}} \omega_{\textrm{MMS}}, \quad \textrm{and} \quad \omega_{\textrm{MMS}} = \omega - \epsilon \sigma.  </span>
<span class="sd">    </span>
<span class="sd">    Introducing this in the leading order solution leads to</span>

<span class="sd">    .. math::</span>
<span class="sd">        x^{\textrm{h}}_{i,0}(\boldsymbol{t}) = a_i(\boldsymbol{t}_s) \cos\left( \frac{r_i}{r_{\textrm{MMS}}} \omega t_0 - \frac{r_i}{r_{\textrm{MMS}}} \sigma t_1 + \phi_i(\boldsymbol{t}_s)\right).</span>

<span class="sd">    It therefore appears convenient to introduce the new phase coordinate :math:`\beta_i(\boldsymbol{t}_s)` as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \beta_i(\boldsymbol{t}_s) = \frac{r_i}{r_{\textrm{MMS}}} \sigma t_1 - \phi_i(\boldsymbol{t}_s),</span>

<span class="sd">    which allows to write the leading order solution as</span>

<span class="sd">    .. math::</span>
<span class="sd">        x^{\textrm{h}}_{i,0}(\boldsymbol{t}) = a_i(\boldsymbol{t}_s) \cos\left( \frac{r_i}{r_{\textrm{MMS}}} \omega t_0 - \beta_i(\boldsymbol{t}_s)\right).</span>

<span class="sd">    In addition, and as discussed previously, the introduction of these new phase coordinates removes the explicit dependency of the evolution functions on :math:`t_1`, which was due to terms :math:`\cos(\sigma t_1 - \phi_i), \; \sin(\sigma t_1 - \phi_i)`.</span>
<span class="sd">    The forcing phase being zero (i.e. reference phase), the :math:`\beta_i(\boldsymbol{t}_s)` can be seen as the phases relative to the forcing. </span>

<span class="sd">    Introducing the notation</span>
<span class="sd">    </span>
<span class="sd">    .. math::</span>
<span class="sd">        \boldsymbol{\beta}(\boldsymbol{t}_s)^\intercal = [\beta_1(\boldsymbol{t}_s), \beta_2(\boldsymbol{t}_s), \dots, \beta_{N_e}(\boldsymbol{t}_s)],</span>
<span class="sd">    </span>
<span class="sd">    the evolution equations can be rewritten as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{aligned}</span>
<span class="sd">        &amp; \epsilon^1 \rightarrow \;</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \textrm{D}_1 a_0(\boldsymbol{t}_s) &amp; = f_{a_0}^{(1)}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">        a_0 \textrm{D}_1 \beta_0(\boldsymbol{t}_s) &amp; = f_{\beta_0}^{(1)}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">        &amp; \vdots \\</span>
<span class="sd">        \textrm{D}_1 a_{N-1}(\boldsymbol{t}_s) &amp; = f_{a_{N-1}}^{(1)}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">        a_{N-1} \textrm{D}_1 \beta_{N-1}(\boldsymbol{t}_s) &amp; = f_{\beta_{N-1}}^{(1)}(\boldsymbol{a}, \boldsymbol{\beta}), </span>
<span class="sd">        \end{cases} \\[5pt]</span>
<span class="sd">        &amp; \hspace{3cm} \vdots \\[5pt]</span>
<span class="sd">        &amp; \epsilon^{N_e} \rightarrow \;</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \textrm{D}_{N_e} a_0(\boldsymbol{t}_s) &amp; = f_{a_0}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">        a_0 \textrm{D}_{N_e} \beta_0(\boldsymbol{t}_s) &amp; = f_{\beta_0}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">        &amp; \vdots \\</span>
<span class="sd">        \textrm{D}_{N_e} a_{N-1}(\boldsymbol{t}_s) &amp; = f_{a_{N-1}}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">        a_{N-1} \textrm{D}_{N_e} \beta_{N-1}(\boldsymbol{t}_s) &amp; = f_{\beta_{N-1}}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\beta}).</span>
<span class="sd">        \end{cases}</span>
<span class="sd">        \end{aligned}</span>

<span class="sd">    The above system is the key result of the application of the MMS as it governs the evolution of leading order amplitudes and phases, on which all higher order solutions depend. </span>
<span class="sd">    It can be solved numerically or analytically, if analytical solutions exist, though it is generally not the case. </span>
<span class="sd">    It can also be rewritten in a more compact form as discussed in the following.</span>
<span class="sd">    </span>
<span class="sd">    The autonomous phase coordinates are introduced in :func:`autonomous_phases` and the evolution equations are computed in :func:`evolution_equations`.</span>
<span class="sd">    </span>
<span class="sd">    All solutions previously computed using the complex amplitudes :math:`\boldsymbol{A}(\boldsymbol{t}_s)` can be rewritten in terms of the polar coordinates :math:`\boldsymbol{a}(\boldsymbol{t}_s),\; \boldsymbol{\beta}(\boldsymbol{t}_s)` using :func:`sol_xMMS_polar`. </span>

<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">    Reintroduction of the physical time</span>
<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

<span class="sd">    Recalling the chain rule</span>

<span class="sd">    .. math::</span>
<span class="sd">        \dfrac{\textrm{d}(\bullet)}{\textrm{d}t} = \sum_{i=0}^{N_e} \epsilon^{i} \textrm{D}_i(\bullet), </span>

<span class="sd">    and reintroducing the physical time, the systems at each order can be summed up to write</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \dfrac{\textrm{d}}{dt} a_0(t) &amp; = f_{a_0}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">        a_0 \dfrac{\textrm{d}}{dt} \beta_0(t) &amp; = f_{\beta_0}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">        &amp; \vdots \\</span>
<span class="sd">        \dfrac{\textrm{d}}{dt} a_{N-1}(t) &amp; = f_{a_{N-1}}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">        a_{N-1} \dfrac{\textrm{d}}{dt} \beta_{N-1}(t) &amp; = f_{\beta_{N-1}}(\boldsymbol{a}, \boldsymbol{\beta}), </span>
<span class="sd">        \end{cases}</span>

<span class="sd">    where</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        f_{a_i}(\boldsymbol{a}, \boldsymbol{\beta}) &amp; = \sum_{j=1}^{N_e} \epsilon^{j} f_{a_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">        f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta}) &amp; = \sum_{j=1}^{N_e} \epsilon^{j} f_{\beta_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\beta}).</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    The MMS system then obtained represents a nonlinear autonomous system of :math:`2N` coupled :math:`1^{\textrm{st}}` order PDEs, with the physical time :math:`t` as the independent variable. </span>
<span class="sd">    Like the time scales-dependent evolution equations, they can be solved numerically or analytically, if analytical solutions exist. </span>

<span class="sd">    These physical time-dependent evolution equations are also computed in :func:`evolution_equations`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dynamical_system</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">Ne</span><span class="p">,</span> <span class="n">omega_ref</span><span class="p">,</span> <span class="n">sub_scaling</span><span class="p">,</span> 
                 <span class="n">ratio_omegaMMS</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">eps_pow_0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform the dynamical system introducing asymptotic series and multiple time scales. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Information</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initialisation of the multiple scales sytem&#39;</span><span class="p">)</span>
        
        <span class="c1"># Order of the method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ne</span>  <span class="o">=</span> <span class="n">Ne</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps_pow_0</span> <span class="o">=</span> <span class="n">eps_pow_0</span>
        
        <span class="c1"># MMS reference frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega_ref</span> <span class="o">=</span> <span class="n">omega_ref</span>
        
        <span class="c1"># MMS frequencies of interest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omegaMMS</span> <span class="o">=</span> <span class="n">ratio_omegaMMS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omegaMMS</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omegaMMS</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>          <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\sigma&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Detuning to investigate the response around omegaMMS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span>          <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\omega&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Frequencies investigated </span>
        <span class="n">sub_omega</span>           <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omegaMMS</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span> <span class="c1"># Definition of omega</span>
        <span class="n">sub_sigma</span>           <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">omegaMMS</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span> <span class="c1"># Definition of sigma (equivalent to that of omega)</span>
        
        <span class="c1"># Number of dof</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span> <span class="o">=</span> <span class="n">dynamical_system</span><span class="o">.</span><span class="n">ndof</span>
        
        <span class="c1"># Multiple time scales</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">dynamical_system</span><span class="o">.</span><span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">,</span> <span class="n">sub_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_scales</span><span class="p">()</span>
        
        <span class="c1"># Asymptotic series of x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xMMS</span><span class="p">,</span> <span class="n">sub_xMMS_t</span><span class="p">,</span> <span class="n">sub_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asymptotic_series</span><span class="p">(</span><span class="n">dynamical_system</span><span class="p">,</span> <span class="n">eps_pow_0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eps_pow_0</span><span class="p">)</span>
        
        <span class="c1"># Substitutions required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span> <span class="o">=</span> <span class="n">Substitutions_MMS</span><span class="p">(</span><span class="n">sub_t</span><span class="p">,</span> <span class="n">sub_xMMS_t</span><span class="p">,</span> <span class="n">sub_x</span><span class="p">,</span> <span class="n">sub_scaling</span><span class="p">,</span> <span class="n">sub_omega</span><span class="p">,</span> <span class="n">sub_sigma</span><span class="p">)</span>
    
        <span class="c1"># Forcing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing_MMS</span><span class="p">(</span><span class="n">dynamical_system</span><span class="p">)</span>
        
        <span class="c1"># Oscillators&#39; frequencies (internal resonances and detuning)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omegas</span> <span class="o">=</span> <span class="n">dynamical_system</span><span class="o">.</span><span class="n">omegas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omega_osc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ratio_omega_osc&quot;</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>   <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detunings</span>       <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;detunings&quot;</span><span class="p">,</span>       <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oscillators_frequencies</span><span class="p">()</span>        
        
        <span class="c1"># Coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">Coord_MMS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polar_coordinates</span><span class="p">()</span>
        
        <span class="c1"># Solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span> <span class="o">=</span> <span class="n">Sol_MMS</span><span class="p">()</span>
        
        <span class="c1"># Compute the MMS equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_EqMMS</span><span class="p">(</span><span class="n">dynamical_system</span><span class="p">)</span>
        
<div class="viewcode-block" id="Multiple_scales_system.time_scales">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.time_scales">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_scales</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define the time scales.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The time scales are defined as (see :class:`~MMS.MMS.Multiple_scales_system`)</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            t_0 = t, \quad t_1 = \epsilon t, \quad \cdots, \quad t_{N_e} = \epsilon^{N_e} t.</span>
<span class="sd">        </span>
<span class="sd">        Substitutions from the physical time :math:`t` to the time scales :math:`t_i, \; i=0, ..., N_e` are also prepared.</span>
<span class="sd">        Note that :math:`t_0` is refered-to as the fast time as it captures the oscillations. </span>
<span class="sd">        Other time scales are refered-to as slow time as they capture the modulations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">tS</span>  <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sub_t</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">tS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbols</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;t_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">it</span><span class="p">),</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">sub_t</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">**</span><span class="n">it</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">tS</span><span class="p">[</span><span class="n">it</span><span class="p">]))</span>
            
        <span class="n">sub_t</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="c1"># Start substitutions with the slowest time scale</span>
        
        <span class="k">return</span> <span class="n">tS</span><span class="p">,</span> <span class="n">sub_t</span></div>

    
<div class="viewcode-block" id="Multiple_scales_system.asymptotic_series">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.asymptotic_series">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">asymptotic_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dynamical_system</span><span class="p">,</span> <span class="n">eps_pow_0</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define the asymptotic series.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The series expansion for oscillator :math:`i` (and for a leading order term :math:`\epsilon^0 = 1`) takes the form (see :class:`~MMS.MMS.Multiple_scales_system`)</span>

<span class="sd">        .. math::</span>
<span class="sd">            x_i(t) = x_{i,0}(t) + \epsilon x_{i,1}(t) + \epsilon^2 x_{i,2}(t) + \cdots + \epsilon^{N_e} x_{i,N_e}(t) + \mathcal{O}(\epsilon^{N_e+1}).</span>

<span class="sd">        On top of introducing the terms of the asymptotic series, this function prepares substitutions from</span>

<span class="sd">        1. dof :math:`x_i(t)` to temporary :math:`t`-dependent asymptotic terms :math:`x_{i,j}(t)`, such that</span>

<span class="sd">           .. math::</span>
<span class="sd">            x_i(t) = x_{i,0}(t) + \epsilon x_{i,1}(t) + \epsilon^2 x_{i,2}(t) + \cdots + \epsilon^{N_e} x_{i,N_e}(t), </span>

<span class="sd">        2. Temporary :math:`x_{i,j}(t)` to the time scales-dependent terms :math:`x_{i,j}(\boldsymbol{t})`, such that</span>
<span class="sd">         </span>
<span class="sd">           .. math::</span>
<span class="sd">            x_i(\boldsymbol{t}) = x_{i,0}(\boldsymbol{t}) + \epsilon x_{i,1}(\boldsymbol{t}) + \epsilon^2 x_{i,2}(\boldsymbol{t}) + \cdots + \epsilon^{N_e} x_{i,N_e}(\boldsymbol{t}). </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Initialisation</span>
        <span class="n">xMMS</span>         <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Terms x00, x01, ..., x10, x11, ... of the asymptotic series of the xi</span>
        <span class="n">sub_xMMS_t</span>   <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Substitutions from xMMS(t) to xMMS(*tS)</span>
        <span class="n">x_expanded</span>   <span class="o">=</span> <span class="p">[]</span> <span class="c1"># x in terms of xMMS(t)</span>
        <span class="n">sub_x</span>        <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Substitutions from x to xMMS(t)</span>
        
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            
            <span class="c1"># Initialisations </span>
            <span class="n">xMMS</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>      <span class="c1"># A list that will contain the different expansion orders of the current x</span>
            <span class="n">xMMS_t</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c1"># Temporary xMMS(t) -&gt; depend on the physical time t</span>
            <span class="n">x_expanded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Initialise the current x to 0</span>
            
            <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            
                <span class="c1"># Define time-dependent asymptotic terms</span>
                <span class="n">xMMS_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Function</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;x_{{</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span><span class="n">it</span><span class="p">),</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">))</span>
                <span class="n">x_expanded</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">**</span><span class="p">(</span><span class="n">it</span><span class="o">+</span><span class="n">eps_pow_0</span><span class="p">)</span> <span class="o">*</span> <span class="n">xMMS_t</span><span class="p">[</span><span class="n">it</span><span class="p">]</span>
                
                <span class="c1"># Define time scales-dependent asymptotic terms</span>
                <span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Function</span><span class="p">(</span><span class="n">xMMS_t</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">))</span>
                
                <span class="c1"># Substitutions from xMMS(t) and its time derivatives to xMMS(*tS) and its time scales derivatives</span>
                <span class="n">sub_xMMS_t</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="p">[(</span><span class="n">xMMS_t</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">Chain_rule_d2fdt2</span><span class="p">(</span><span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">it</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)),</span> 
                                    <span class="p">(</span><span class="n">xMMS_t</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">Chain_rule_dfdt</span>  <span class="p">(</span><span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">it</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)),</span> 
                                    <span class="p">(</span><span class="n">xMMS_t</span><span class="p">[</span><span class="n">it</span><span class="p">]</span>               <span class="p">,</span> <span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">it</span><span class="p">])]</span> <span class="p">)</span>
            
            <span class="c1"># Substitutions from x to xMMS(t)</span>
            <span class="n">sub_x</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dynamical_system</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">x_expanded</span><span class="p">[</span><span class="n">ix</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">xMMS</span><span class="p">,</span> <span class="n">sub_xMMS_t</span><span class="p">,</span> <span class="n">sub_x</span></div>

        
<div class="viewcode-block" id="Multiple_scales_system.forcing_MMS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.forcing_MMS">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forcing_MMS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dynamical_system</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rewrite the forcing terms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dynamical_system : Dynamical_system</span>
<span class="sd">            The dynamical system.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The initial forcing terms are </span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            f_{F,i}(\boldsymbol{x}(t), \dot{\boldsymbol{x}}(t), \ddot{\boldsymbol{x}}(t)) F \cos(\omega t), \quad i=1,...,N.</span>
<span class="sd">        </span>
<span class="sd">        Rewritting them involves</span>

<span class="sd">        1. Replacing the :math:`x_i(t)` by their series expansions written in terms of time scales,</span>
<span class="sd">        </span>
<span class="sd">        2. Scaling the forcing and the parameters in :math:`f_{F,i}` if any,</span>
<span class="sd">        </span>
<span class="sd">        3. Truncating terms whose order is larger than the largest order retained in the MMS,</span>
<span class="sd">        </span>
<span class="sd">        4. Rewrite :math:`\cos(\omega t)` as </span>
<span class="sd">        </span>
<span class="sd">           .. math::</span>
<span class="sd">            \cos(\omega t) = \frac{1}{2} e^{\mathrm{j}(\omega_{\textrm{MMS}} + \epsilon \sigma)t} + cc = \frac{1}{2} e^{\mathrm{j}(\omega_{\textrm{MMS}}t_0 + \sigma t_1)} + cc.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Get the expression of the forcing frequency</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Get the forcing amplitude and order for the substitutions</span>
        <span class="n">forcing</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_scaling</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dynamical_system</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                <span class="n">dic_F_MMS</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">scaling_coeff</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dic_F_MMS</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">forcing</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">scaling_coeff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">f_order</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">scaling_coeff</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
                    <span class="n">f_order</span> <span class="o">=</span> <span class="mi">1</span> 
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_order</span> <span class="o">=</span> <span class="n">scaling_coeff</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    
                <span class="n">F</span>       <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dic_F_MMS</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">forcing</span> <span class="o">=</span> <span class="kc">True</span>
                
        <span class="k">if</span> <span class="ow">not</span> <span class="n">forcing</span><span class="p">:</span>
            <span class="n">F</span>       <span class="o">=</span> <span class="mi">0</span>
            <span class="n">f_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_pow_0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span>
            
        <span class="c1"># Get the forcing term for each oscillator</span>
        <span class="n">forcing_term</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fF</span>           <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sub_t</span><span class="p">,</span> <span class="n">sub_x</span><span class="p">,</span> <span class="n">sub_xMMS_t</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">,[</span><span class="s2">&quot;sub_t&quot;</span><span class="p">,</span> <span class="s2">&quot;sub_x&quot;</span><span class="p">,</span> <span class="s2">&quot;sub_xMMS_t&quot;</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="n">fF</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">dynamical_system</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">fF</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_scaling</span><span class="p">)</span>
                        <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_x</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_xMMS_t</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_t</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span>
                        <span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eps_pow_0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">())</span>
            
            <span class="n">forcing_term</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">fF</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">F</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">**</span><span class="n">f_order</span><span class="p">)</span>
                                <span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eps_pow_0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span> <span class="o">*</span> 
                                <span class="p">(</span><span class="n">exp</span><span class="p">(</span> <span class="n">I</span><span class="o">*</span><span class="p">((</span><span class="n">omega</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_t</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()))</span> <span class="o">+</span> 
                                 <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="p">((</span><span class="n">omega</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_t</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()))</span> <span class="p">)</span> 
                                <span class="p">)</span>
        
        <span class="n">forcing</span> <span class="o">=</span> <span class="n">Forcing_MMS</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">f_order</span><span class="p">,</span> <span class="n">fF</span><span class="p">,</span> <span class="n">forcing_term</span><span class="p">)</span>
    
        <span class="k">return</span> <span class="n">forcing</span></div>

    
<div class="viewcode-block" id="Multiple_scales_system.oscillators_frequencies">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.oscillators_frequencies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">oscillators_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the expression of every oscillator frequency in terms of the reference frequency, possibly with a detuning.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For the :math:`i^\textrm{th}` oscillator, this leads to </span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            \omega_i = r_i \omega_{\textrm{ref}} + \delta_i .</span>
<span class="sd">        </span>
<span class="sd">        An associated first-order natural frequency :math:`\omega_{i,0}` is defined by neglecting the detuning :math:`\delta_i`, which is at least of order :math:`\epsilon`, resulting in</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            \omega_{i,0} = r_i \omega_{\textrm{ref}}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_omegas</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Substitutions from the omegas to their expression in terms of omega_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omegas_O0</span>      <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Leading order oscillators&#39; natural frequencies</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            
            <span class="c1"># Check if ratio_omega_osc should be modified</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omega_osc</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">Mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega_ref</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omega_osc</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega_ref</span>
                <span class="k">elif</span> <span class="n">Mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega_ref</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omega_osc</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega_ref</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omega_osc</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_omegas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omega_osc</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">omega_ref</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">detunings</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">omegas_O0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omega_osc</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega_ref</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_omegas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">omegas_O0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">omegas</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="p">)</span></div>

        
        
<div class="viewcode-block" id="Multiple_scales_system.compute_EqMMS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.compute_EqMMS">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_EqMMS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dynamical_system</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the system of equations for each oscillator at each order of :math:`\epsilon`. This system is described in :class:`~MMS.MMS.Multiple_scales_system`.</span>

<span class="sd">        The output `EqMMS` is a list of lists:</span>

<span class="sd">        - The :math:`1^{\text{st}}` level lists are associated to the equations for each oscillator,</span>
<span class="sd">        </span>
<span class="sd">        - The :math:`2^{\text{nd}}` level lists are associated to the orders of :math:`\epsilon` from the lowest to the highest order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dynamical_system : Dynamical_system</span>
<span class="sd">            The dynamical system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="c1"># Equations with every epsilon appearing</span>
        <span class="n">sub_t</span><span class="p">,</span> <span class="n">sub_x</span><span class="p">,</span> <span class="n">sub_xMMS_t</span><span class="p">,</span> <span class="n">sub_scaling</span><span class="p">,</span> <span class="n">sub_omegas</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">,[</span><span class="s2">&quot;sub_t&quot;</span><span class="p">,</span> <span class="s2">&quot;sub_x&quot;</span><span class="p">,</span> <span class="s2">&quot;sub_xMMS_t&quot;</span><span class="p">,</span> <span class="s2">&quot;sub_scaling&quot;</span><span class="p">,</span> <span class="s2">&quot;sub_omegas&quot;</span><span class="p">]))</span>
    
        <span class="n">Eq_eps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="n">Eq_eps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">((</span><span class="n">dynamical_system</span><span class="o">.</span><span class="n">Eq</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_omegas</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_scaling</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
                             <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_x</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_xMMS_t</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_t</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span>
                          <span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eps_pow_0</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span> 
                          <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">forcing_term</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_pow_0</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Set the leading order to eps**0 = 1</span>
                <span class="n">Eq_eps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq_eps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps_pow_0</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
                
        <span class="c1"># MMS equations system</span>
        <span class="n">EqMMS</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            
            <span class="c1"># Initialise a list of the equations at each order. Start with the lowest order</span>
            <span class="n">EqMMSO</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq_eps</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()]</span> 
            
            <span class="c1"># What has to be substracted to keep only the terms of order eps**io in equation at order io.</span>
            <span class="n">retrieve_EqMMSO</span> <span class="o">=</span> <span class="n">EqMMSO</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
            
            <span class="c1"># Feed EqMMSO with higher orders of epsilon</span>
            <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">EqMMSO</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">((</span><span class="n">Eq_eps</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">io</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span> <span class="o">-</span> <span class="n">retrieve_EqMMSO</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">**</span><span class="n">io</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="p">)</span>
                
                <span class="c1"># Update the terms that are to be substracted at order io+1</span>
                <span class="n">retrieve_EqMMSO</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">**</span><span class="n">io</span> <span class="o">*</span> <span class="n">EqMMSO</span><span class="p">[</span><span class="n">io</span><span class="p">]</span>
                
            <span class="n">EqMMS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">EqMMSO</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">EqMMS</span> <span class="o">=</span> <span class="n">EqMMS</span></div>

        
<div class="viewcode-block" id="Multiple_scales_system.apply_MMS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.apply_MMS">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_MMS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rewrite_polar</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the MMS. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rewrite_polar : str, int or list of int, optional</span>
<span class="sd">            The orders at which the solutions will be rewritten in polar form.</span>
<span class="sd">            See :func:`sol_xMMS_polar`.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The application of the MMS is operated by successively calling the following methods.</span>

<span class="sd">        #. :func:`system_t0`: An equivalent system is written in terms of the fast time scale :math:`t_0`. </span>
<span class="sd">           This introduces the temporary unknowns :math:`\tilde{x}_{i,j}(t_0)` and allows the use of :func:`~sympy.solvers.ode.dsolve`.</span>

<span class="sd">        #. :func:`sol_order_0`: Leading order solutions :math:`x_{i,0}(\boldsymbol{t})` are defined.</span>

<span class="sd">        #. :func:`secular_analysis`: The leading order solutions are introduced in the equations and the secular terms at each order are identified. </span>
<span class="sd">           Cancelling those secular terms is a condition for bounded solutions. </span>
<span class="sd">           It leads to a system of equations governing the slow evolution of the complex amplitude of the homogeneous leading order solutions. </span>
<span class="sd">           Each equation takes the form </span>
<span class="sd">           </span>
<span class="sd">           .. math::</span>
<span class="sd">            \textrm{D}_{j} A_i(\boldsymbol{t}_s) = f_{A_i}^{(j)}(\boldsymbol{A}, t_1).</span>

<span class="sd">           After cancelling the secular terms the higher order equations are solved successively to express the higher order solutions :math:`x_{i,j}(\boldsymbol{t}),\; j&gt;0` in terms of the leading order ones.</span>

<span class="sd">        #. :func:`autonomous_phases`: The phase coordinates are changed from :math:`\phi_i(\boldsymbol{t}_s)` to :math:`\beta_i(\boldsymbol{t}_s)` to cancel the slow time :math:`t_1` in the secular terms. This will be used afterwards to obtain an autonomous system.</span>

<span class="sd">        #. :func:`evolution_equations`: The secular conditions are split into real and imaginary parts, polar coordinates are used and the autonomous phases are introduced,</span>
<span class="sd">           resulting in an autonomous system of evolution equations on polar coordinates. </span>
<span class="sd">           Equations come by two, one representing the amplitude evolution while the other represents the phase&#39;s, such that</span>
<span class="sd">           </span>
<span class="sd">           .. math::</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            \textrm{D}_{j} a_i(\boldsymbol{t}_s) &amp; = f_{a_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">            a_i \textrm{D}_{j} \beta_i(\boldsymbol{t}_s) &amp; = f_{\beta_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\beta}).</span>
<span class="sd">            \end{cases}</span>

<span class="sd">           This is the key result of the MMS. The evolution on each time scale are combined to reintroduce the physical time, resulting in a system of the form</span>

<span class="sd">           .. math::</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            \dfrac{\textrm{d}}{dt} a_i(t) &amp; = f_{a_i}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">            a_i \dfrac{\textrm{d}}{dt} \beta_i(t) &amp; = f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta}).</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        #. :func:`sol_xMMS_polar`: The leading and higher order solutions are rewritten in terms of polar coordinates using :math:`\cos` and :math:`\sin` functions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Write a temporary equivalent system depending only on t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">system_t0</span><span class="p">()</span>
        
        <span class="c1"># Compute the solutions at order 0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol_order_0</span><span class="p">()</span>

        <span class="c1"># Analyse the secular terms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">secular_analysis</span><span class="p">()</span>

        <span class="c1"># Change the phase coordinates for autonomous purposes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autonomous_phases</span><span class="p">()</span>

        <span class="c1"># Derive the evolution equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evolution_equations</span><span class="p">()</span>
        
        <span class="c1"># Write the x solutions in terms of polar coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol_xMMS_polar</span><span class="p">(</span><span class="n">rewrite_polar</span><span class="o">=</span><span class="n">rewrite_polar</span><span class="p">)</span></div>



<div class="viewcode-block" id="Multiple_scales_system.system_t0">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.system_t0">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">system_t0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rewrite the system with the fast time scale as the only independent variable.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a trick to use :func:`~sympy.solvers.ode.dsolve`, which only accepts functions of 1 variable, to solve higher order equations. </span>
<span class="sd">        The higher order equations are rewritten in terms of temporary coordinates :math:`\tilde{x}_{i,j}(t_0)` in place of :math:`x_{i,j}(\boldsymbol{t})`, with :math:`i,j` denoting the oscillator number and :math:`\epsilon` order, respectively. </span>
<span class="sd">        This is equivalent to temporary considering that :math:`\boldsymbol{A}(\boldsymbol{t}_s)` does not depend on the slow times, which is of no consequence as there are no slow time derivatives appearing in the higher order equations at this stage. </span>
<span class="sd">        Indeed, they were either substituted using the complex evolution equations, or they disappeared when eliminating the secular terms. </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">xMMS_t0</span>  <span class="o">=</span> <span class="p">[]</span> <span class="c1"># t0-dependent variables xij(t0). Higher time scales dependency is ignored.</span>
        <span class="n">EqMMS_t0</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Equations at each order with only t0 as an explicit variable. Leads to a harmonic oscillator at each order with a t0-periodic forcing coming from lower order solutions.</span>
        
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="n">xMMS_t0</span> <span class="o">.</span><span class="n">append</span><span class="p">([</span> <span class="n">Function</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\tilde{x_&#39;</span><span class="o">+</span><span class="s1">&#39;{{</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span><span class="n">io</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;}&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="p">)</span> <span class="p">])</span> 
            <span class="n">EqMMS_t0</span><span class="o">.</span><span class="n">append</span><span class="p">([</span> <span class="bp">self</span><span class="o">.</span><span class="n">EqMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xMMS_t0</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span> <span class="p">])</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">EqMMS_t0</span> <span class="o">=</span> <span class="n">EqMMS_t0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xMMS_t0</span>  <span class="o">=</span> <span class="n">xMMS_t0</span></div>

        
        
<div class="viewcode-block" id="Multiple_scales_system.sol_order_0">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.sol_order_0">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sol_order_0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the leading-order solutions for each oscillator. </span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For oscillator :math:`i`, the homogeneous solution takes the general form</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            x_{i,0}^{\textrm{h}}(\boldsymbol{t}) = A_i(\boldsymbol{t}_s) e^{\textrm{j} \omega_{i,0} t_0} + cc,</span>
<span class="sd">        </span>
<span class="sd">        where :math:`A_i(\boldsymbol{t}_s)` is an unknown complex amplitude.</span>
<span class="sd">        </span>
<span class="sd">        If the oscillator is subject to hard forcing (i.e. forcing appears at leading order), then the particular solution</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            x_{i,0}^{\textrm{p}}(t_0, t_1) = B_i e^{\textrm{j} \omega t} + cc = B_i e^{\textrm{j} (\omega_{\textrm{MMS}} t_0 + \sigma t_1)} + cc</span>
<span class="sd">        </span>
<span class="sd">        is also taken into account. :math:`B_i` is a time-independent function of the forcing parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Information</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Definition of leading order multiple scales solutions&#39;</span><span class="p">)</span>
        
        <span class="c1"># Initialisation</span>
        <span class="n">xMMS0</span>    <span class="o">=</span> <span class="p">[]</span> <span class="c1"># leading order solutions</span>
        <span class="n">sub_xMMS</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Substitutions from xij to its solution</span>
        <span class="n">sub_B</span>    <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Substitutions from the particular solution amplitude Bi to its expression</span>
        
        <span class="c1"># Compute the solutions</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            
            <span class="c1"># Homogeneous leading order solution </span>
            <span class="n">xMMS0_h_ix</span> <span class="o">=</span> <span class="p">(</span>            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas_O0</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
                          <span class="o">+</span> <span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas_O0</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">)</span>
            
            <span class="c1"># Particular leading order solution - if the equation is not homogeneous (due to hard forcing)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">EqMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas_O0</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">hint</span><span class="o">=</span><span class="s2">&quot;nth_linear_constant_coeff_undetermined_coefficients&quot;</span>
                
                <span class="c1"># General solution, containing both homogeneous and particular solutions</span>
                <span class="n">xMMS0_sol_general</span> <span class="o">=</span> <span class="p">(</span> <span class="n">dsolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EqMMS_t0</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMMS_t0</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">hint</span><span class="o">=</span><span class="n">hint</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">rhs</span>
                
                <span class="c1"># Cancel the homogeneous solutions</span>
                <span class="n">C</span>      <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xMMS0_sol_general</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EqMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)))</span>
                <span class="n">sub_IC</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Ci</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">Ci</span> <span class="ow">in</span> <span class="n">C</span><span class="p">]</span>
                <span class="n">xMMS0_p_ix</span> <span class="o">=</span> <span class="n">xMMS0_sol_general</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_IC</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
                
                <span class="c1"># Get the real amplitude of the particular solution</span>
                <span class="n">exp_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xMMS0_p_ix</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">exp_keys</span><span class="p">:</span>
                    <span class="n">sub_B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">xMMS0_p_ix</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">exp_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Static hard forcing is currently not handled&quot;</span><span class="p">)</span>
                
                <span class="c1"># Rewrite the particular solution in terms of B for the sake of readability and computational efficiency</span>
                <span class="n">xMMS0_p_ix</span> <span class="o">=</span> <span class="p">(</span>          <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_omega</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_t</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">+</span> 
                              <span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">B</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_omega</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_t</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span>
                    
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xMMS0_p_ix</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                
            <span class="c1"># Total leading order solution</span>
            <span class="n">xMMS0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">xMMS0_h_ix</span> <span class="o">+</span> <span class="n">xMMS0_p_ix</span> <span class="p">)</span> 
            <span class="n">sub_xMMS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xMMS0</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
        
        <span class="c1"># Store the solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">xMMS</span> <span class="o">=</span> <span class="p">[[</span><span class="n">xMMS0_dof</span><span class="p">]</span> <span class="k">for</span> <span class="n">xMMS0_dof</span> <span class="ow">in</span> <span class="n">xMMS0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_xMMS</span> <span class="o">=</span> <span class="n">sub_xMMS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_B</span>    <span class="o">=</span> <span class="n">sub_B</span></div>

        
<div class="viewcode-block" id="Multiple_scales_system.secular_analysis">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.secular_analysis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">secular_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify the secular terms in the MMS equations. </span>
<span class="sd">        This allows to:</span>

<span class="sd">        1. Compute the evolution equations of the complex amplitudes :math:`A_i(\boldsymbol{t}_s)`, coming from the elimination of the secular terms,</span>
<span class="sd">        </span>
<span class="sd">        2. Derive nonsecular MMS equations, i.e. MMS equations with the secular terms cancelled,</span>
<span class="sd">        </span>
<span class="sd">        3. Use the nonsecular equations to express the higher order solutions :math:`x_{i,j}(\boldsymbol{t}),\; j&gt;0` in terms of the :math:`\boldsymbol{A}(\boldsymbol{t}_s)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Information</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Secular analysis&quot;</span><span class="p">)</span>
        
        <span class="c1"># Initialisations - secular analysis</span>
        <span class="n">DA_sol</span>     <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Solutions Di(Aj) cancelling the secular terms for each oscillator j, in terms of Aj </span>
        <span class="n">sub_DA_sol</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Substitutions from DiAj to its solution </span>
        <span class="n">sec</span>        <span class="o">=</span> <span class="p">[]</span> <span class="c1"># The ith secular term in the equations of the jth oscillator is written only in terms of Di(Aj) and Aj (i.e. Dk(Aj) with k&lt;i are substituted for their solution)</span>
        
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="n">DA_sol</span>    <span class="o">.</span><span class="n">append</span><span class="p">([</span> <span class="mi">0</span> <span class="p">])</span> <span class="c1"># dAi/dt0 = 0 </span>
            <span class="n">sub_DA_sol</span><span class="o">.</span><span class="n">append</span><span class="p">([</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">)]</span> <span class="p">)</span>
            <span class="n">sec</span>       <span class="o">.</span><span class="n">append</span><span class="p">([</span> <span class="mi">0</span><span class="p">])</span>
        
        <span class="n">E</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">)</span> <span class="c1"># Symbol to substitue exponentials and use collect() in the following</span>
        
        <span class="c1"># Computation of the secular terms, DA solutions, equations with the secular terms cancelled and x solutions in terms of A</span>
        <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   Analysing the secular terms at order </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">io</span><span class="p">))</span>
            
            <span class="c1"># Substitutions from x(t0, t1, ...) to x(t0) at order io to use sy.dsolve() in the following</span>
            <span class="n">sub_xMMS_t0</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMMS_t0</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">])</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span> <span class="p">]</span>
            
            <span class="c1"># Substitute the solutions at previous orders in the MMS equations and make it t0-dependent. Contains the secular terms.</span>
            <span class="n">EqMMS_t0_sec</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">EqMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_xMMS</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_xMMS_t0</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span> <span class="p">]</span> 
            
            <span class="c1"># Find the secular terms and deduce the D(A) that cancel them</span>
            <span class="n">dicE</span> <span class="o">=</span> <span class="p">[]</span> 
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
                
                <span class="c1"># Define the exponential corresponding to secular terms</span>
                <span class="n">sub_exp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">exp</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas_O0</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">E</span><span class="p">)]</span> <span class="c1"># Substitute exp(I*omegas_O0*t0) by E to use sy.collect() in the following</span>
                
                <span class="c1"># Substitute the low order DA to get rid of all A derivatives except the current one</span>
                <span class="n">EqMMS_t0_sec</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">sfun</span><span class="o">.</span><span class="n">sub_deep</span><span class="p">(</span><span class="n">EqMMS_t0_sec</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">sub_DA_sol</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>
                
                <span class="c1"># Identify the secular term</span>
                <span class="n">dicE_ix</span> <span class="o">=</span> <span class="n">EqMMS_t0_sec</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_exp</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">E</span> <span class="ow">in</span> <span class="n">dicE_ix</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">sec_ix</span>  <span class="o">=</span> <span class="n">dicE_ix</span><span class="p">[</span><span class="n">E</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sec_ix</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">dicE</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dicE_ix</span><span class="p">)</span>
                
                <span class="c1"># Solve D(A) such that the secular term is cancelled</span>
                <span class="n">DA_sol</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">solve</span><span class="p">(</span><span class="n">sec_ix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="n">io</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="c1"># Solution for the current D(A) cancelling the secular terms</span>
                <span class="n">sub_DA_sol</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="n">io</span><span class="p">]),</span> <span class="n">DA_sol</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span> <span class="p">)</span>
            
                <span class="c1"># Store the current secular term</span>
                <span class="n">sec</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sec_ix</span><span class="p">)</span>
                
            <span class="c1"># Substitute the expression of the just computed DA in EqMMS_t0_sec to obtain nonsecular equations governing xMMS_t0 at the current order</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">EqMMS_t0</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">EqMMS_t0_sec</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_DA_sol</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span>
            
            <span class="c1"># Compute the x solution at order io in terms of the amplitudes A</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   Computing the higher order solutions at order </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">io</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">sol_higher_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EqMMS_t0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xMMS_t0</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">ix</span><span class="p">)</span>
            
        <span class="c1"># Store the solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sec</span>  <span class="o">=</span> <span class="n">sec</span>      <span class="c1"># Secular terms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">DA</span>   <span class="o">=</span> <span class="n">DA_sol</span>   <span class="c1"># Solutions that cancel the secular terms</span></div>

    
<div class="viewcode-block" id="Multiple_scales_system.sol_higher_order">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.sol_higher_order">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sol_higher_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">EqMMS_t0</span><span class="p">,</span> <span class="n">xMMS_t0</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">ix</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the higher order solutions :math:`x_{i,j}(\boldsymbol{t}_s),\; j&gt;0`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        EqMMS_t0 : list of list of sympy.Expr</span>
<span class="sd">            The MMS equations at each order and for each oscillator written with :math:`t_0` as the only independent variable. </span>
<span class="sd">        xMMS_t0 : list of list of sympy.Function</span>
<span class="sd">            Oscillators&#39; response at each order written in terms of :math:`t_0` only, :math:`\tilde{x}_{i,j}(t_0)`.</span>
<span class="sd">        io : int</span>
<span class="sd">            The order of :math:`\epsilon`.</span>
<span class="sd">        ix : int</span>
<span class="sd">            The dof number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Hint for dsolve()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">EqMMS_t0</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span> <span class="o">==</span> <span class="n">xMMS_t0</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omegas_O0</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xMMS_t0</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]:</span>
            <span class="n">hint</span><span class="o">=</span><span class="s2">&quot;nth_linear_constant_coeff_undetermined_coefficients&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hint</span><span class="o">=</span><span class="s2">&quot;default&quot;</span>
        
        <span class="c1"># General solution, containing both homogeneous and particular solutions</span>
        <span class="n">xMMS_sol_general</span> <span class="o">=</span> <span class="p">(</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">EqMMS_t0</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">],</span> <span class="n">xMMS_t0</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">],</span> <span class="n">hint</span><span class="o">=</span><span class="n">hint</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">rhs</span>
        
        <span class="c1"># Cancel the homogeneous solutions</span>
        <span class="n">C</span>      <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xMMS_sol_general</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">EqMMS_t0</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)))</span>
        <span class="n">sub_IC</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Ci</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">Ci</span> <span class="ow">in</span> <span class="n">C</span><span class="p">]</span>
        
        <span class="c1"># Append the solution for dof ix at order io</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xMMS_sol_general</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_IC</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span>
        
        <span class="c1"># Update the list of substitutions from the x to their expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_xMMS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">])</span> <span class="p">)</span></div>

        
        
<div class="viewcode-block" id="Multiple_scales_system.polar_coordinates">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.polar_coordinates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">polar_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define the polar coordinates.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Define polar coordinates such that, for oscillator :math:`i`, the complex amplitude of the homogeneous leading order solution is defined as</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            A_i(\boldsymbol{t}_s) = \frac{1}{2} a_i(\boldsymbol{t}_s) e^{\textrm{j} \phi_i(\boldsymbol{t}_s)},</span>

<span class="sd">        where :math:`a_i(\boldsymbol{t}_s)` and :math:`\phi_i(\boldsymbol{t}_s)` are the solution&#39;s amplitude and phase, respectively. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span>   <span class="o">=</span> <span class="p">[</span> <span class="n">Function</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;a_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>   <span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Function</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\phi_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>               <span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_A</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)]</span></div>

        
    
<div class="viewcode-block" id="Multiple_scales_system.autonomous_phases">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.autonomous_phases">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">autonomous_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define phase coordinates that render an autonomous system.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Define new phase coordinates :math:`\beta_i` to transform nonautonomous equations into autonomous ones. </span>
<span class="sd">        The :math:`\beta_i` are defined as</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            \beta_i = - \frac{r_{\textrm{MMS}}}{r_i} \phi_i + \sigma t_1,</span>
<span class="sd">        </span>
<span class="sd">        where we recall that</span>
<span class="sd">        :math:`\omega = r_{\textrm{MMS}} \omega_{\textrm{ref}} + \epsilon \sigma` and</span>
<span class="sd">        :math:`\omega_{i,0} = r_i \omega_{\textrm{ref}}`. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span>   <span class="o">=</span> <span class="p">[</span> <span class="n">Function</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\beta_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>                                            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">def_beta</span>          <span class="o">=</span> <span class="p">[</span> <span class="o">-</span> <span class="n">Rational</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio_omegaMMS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omega_osc</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">def_phi</span>           <span class="o">=</span> <span class="p">[</span> <span class="n">solve</span><span class="p">(</span><span class="n">def_beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">ix</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>                                       <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_phi</span>  <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">def_phi</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>                                                                    <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_beta</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">def_beta</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>                                                                  <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span> <span class="p">]</span></div>


<div class="viewcode-block" id="Multiple_scales_system.evolution_equations">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.evolution_equations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evolution_equations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derive the evolution equations of the polar coordinates system.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derive the evolution equations of the polar coordinates system (defined in :func:`polar_coordinates` and :func:`autonomous_phases`) from the secular conditions. For oscillator :math:`i`, these are defined as</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            \dfrac{\textrm{d} a_i}{\textrm{d} t}         &amp; = f_{a_i}(\boldsymbol{a}, \boldsymbol{\beta}), \\</span>
<span class="sd">            a_i \dfrac{\textrm{d} \beta_i}{\textrm{d} t} &amp; = f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta}),</span>
<span class="sd">            \end{cases}</span>
<span class="sd">        </span>
<span class="sd">        where :math:`\boldsymbol{a}` and :math:`\boldsymbol{\beta}` are vectors containing the polar amplitudes and phases.</span>

<span class="sd">        The aim here is to compute all the :math:`f_{a_i}` and :math:`f_{\beta_i}`.</span>
<span class="sd">        This is done by:</span>
<span class="sd">        </span>
<span class="sd">        #. Introducing polar coordinates in the secular terms</span>
<span class="sd">        </span>
<span class="sd">        #. Splitting the real and imaginary parts of the (complex) secular terms</span>
<span class="sd">        </span>
<span class="sd">        #. Using the autonomous phase coordinates</span>
<span class="sd">        </span>
<span class="sd">        #. Collecting the terms governing the slow amplitude and phase dynamics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Information</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing the evolution equations&#39;</span><span class="p">)</span>

        <span class="c1"># Initialisation</span>
        <span class="n">sec_re</span>    <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">dummy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)]</span> <span class="c1"># Real part of the secular terms</span>
        <span class="n">sec_im</span>    <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">dummy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)]</span> <span class="c1"># Imaginary part of the secular terms</span>
        <span class="n">sub_re_im</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># To overcome a sympy limitation: derivatives of real functions w.r.t. a real variable are not recognised as real</span>
        
        <span class="n">faO</span>    <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">dummy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)]</span> <span class="c1"># Defined as      Di(a) = faO[i](a,beta)</span>
        <span class="n">fbetaO</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">dummy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)]</span> <span class="c1"># Defined as a*Di(beta) = fbetaO[i](a,beta)</span>
        <span class="n">fa</span>     <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">dummy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)]</span>  <span class="c1"># Defined as      da/dt = fa(a,beta)</span>
        <span class="n">fbeta</span>  <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">dummy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)]</span>  <span class="c1"># Defined as a*dbeta/dt = fbeta(a,beta)</span>
        
        <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            
            <span class="c1"># print(&quot;    Evolution equations at order {}&quot;.format(io))</span>
            
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>

                <span class="c1"># Order 0 -&gt; there are no secular terms</span>
                <span class="k">if</span> <span class="n">io</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">sec_re</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">sec_im</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">faO</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                    <span class="n">fbetaO</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
                
                <span class="c1"># Deal with the secular terms at order eps**io</span>
                <span class="k">else</span><span class="p">:</span>        
                    
                    <span class="c1"># State that da/dti and dphi/dti are real</span>
                    <span class="n">sub_re_im</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="p">[(</span><span class="n">re</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="n">io</span><span class="p">]))</span>  <span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="n">io</span><span class="p">])</span>  <span class="p">),</span>
                                       <span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="n">io</span><span class="p">]))</span>  <span class="p">,</span> <span class="mi">0</span>                                   <span class="p">),</span>
                                       <span class="p">(</span><span class="n">re</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="n">io</span><span class="p">])),</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="n">io</span><span class="p">])),</span>
                                       <span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="n">io</span><span class="p">])),</span> <span class="mi">0</span>                                   <span class="p">)]</span> <span class="p">)</span>
                    
                    <span class="c1"># Split sec into real and imaginary parts and change phase coordinates from phi to beta</span>
                    <span class="n">sec_re</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">re</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sec</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">ix</span><span class="p">]))</span>
                                          <span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_A</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="p">)</span>
                                      <span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_re_im</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_phi</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="p">)</span>
                    
                    <span class="n">sec_im</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">im</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sec</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">phi</span><span class="p">[</span><span class="n">ix</span><span class="p">]))</span>
                                          <span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_A</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="p">)</span>
                                      <span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_re_im</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_phi</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="p">)</span>
                    
                    <span class="c1"># Derive the evolution equations at each order</span>
                    <span class="n">faO</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>   <span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">solve</span><span class="p">(</span><span class="n">sec_im</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>   <span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="n">io</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>                  <span class="p">)</span>
                    <span class="n">fbetaO</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">solve</span><span class="p">(</span><span class="n">sec_re</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="n">io</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="p">)</span>
                    
                    <span class="c1"># Global evolution equations</span>
                    <span class="n">fa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>    <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">**</span><span class="n">io</span> <span class="o">*</span> <span class="n">faO</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span>
                    <span class="n">fbeta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">**</span><span class="n">io</span> <span class="o">*</span> <span class="n">fbetaO</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span>
        
        <span class="c1"># Store the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">faO</span>    <span class="o">=</span> <span class="n">faO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fbetaO</span> <span class="o">=</span> <span class="n">fbetaO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fa</span>     <span class="o">=</span> <span class="n">fa</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fbeta</span>  <span class="o">=</span> <span class="n">fbeta</span></div>

                    

<div class="viewcode-block" id="Multiple_scales_system.sol_xMMS_polar">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.sol_xMMS_polar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sol_xMMS_polar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rewrite_polar</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the solutions using the polar coordinates and :math:`\cos` and :math:`\sin` functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rewrite_polar : str or int or list of int or optional</span>
<span class="sd">            The orders at which the solutions will be rewritten in polar form.</span>
<span class="sd">            If ``&quot;all&quot;``, then all solution orders will be rewritten.</span>
<span class="sd">            If `int`, then only a single order will be rewritten.</span>
<span class="sd">            If `list` of `int`, then the listed orders will be rewritten.</span>
<span class="sd">            Default is 0, so only the leading order solution will be rewritten.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Information</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rewritting the solutions in polar form&quot;</span><span class="p">)</span>
        
        <span class="c1"># Orders to rewrite</span>
        <span class="k">if</span> <span class="n">rewrite_polar</span><span class="o">==</span><span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">rewrite_polar</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rewrite_polar</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">rewrite_polar</span> <span class="o">=</span> <span class="p">[</span><span class="n">rewrite_polar</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">rewrite_polar</span><span class="p">)</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Trying to rewrite a solution order that exceeds the maximum order computed.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Prepare substitutions</span>
        <span class="n">sub_t_back</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_t</span><span class="p">]</span>
        <span class="n">sub_sigma</span>  <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">omegaMMS</span><span class="p">)]</span>
        
        <span class="c1"># Prepare the collection of sin and cos terms</span>
        <span class="n">harmonics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_harmonics</span><span class="p">()</span>
        <span class="n">collect_omega</span> <span class="o">=</span> <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">h</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">harmonics</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">cos</span><span class="p">(</span><span class="n">h</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">harmonics</span><span class="p">]</span>
        
        <span class="c1"># Rewrite the solutions</span>
        <span class="n">xMMS_polar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">x</span>          <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">dummy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="n">xMMS_polar</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="n">rewrite_polar</span><span class="p">:</span>
                <span class="n">xMMS_polar</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">TR10</span><span class="p">(</span><span class="n">TR8</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">xMMS</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span>
                                        <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_A</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
                                        <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_phi</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span> 
                                      <span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">cos</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span> 
                                      <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_t_back</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_sigma</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">())</span> 
                                      <span class="o">.</span><span class="n">expand</span><span class="p">()</span>
                                      <span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">collect_omega</span><span class="p">)</span>
                                      <span class="p">)</span>
            <span class="k">if</span> <span class="n">rewrite_polar</span> <span class="o">==</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># Construct the full response if relevant</span>
                <span class="n">x</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">**</span><span class="p">(</span><span class="n">io</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eps_pow_0</span><span class="p">)</span> <span class="o">*</span> <span class="n">xMMS_polar</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span> <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;all solution orders were not rewritten in polar form&quot;</span>
        <span class="c1"># Store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">xMMS_polar</span> <span class="o">=</span> <span class="n">xMMS_polar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">x</span>          <span class="o">=</span> <span class="n">x</span></div>


    
<div class="viewcode-block" id="Multiple_scales_system.find_harmonics">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Multiple_scales_system.find_harmonics">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_harmonics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the harmonics contained in the MMS solutions. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        harmonics: list</span>
<span class="sd">            list of the harmonics appearing in the MMS solutions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">list_xMMS</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">xMMS</span><span class="p">))</span>
        <span class="n">harmonics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">xMMS_ix</span> <span class="ow">in</span> <span class="n">list_xMMS</span><span class="p">:</span>
            <span class="n">exponents</span> <span class="o">=</span> <span class="p">[</span><span class="n">exp_term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">exp_term</span> <span class="ow">in</span> <span class="n">xMMS_ix</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">exp</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">exponent</span> <span class="ow">in</span> <span class="n">exponents</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">exponent</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span> <span class="ow">and</span> <span class="n">im</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">harmonics</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">exponent</span><span class="o">/</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">omega_ref</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omegaMMS</span> <span class="p">)</span>
            
        <span class="n">harmonics</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">harmonics</span><span class="p">))</span>
        <span class="n">harmonics</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">harmonics</span></div>
</div>

    
<div class="viewcode-block" id="Substitutions_MMS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Substitutions_MMS">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Substitutions_MMS</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Substitutions used in the MMS.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_t</span><span class="p">,</span> <span class="n">sub_xMMS_t</span><span class="p">,</span> <span class="n">sub_x</span><span class="p">,</span> <span class="n">sub_scaling</span><span class="p">,</span> <span class="n">sub_omega</span><span class="p">,</span> <span class="n">sub_sigma</span><span class="p">):</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_t</span>            <span class="o">=</span> <span class="n">sub_t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_xMMS_t</span>       <span class="o">=</span> <span class="n">sub_xMMS_t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_x</span>            <span class="o">=</span> <span class="n">sub_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_scaling</span>      <span class="o">=</span> <span class="n">sub_scaling</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_scaling_back</span> <span class="o">=</span> <span class="n">sub_scaling</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_omega</span>        <span class="o">=</span> <span class="n">sub_omega</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_sigma</span>        <span class="o">=</span> <span class="n">sub_sigma</span></div>

        
<div class="viewcode-block" id="Forcing_MMS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Forcing_MMS">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Forcing_MMS</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define the forcing on the system as</span>
<span class="sd">    </span>
<span class="sd">    - A forcing amplitude `F`</span>
<span class="sd">    </span>
<span class="sd">    - A scaling order `f_order` for the forcing</span>
<span class="sd">    </span>
<span class="sd">    - Forcing coefficients `fF`</span>
<span class="sd">    </span>
<span class="sd">    - Forcing terms (direct or parametric) `forcing_term`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">f_order</span><span class="p">,</span> <span class="n">fF</span><span class="p">,</span> <span class="n">forcing_term</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span>       <span class="o">=</span> <span class="n">F</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_order</span> <span class="o">=</span> <span class="n">f_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fF</span>      <span class="o">=</span> <span class="n">fF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing_term</span> <span class="o">=</span> <span class="n">forcing_term</span></div>

        
<div class="viewcode-block" id="Coord_MMS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Coord_MMS">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Coord_MMS</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The coordinates used in the MMS.</span>
<span class="sd">    &quot;&quot;&quot;</span>      
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mms</span><span class="p">):</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Complex amplitudes of the homogeneous leading order solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Real amplitudes of the particular leading order solutions (nonzero only if the forcing is hard)</span>
        
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Function</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;A_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span> <span class="nb">complex</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="o">*</span><span class="n">mms</span><span class="o">.</span><span class="n">tS</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">)</span> 
            
            <span class="k">if</span> <span class="n">mms</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">f_order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Condition for hard forcing</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;B_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="p">)</span> </div>


<div class="viewcode-block" id="Sol_MMS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Sol_MMS">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Sol_MMS</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solutions obtained when applying the MMS.</span>
<span class="sd">    &quot;&quot;&quot;</span>                
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>



<div class="viewcode-block" id="Steady_state">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Steady_state</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Steady state analysis of the multiple scales system.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mms : Multiple_scales_system</span>
<span class="sd">        The multiple scales system.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Description of the steady state analysis.</span>

<span class="sd">    ----------------------</span>
<span class="sd">    Steady state solutions</span>
<span class="sd">    ----------------------</span>

<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">    Steady state conditions</span>
<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^^</span>

<span class="sd">    At steady state, the solutions&#39; amplitudes and phases are time-independent. One therefore has, for each oscillator :math:`i=1,...,N`,</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        \dfrac{\textrm{d}}{dt} a_i &amp; = 0, \\</span>
<span class="sd">        \dfrac{\textrm{d}}{dt} \beta_i &amp; = 0, \\</span>
<span class="sd">        \end{cases}</span>
<span class="sd">    </span>
<span class="sd">    and the homogeneous steady state solutions take the form</span>

<span class="sd">    .. math::</span>
<span class="sd">        x^{\textrm{h}}_{i,0}(t) = a_i \cos\left( \frac{r_i}{r_{\textrm{MMS}}} \omega t - \frac{r_i}{r_{\textrm{MMS}}} \beta_i \right).    </span>
<span class="sd">    </span>
<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">    MMS evolution equations at steady state</span>
<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

<span class="sd">    The steady state amplitudes :math:`\boldsymbol{a}` and phases :math:`\boldsymbol{\beta}` are governed by the evolution equations evaluated at steady state, which take the form</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">        f_{a_0}(\boldsymbol{a}, \boldsymbol{\beta})     &amp; = 0, \\</span>
<span class="sd">        f_{\beta_0}(\boldsymbol{a}, \boldsymbol{\beta}) &amp; = 0, \\</span>
<span class="sd">        &amp; \vdots \\</span>
<span class="sd">        f_{a_{N-1}}(\boldsymbol{a}, \boldsymbol{\beta})     &amp; = 0, \\</span>
<span class="sd">        f_{\beta_{N-1}}(\boldsymbol{a}, \boldsymbol{\beta}) &amp; = 0.</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    This is now an algebraic system of equations. </span>

<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">    MMS solutions at steady state</span>
<span class="sd">    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

<span class="sd">    Solving the evolution equations at steady state yields the steady state solutions :math:`\boldsymbol{a}, \boldsymbol{\beta}`. </span>
<span class="sd">    The system can be solved directly for :math:`\boldsymbol{a}` and :math:`\boldsymbol{\beta}`, yielding explicit analytical solutions, but this is often complex as the system is nonlinear. </span>

<span class="sd">    A possibility that is sometimes available to obtain **analytical solutions** is to rearrange the equations to isolate the phase terms :math:`\cos(f(\boldsymbol{\beta})),\; \sin(f(\boldsymbol{\beta}))` where :math:`f(\boldsymbol{\beta})` is a linear function of the :math:`\beta_i`. </span>
<span class="sd">    Then the equations can be squared and summed up to obtain an equation on :math:`a_i` only and/or :math:`a_j` as a function of :math:`a_i`. The :math:`a_j` can be expressed as a function of :math:`a_i`, leading to a polynomial equation on :math:`a_i`.</span>
<span class="sd">    The resulting polynomial equation can rarely be solved directly as the polynomial involved are often of high order. </span>
<span class="sd">    However, the polynomial is often quadratic in the detuning :math:`\sigma` and forcing amplitude :math:`F`. </span>
<span class="sd">    It can therefore be solved for :math:`\sigma` and :math:`F` with :math:`a_i` seen as a parameter. </span>
<span class="sd">    This yields an implicit solution for :math:`a_i(\sigma) \Rightarrow a_i(\omega)` and :math:`a_i(F)`, from which one can deduce the other amplitudes :math:`a_j` and phases :math:`\boldsymbol{\beta}`, thus reconstructing the oscillators&#39; solutions.</span>
<span class="sd">    </span>
<span class="sd">    The processus described above is not always feasible. The blocking points are typically to </span>

<span class="sd">    (i) get rid of phase terms :math:`\cos(f(\boldsymbol{\beta})),\; \sin(f(\boldsymbol{\beta}))` in the equations, </span>

<span class="sd">    (ii) express every amplitude :math:`a_j` in terms of a single one, :math:`a_i`,</span>

<span class="sd">    (iii) end up with a polynomial of order 2 in :math:`\sigma` and :math:`F` </span>
<span class="sd">    </span>
<span class="sd">    These difficulties become more pronounced when the system involves several oscillator, in which case the amplitudes and phases may only be **computed numerically**.</span>

<span class="sd">    To facilitate the derivation of an analytical solution, it is possible to consider the **backbone curve** (bbc) of the forced solution rather than the forced solution itself. </span>
<span class="sd">    This bbc is computed in the absence of damping and forcing, therefore simplifying the system. Typically, this reduces the number of phase terms appearing. </span>
<span class="sd">    The solving procedure is then the same as that described previously.</span>

<span class="sd">    ------------------</span>
<span class="sd">    Stability analysis</span>
<span class="sd">    ------------------</span>
<span class="sd">    The stability analysis is described in details in :func:`stability_analysis`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the MMS quantities at steady state. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Information</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initialisation of the steady state analysis&#39;</span><span class="p">)</span>
        
        <span class="c1"># Small parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">eps</span>
        
        <span class="c1"># MMS frequencies of interest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega_ref</span>      <span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">omega_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omegaMMS</span> <span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">ratio_omegaMMS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>          <span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omegaMMS</span>       <span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">omegaMMS</span>
        
        <span class="c1"># Oscillators&#39; internal resonances relations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omega_osc</span> <span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">ratio_omega_osc</span>
        
        <span class="c1"># Number of dof</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span> <span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">ndof</span>
        
        <span class="c1"># Substitutions (initialisation)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span> <span class="o">=</span> <span class="n">Substitutions_SS</span><span class="p">(</span><span class="n">mms</span><span class="p">)</span>
    
        <span class="c1"># Forcing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span> <span class="o">=</span> <span class="n">Forcing_SS</span><span class="p">(</span><span class="n">mms</span><span class="p">)</span>
        
        <span class="c1"># Coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">Coord_SS</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polar_coordinates_SS</span><span class="p">(</span><span class="n">mms</span><span class="p">)</span>
        
        <span class="c1"># Solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span> <span class="o">=</span> <span class="n">Sol_SS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mms</span><span class="p">)</span>
        
        <span class="c1"># Stability</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stab</span> <span class="o">=</span> <span class="n">Stab_SS</span><span class="p">()</span>
        
        <span class="c1"># Evolution equations at steady state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evolution_equations_SS</span><span class="p">(</span><span class="n">mms</span><span class="p">)</span>
        
    
<div class="viewcode-block" id="Steady_state.polar_coordinates_SS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.polar_coordinates_SS">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">polar_coordinates_SS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Introduce time-independent amplitudes and phases (polar coordinates).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">a</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">sub_SS</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="n">a</span>   <span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;a_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span><span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">beta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\beta_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span><span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">sub_SS</span> <span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="p">[(</span><span class="n">mms</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]),</span> <span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">])]</span> <span class="p">)</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span>    <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_SS</span> <span class="o">=</span> <span class="n">sub_SS</span></div>

        
<div class="viewcode-block" id="Steady_state.evolution_equations_SS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.evolution_equations_SS">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evolution_equations_SS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the evolution equations at steady state (polar system).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">fa</span><span class="p">,</span> <span class="n">fbeta</span><span class="p">,</span> <span class="n">faO</span><span class="p">,</span> <span class="n">fbetaO</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="n">fa</span>    <span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">mms</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>   <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_SS</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">.</span><span class="n">collect</span><span class="p">([</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]),</span> <span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">])])</span> <span class="p">)</span>
            <span class="n">fbeta</span> <span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">mms</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fbeta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_SS</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">.</span><span class="n">collect</span><span class="p">([</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]),</span> <span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">])])</span> <span class="p">)</span>
        
            <span class="n">faO</span>    <span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="n">mms</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">faO</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span>   <span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_SS</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">.</span><span class="n">collect</span><span class="p">([</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]),</span> <span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">])])</span> <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="p">)</span>
            <span class="n">fbetaO</span> <span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="n">mms</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fbetaO</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">io</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_SS</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">.</span><span class="n">collect</span><span class="p">([</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]),</span> <span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">])])</span> <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">Ne</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fa</span>     <span class="o">=</span> <span class="n">fa</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fbeta</span>  <span class="o">=</span> <span class="n">fbeta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">faO</span>    <span class="o">=</span> <span class="n">faO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fbetaO</span> <span class="o">=</span> <span class="n">fbetaO</span>
        
        <span class="c1"># Check if the evolution equations are autonomous</span>
        <span class="k">if</span> <span class="s1">&#39;t_1&#39;</span> <span class="ow">in</span> <span class="n">srepr</span><span class="p">(</span><span class="n">fa</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;t_1&#39;</span> <span class="ow">in</span> <span class="n">srepr</span><span class="p">(</span><span class="n">fbeta</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The evolution equations do not form an autonomous system&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Steady_state.solve_forced">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.solve_forced">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_forced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solve_dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the forced response of an oscillator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        solve_dof: None or int, optional</span>
<span class="sd">            The oscillator to solve for. </span>
<span class="sd">            If `None`, no oscillator is solved for.</span>
<span class="sd">            Default is `None`.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Find the steady state solution for a given oscillator with the other oscillators&#39; amplitude set to 0.</span>

<span class="sd">        To do so, one must choose an oscillator to chose for, say oscillator :math:`i`. Then, the following methods are called: </span>
<span class="sd">        </span>
<span class="sd">        #. :func:`substitution_solve_dof`: Set the other oscillators&#39; amplitude to 0, i.e. :math:`a_j = 0 \; \forall j \neq i`.</span>

<span class="sd">        #. :func:`solve_phase`: express the oscillator&#39;s phase :math:`\beta_i` as a function of its amplitude :math:`a_i`. </span>

<span class="sd">        #. :func:`solve_sigma`: find the expression of :math:`\sigma(a_i)`.</span>

<span class="sd">        #. :func:`solve_a`: find the expression of :math:`a_i (\sigma, F)`.</span>
<span class="sd">                </span>
<span class="sd">        #. :func:`solve_F`: find the expression of :math:`F(a_i)`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Conditions for not solving the forced response</span>
        <span class="k">if</span> <span class="n">solve_dof</span><span class="o">==</span><span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="c1"># Information</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing the forced response for oscillator </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">solve_dof</span><span class="p">))</span>
        
        <span class="c1"># Store the oscillator that is solved for</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span> <span class="o">=</span> <span class="n">solve_dof</span>
        
        <span class="c1"># Set the other oscillator&#39;s amplitudes to zero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substitution_solve_dof</span><span class="p">(</span><span class="n">solve_dof</span><span class="p">)</span>
        
        <span class="c1"># Phase response</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve_phase</span><span class="p">()</span>
        
        <span class="c1"># Frequency (detuning) response</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve_sigma</span><span class="p">()</span>
        
        <span class="c1"># Frequency response (in terms of oscillator&#39;s amplitude)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve_a</span><span class="p">()</span>
        
        <span class="c1"># Amplitude (forcing) respose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve_F</span><span class="p">()</span></div>

        
<div class="viewcode-block" id="Steady_state.substitution_solve_dof">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.substitution_solve_dof">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">substitution_solve_dof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solve_dof</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set every oscillator amplitude to 0 except the one to solve for.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If one wants to solve for :math:`a_i`, then the system is evaluated for :math:`a_j=0, \; \forall j \neq i`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sub_solve</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ix</span> <span class="o">!=</span> <span class="n">solve_dof</span><span class="p">:</span>
                <span class="n">sub_solve</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_solve</span> <span class="o">=</span> <span class="n">sub_solve</span>    </div>

        
<div class="viewcode-block" id="Steady_state.solve_phase">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.solve_phase">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find solutions for the oscillator&#39;s phase :math:`\beta_i`. </span>
<span class="sd">        The solutions actually returned are :math:`\sin(k \beta_i)` and :math:`\cos(k \beta_i)`, where :math:`k` is an integer or rational.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Evaluate the evolution equations for a single oscillator responding</span>
        <span class="n">fa_dof</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fa</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">]</span>   <span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_solve</span><span class="p">)</span>
        <span class="n">fbeta_dof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fbeta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_solve</span><span class="p">)</span>
        
        <span class="c1"># Collect sin and cos terms in the evolution equations</span>
        <span class="n">collect_sin_cos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fa_dof</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">fbeta_dof</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">))</span>
        <span class="n">collect_sin_cos</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">collect_sin_cos</span> <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">])]</span>
    
        <span class="k">def</span><span class="w"> </span><span class="nf">sort_key</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Sorting function. Assign a lower value to sine terms and a higher value to cosine terms</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span> <span class="o">==</span> <span class="n">sin</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span> <span class="o">==</span> <span class="n">cos</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">2</span>  

        <span class="n">collect_sin_cos</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">collect_sin_cos</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sort_key</span><span class="p">)</span> <span class="c1"># sin terms first, cos terms then</span>

        <span class="n">dic_fa</span>    <span class="o">=</span> <span class="n">fa_dof</span>   <span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">collect_sin_cos</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dic_fbeta</span> <span class="o">=</span> <span class="n">fbeta_dof</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">collect_sin_cos</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
        <span class="c1"># Check the possibility to solve using standard procedure (quadratic sum) -&gt; enforce the presence of 3 keys : {1, sin(phase), cos(phase)}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dic_fa</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">dic_fbeta</span><span class="o">.</span><span class="n">keys</span><span class="p">()))))</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="c1"># cos and sin terms both appear in the same expression </span>
             <span class="p">(</span><span class="n">collect_sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span> <span class="o">!=</span> <span class="n">collect_sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="p">):</span> <span class="c1"># Too many phases involved</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    No implemented analytical solution&#39;</span><span class="p">)</span>
            <span class="k">return</span>
    
        <span class="c1"># Compute the expression of sin/cos as a function of the amplitude</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   Computing the phase response&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">collect_sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">dic_fa</span><span class="p">:</span> <span class="c1"># sin in fa</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">dic_fa</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">sin_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">dic_fa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="n">dic_fa</span><span class="p">[</span><span class="n">collect_sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sin_phase</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">dic_fbeta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">cos_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">dic_fbeta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="n">dic_fbeta</span><span class="p">[</span><span class="n">collect_sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cos_phase</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                
        <span class="k">elif</span> <span class="n">collect_sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">dic_fa</span><span class="p">:</span> <span class="c1"># cos in fa</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">dic_fa</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">cos_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">dic_fa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="n">dic_fa</span><span class="p">[</span><span class="n">collect_sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cos_phase</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">dic_fbeta</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">sin_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">dic_fbeta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="n">dic_fbeta</span><span class="p">[</span><span class="n">collect_sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sin_phase</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   oscillator </span><span class="si">{}</span><span class="s2"> is not forced&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">))</span>
            <span class="k">return</span>
    
        <span class="c1"># Store the solutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sin_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">collect_sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sin_phase</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">cos_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">collect_sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cos_phase</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_phase</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sin_phase</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">cos_phase</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="Steady_state.solve_sigma">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.solve_sigma">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the forced response in terms of the detuning :math:`\sigma`. </span>
<span class="sd">        Returns :math:`\sigma(a_i)`.</span>
<span class="sd">        It is recalled that :math:`\omega = \omega_{\textrm{MMS}} + \epsilon \sigma`. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">sin_phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sin_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cos_phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">cos_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">Eq_sig</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin_phase</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">cos_phase</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
    
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   Computing the frequency response&#39;</span><span class="p">)</span>
        <span class="n">sol_sigma</span> <span class="o">=</span> <span class="n">sfun</span><span class="o">.</span><span class="n">solve_poly2</span><span class="p">(</span><span class="n">Eq_sig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
        <span class="n">sol_sigma</span> <span class="o">=</span> <span class="p">[</span><span class="n">sol_sigma_i</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span> <span class="k">for</span> <span class="n">sol_sigma_i</span> <span class="ow">in</span> <span class="n">sol_sigma</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sol_sigma</span></div>

    
<div class="viewcode-block" id="Steady_state.solve_a">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.solve_a">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_a</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the forced response in terms of the oscillator&#39;s amplitude.</span>
<span class="sd">        For readability, the output actually returned is :math:`a_i^2(\sigma, F)`. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">sin_phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sin_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cos_phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">cos_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">a</span>         <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">]</span>
        
        <span class="c1"># Equation on a</span>
        <span class="n">Eq_a</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin_phase</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="n">cos_phase</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">Eq_a</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">min_power</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">sfun</span><span class="o">.</span><span class="n">get_exponent</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
        <span class="n">Eq_a</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq_a</span><span class="o">/</span><span class="n">min_power</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        
        <span class="c1"># Solve</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">Eq_a</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">4</span><span class="p">]),</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">4</span><span class="p">])]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Computing the response with respect to the oscillator&#39;s amplitude&quot;</span><span class="p">)</span>
            <span class="n">sol_a2</span> <span class="o">=</span> <span class="n">sfun</span><span class="o">.</span><span class="n">solve_poly2</span><span class="p">(</span><span class="n">Eq_a</span><span class="p">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">sol_a2</span> <span class="o">=</span> <span class="p">[</span><span class="n">sol_a2_i</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span> <span class="k">for</span> <span class="n">sol_a2_i</span> <span class="ow">in</span> <span class="n">sol_a2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Not computing the response with respect to the oscillator&#39;s amplitude as the equation to solve is not of 2nd degree&quot;</span><span class="p">)</span>
            <span class="n">sol_a2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sol_a2</span> <span class="o">=</span> <span class="n">sol_a2</span></div>

    
<div class="viewcode-block" id="Steady_state.solve_F">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.solve_F">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_F</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the forced response in terms of the forcing amplitude :math:`F`. Returns :math:`F(a_i)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">sin_phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sin_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cos_phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">cos_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">F</span>         <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span>
        
        <span class="c1"># Equation on F</span>
        <span class="n">Eq_F</span>   <span class="o">=</span> <span class="p">(((</span><span class="n">sin_phase</span><span class="o">*</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> 
               <span class="o">+</span> <span class="p">(</span> <span class="p">(</span><span class="n">cos_phase</span><span class="o">*</span><span class="n">F</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> 
               <span class="o">-</span>    <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_B</span><span class="p">)</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">Eq_F</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">min_power</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">sfun</span><span class="o">.</span><span class="n">get_exponent</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">F</span><span class="p">))</span>
        <span class="n">Eq_F</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq_F</span><span class="o">/</span><span class="n">min_power</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        
        <span class="c1"># Solve</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">Eq_F</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">F</span><span class="o">**</span><span class="mi">2</span><span class="p">])]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   Computing the response with respect to the forcing amplitude&#39;</span><span class="p">)</span>
            <span class="n">sol_F</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">sfun</span><span class="o">.</span><span class="n">solve_poly2</span><span class="p">(</span><span class="n">Eq_F</span><span class="p">,</span> <span class="n">F</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;   Not computing the response with respect to the forcing amplitude as the equation to solve is not of 2nd degree&#39;</span><span class="p">)</span>
            <span class="n">sol_F</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">sol_F</span>    </div>

    
<div class="viewcode-block" id="Steady_state.solve_bbc">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.solve_bbc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_bbc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">[],</span> <span class="n">solve_dof</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the backbone curve (bbc) of a given oscillator with the other oscillators&#39; amplitude set to 0.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c: list, optional</span>
<span class="sd">            Damping terms. They will be set to 0 to compute the backbone curve.</span>
<span class="sd">            Note that these are the scaled damping terms.</span>
<span class="sd">            Default is `[]`.</span>
<span class="sd">        solve_dof: None or int, oprtional</span>
<span class="sd">            The oscillator number to solve for. </span>
<span class="sd">            If `None`, no oscillator is solved for.</span>
<span class="sd">            Default is `None`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The backbone curve describes the frequency of free oscillations as a function of the oscillator&#39;s amplitude.</span>
<span class="sd">        In the presence of small damping (as in the case in the MMS) the frequency of free oscillations is close from the resonance frequency. </span>
<span class="sd">        The backbone curve can therefore be interpreted as the *backbone* of the forced response. </span>

<span class="sd">        The backbone curve of oscillator :math:`i` typically takes the form</span>

<span class="sd">        .. math::</span>
<span class="sd">            \omega_{\textrm{bbc}}^{(i)} = k\omega_{i} + f_{\textrm{bbc}}^{(i)} (a_i),</span>

<span class="sd">        where :math:`k=1,\; k&lt;1,\; k&gt;1` are associated to direct, superharmonic and subharmonic responses, respectively. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">solve_dof</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="c1"># Information</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing the backbone curve for oscillator </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">solve_dof</span><span class="p">))</span>
        
        <span class="c1"># Set every oscillator amplitude to 0 except the one to solve for</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">substitution_solve_dof</span><span class="p">(</span><span class="n">solve_dof</span><span class="p">)</span>
        
        <span class="c1"># Substitutions for the free response</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> 
            <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="n">sub_free</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="p">[(</span><span class="n">ci</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]]</span>
        
        <span class="c1"># Establish the backbone curve equation</span>
        <span class="n">Eq_bbc</span>        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fbeta</span><span class="p">[</span><span class="n">solve_dof</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_solve</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_B</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_free</span><span class="p">)</span>
        
        <span class="c1"># Compute the backbone curve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sigma_bbc</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">Eq_bbc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">omega_bbc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omegaMMS</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sigma_bbc</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_free</span> <span class="o">=</span> <span class="n">sub_free</span></div>



<div class="viewcode-block" id="Steady_state.Jacobian_polar">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.Jacobian_polar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Jacobian_polar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Jacobian of the evolution equations systems expressed in polar coordinates (see :func:`stability_analysis`).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        J : sympy.Matrix</span>
<span class="sd">            Jacobian of the polar system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">J</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">fai</span><span class="p">,</span> <span class="n">fbetai</span><span class="p">,</span> <span class="n">ai</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fbeta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="p">(</span><span class="n">aj</span><span class="p">,</span> <span class="n">betaj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">beta</span><span class="p">)):</span>
                <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="p">]</span>     <span class="o">=</span> <span class="n">fai</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span>
                <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="n">fai</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">betaj</span><span class="p">)</span>
                <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="p">]</span>   <span class="o">=</span> <span class="p">(</span><span class="n">fbetai</span><span class="o">/</span><span class="n">ai</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span>
                <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fbetai</span><span class="o">/</span><span class="n">ai</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">betaj</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">J</span></div>

        
        
<div class="viewcode-block" id="Steady_state.cartesian_coordinates">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.cartesian_coordinates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cartesian_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define cartesian coordinates from the polar ones.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The homogeneous leading order solution for oscillator :math:`i` expressed in polar coordinates takes the form</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{split}</span>
<span class="sd">            x_{i,0}^{\textrm{h}}(t) &amp; = a_i \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t - \beta_i \right), \\</span>
<span class="sd">                                    &amp; = a_i \cos(\beta_i) \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right) </span>
<span class="sd">                                      + a_i \sin(\beta_i) \sin\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right)</span>
<span class="sd">            \end{split}</span>

<span class="sd">        The polar coordinates are defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            p_i = a_i \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\beta_i\right), \\</span>
<span class="sd">            q_i = a_i \sin\left(\frac{r_i}{r_{\textrm{MMS}}}\beta_i\right),</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        such that the leading order solution can be written as</span>

<span class="sd">        .. math::</span>
<span class="sd">            x_{i,0}^{\textrm{h}}(t) = p_i \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right) + q_i \sin\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right).</span>
<span class="sd">        </span>
<span class="sd">        XXX : vrifier comment je dfinis beta ici, et les coord cartsiennes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        
        <span class="c1"># Define the cartesian coordinates</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbols</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;p_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbols</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;q_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)]</span>
        
        <span class="c1"># Define relations between the polar and cartesian coordinates</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">]))</span>
        <span class="n">sub_cart</span>  <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sub_polar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="n">ratio_omega</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio_omega_osc</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omegaMMS</span><span class="p">)</span>
            
            <span class="n">sub_cart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">ratio_omega</span><span class="p">)</span>     <span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="p">)</span>
            <span class="n">sub_cart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">ratio_omega</span><span class="p">)</span>     <span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="p">)</span>
            <span class="n">sub_cart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">ratio_omega</span><span class="p">),</span> <span class="n">p</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">sub_cart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">ratio_omega</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">q</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span> <span class="p">)</span>
            <span class="n">sub_cart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>                            <span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span>
            
            <span class="n">sub_polar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">ratio_omega</span><span class="p">))</span> <span class="p">)</span>
            <span class="n">sub_polar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">ratio_omega</span><span class="p">))</span> <span class="p">)</span>
    
        <span class="c1"># Store the results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_cart</span>  <span class="o">=</span> <span class="n">sub_cart</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_polar</span> <span class="o">=</span> <span class="n">sub_polar</span></div>

        
    
<div class="viewcode-block" id="Steady_state.evolution_equations_cartesian">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.evolution_equations_cartesian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evolution_equations_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the evolution equations of the cartesian coordinates system.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Write the evolution equations using the cartesian coordinates (defined in :func:`cartesian_coordinates`). </span>
<span class="sd">        For oscillator :math:`i`, this results in</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            \dfrac{\textrm{d} p_i}{\textrm{d} t} &amp; = f_{p_i}(\boldsymbol{p}, \boldsymbol{q}), \\</span>
<span class="sd">            \dfrac{\textrm{d} q_i}{\textrm{d} t} &amp; = f_{q_i}(\boldsymbol{p}, \boldsymbol{q}),</span>
<span class="sd">            \end{cases}</span>
<span class="sd">        </span>
<span class="sd">        where :math:`\boldsymbol{p}(t)` and :math:`\boldsymbol{q}(t)` are vectors containing the cartesian coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Compute the functions fp(p,q) and fq(p,q)</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fq</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">a</span><span class="p">,</span> <span class="n">beta</span>   <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">]))</span>
        <span class="n">fa</span><span class="p">,</span> <span class="n">fbeta</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;fa&quot;</span><span class="p">,</span> <span class="s2">&quot;fbeta&quot;</span><span class="p">]))</span>
        
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="n">ratio_omega</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio_omega_osc</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratio_omegaMMS</span><span class="p">)</span>
            
            <span class="n">fp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">TR10</span><span class="p">(</span> <span class="p">(</span> <span class="n">fa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">ratio_omega</span><span class="p">)</span> <span class="o">-</span> 
                               <span class="n">ratio_omega</span><span class="o">*</span><span class="n">fbeta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">ratio_omega</span><span class="p">)</span>
                              <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_cart</span><span class="p">)</span> <span class="p">)</span>
            
            <span class="n">fq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">TR10</span><span class="p">(</span> <span class="p">(</span> <span class="n">fa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">ratio_omega</span><span class="p">)</span> <span class="o">+</span> 
                               <span class="n">ratio_omega</span><span class="o">*</span><span class="n">fbeta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">*</span><span class="n">ratio_omega</span><span class="p">)</span>
                              <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_cart</span><span class="p">)</span> <span class="p">)</span>
        
        <span class="c1"># Check if the a and beta have all been substituted</span>
        <span class="n">substitution_OK</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_cartesian_substitutions</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fq</span><span class="p">)</span>
        
        <span class="c1"># Try additional substitutions if the change of coordinates is incomplete</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">substitution_OK</span><span class="p">:</span>
            <span class="n">fp</span><span class="p">,</span> <span class="n">fq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">additional_cartesian_substitutions</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fq</span><span class="p">)</span>
            
            <span class="c1"># Check if the a and beta have all been substituted</span>
            <span class="n">substitution_OK</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_cartesian_substitutions</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fq</span><span class="p">)</span>
            
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">substitution_OK</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   The substitution from polar to cartesian coordinates is incomplete&quot;</span><span class="p">)</span>
        
        <span class="c1"># Store the evolution equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fq</span> <span class="o">=</span> <span class="n">fq</span></div>

        
<div class="viewcode-block" id="Steady_state.check_cartesian_substitutions">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.check_cartesian_substitutions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_cartesian_substitutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fq</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if substitutions from polar to cartesian coordinates are complete.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a: list of sympy.Symbol</span>
<span class="sd">            Amplitudes of the leading order solutions.</span>
<span class="sd">        beta: list of sympy.Symbol</span>
<span class="sd">            Phases of the leading order solutions.</span>
<span class="sd">        fp: list of sympy.Expr</span>
<span class="sd">            Evolution functions for the cartesian coordinates :math:`p_i`.</span>
<span class="sd">        fq: list of sympy.Expr</span>
<span class="sd">            Evolution functions for the cartesian coordinates :math:`q_i`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        substitution_OK : bool</span>
<span class="sd">            `True` if substitutions are complete.</span>
<span class="sd">            `False` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polar_coordinates</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">beta</span>
        <span class="n">substitution_OK</span>   <span class="o">=</span> <span class="kc">True</span>
        <span class="n">count</span>             <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">substitution_OK</span> <span class="ow">and</span> <span class="n">count</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
                <span class="n">symbols_fpq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fp</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">fq</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">polar_coordinate</span> <span class="ow">in</span> <span class="n">polar_coordinates</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">polar_coordinate</span> <span class="ow">in</span> <span class="n">symbols_fpq</span><span class="p">:</span>
                        <span class="n">substitution_OK</span> <span class="o">=</span> <span class="kc">False</span>
                        
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">substitution_OK</span></div>

        
<div class="viewcode-block" id="Steady_state.additional_cartesian_substitutions">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.additional_cartesian_substitutions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">additional_cartesian_substitutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fq</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reformulate the already-existing substitutions from polar to cartesian to try and substitute leftover polar terms.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fp: list of sympy.Expr</span>
<span class="sd">            Evolution functions for the cartesian coordinates :math:`p_i`.</span>
<span class="sd">            There are polar coordinates remaining.</span>
<span class="sd">        fq: list of sympy.Expr</span>
<span class="sd">            Evolution functions for the cartesian coordinates :math:`q_i`.</span>
<span class="sd">            There are polar coordinates remaining.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fp: list of sympy.Expr</span>
<span class="sd">            Evolution functions for the cartesian coordinates :math:`p_i`.</span>
<span class="sd">            Additional substitutions were performed to get rid of polar coordinates.</span>
<span class="sd">        fq: list of sympy.Expr</span>
<span class="sd">            Evolution functions for the cartesian coordinates :math:`q_i`.</span>
<span class="sd">            Additional substitutions were performed to get rid of polar coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">sub_cart_add</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Additional substitutions required</span>
        
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fp</span><span class="o">+</span><span class="n">fq</span><span class="p">:</span>
            <span class="c1"># Terms that were not properly substituted</span>
            <span class="n">left_polar_terms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">))</span>
            
            <span class="c1"># Check if unsubstituted terms were identified</span>
            <span class="k">if</span> <span class="n">left_polar_terms</span><span class="p">:</span> 
                
                <span class="c1"># Loop over the unsubstituted terms</span>
                <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">left_polar_terms</span><span class="p">:</span>
                    
                    <span class="c1"># Loop over already-defined substitutions and look for the current unsubstituted term</span>
                    <span class="k">for</span> <span class="n">sub_cart_item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_cart</span><span class="p">:</span>
                        <span class="n">dic</span> <span class="o">=</span> <span class="n">sub_cart_item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        
                        <span class="c1"># Identify possible additional substitutions</span>
                        <span class="k">if</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">dic</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">sub_cart_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">solve</span><span class="p">(</span><span class="n">sub_cart_item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">sub_cart_item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">term</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_cart</span><span class="p">))</span> <span class="p">)</span>
        
        <span class="c1"># Apply these new substitutions                                </span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="n">fp</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">fp</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_cart_add</span><span class="p">)</span>
            <span class="n">fq</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">fq</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_cart_add</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fq</span></div>

    
    
<div class="viewcode-block" id="Steady_state.Jacobian_cartesian">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.Jacobian_cartesian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Jacobian_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Jacobian of the evolution equations systems expressed in cartesian coordinates (see :func:`stability_analysis`).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        J : sympy.Matrix</span>
<span class="sd">            Jacobian of the cartesian system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">J</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">fpi</span><span class="p">,</span> <span class="n">fqi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fq</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span> <span class="p">(</span><span class="n">pj</span><span class="p">,</span> <span class="n">qj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">q</span><span class="p">)):</span>
                <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="p">]</span>     <span class="o">=</span> <span class="n">fpi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">pj</span><span class="p">)</span>
                <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>   <span class="o">=</span> <span class="n">fpi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">qj</span><span class="p">)</span>
                <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="p">]</span>   <span class="o">=</span> <span class="n">fqi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">pj</span><span class="p">)</span>
                <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fqi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">qj</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">J</span></div>


<div class="viewcode-block" id="Steady_state.stability_analysis">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.stability_analysis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">stability_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="o">=</span><span class="s2">&quot;cartesian&quot;</span><span class="p">,</span> <span class="n">rewrite_polar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eigenvalues</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bifurcation_curves</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">analyse_blocks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">kwargs_bif</span><span class="o">=</span><span class="nb">dict</span><span class="p">()):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the stability of a steady state solution. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord: str, optional</span>
<span class="sd">            Either ``&quot;cartesian&quot;`` or ``&quot;polar&quot;``. </span>
<span class="sd">            Specifies the coordinates to use for the stability analysis.</span>
<span class="sd">            ``&quot;cartesian&quot;`` is recommended as it prevents divisions by 0, which occur when at least one of the oscillator has a 0 ampliutude.</span>
<span class="sd">            Default is ``&quot;cartesian&quot;``.</span>
<span class="sd">        rewrite_polar: bool, optional</span>
<span class="sd">            Rewrite the Jacobian&#39;s determinant and trace in polar coordinates (if computed using cartesian ones).</span>
<span class="sd">            This is time consuming and the current back substitutions from cartesian to polar coordinates are not always sufficient.</span>
<span class="sd">            Default is `False`.</span>
<span class="sd">        eigenvalues: bool, optional</span>
<span class="sd">            Compute the eigenvalues of the Jacobian.</span>
<span class="sd">            Default is `False`.</span>
<span class="sd">        bifurcation_curves: bool, optional</span>
<span class="sd">            Compute the bifurcation curves.</span>
<span class="sd">            Default is `False`.</span>
<span class="sd">        analyse_blocks: bool, optional</span>
<span class="sd">            Analyse the diagonal blocks of the Jacobian rather than the Jacobian itself. This is relevant if the Jacobian is block-diagonal.</span>
<span class="sd">        kwargs_bif: dict, optional</span>
<span class="sd">            Passed to :func:`bifurcation_curves`</span>
<span class="sd">            Default is `dict()`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        ^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">        Stability information</span>
<span class="sd">        ^^^^^^^^^^^^^^^^^^^^^</span>

<span class="sd">        Consider a steady state solution :math:`(\hat{\boldsymbol{a}} , \hat{\boldsymbol{\beta}})` such that, for :math:`i=1,...,N`,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            f_{a_i}(\hat{\boldsymbol{a}}, \hat{\boldsymbol{\beta}})     &amp; = 0, \\</span>
<span class="sd">            f_{\beta_i}(\hat{\boldsymbol{a}}, \hat{\boldsymbol{\beta}}) &amp; = 0.</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        The aim is to determine the stability state of that steady solution, which corresponds to a fixed point in the phase space. </span>

<span class="sd">        ---------------</span>
<span class="sd">        Jacobian matrix</span>
<span class="sd">        ---------------</span>
<span class="sd">        Let&#39;s first introduce the vector of polar coordinates and polar evolution functions</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol{x}^{(\textrm{p})\intercal} &amp; = [a_0, \beta_0, \cdots, a_{N-1}, \beta_{N-1}], \\</span>
<span class="sd">            \boldsymbol{f}^{(\textrm{p})\intercal} &amp; = [f_{a_0}, f_{\beta_0}^*, \cdots, f_{a_{N-1}}, f_{\beta_{N-1}}^*].</span>

<span class="sd">        Note that the appearance of :math:`f_{\beta_i}^*` in :math:`\boldsymbol{f}^{(\textrm{p})}` requires :math:`a_i \neq 0`, which strongly constraints the type of steady state solutions that can be considered in the approach described below. </span>
<span class="sd">        To relax this constraint, one can use a change of coordinates from polar to cartesian ones. </span>
<span class="sd">        This will be discussed in following sections, after the description of this polar approach. </span>
<span class="sd">        </span>
<span class="sd">        Using the vectors of polar coordinates and evolution functions, one can write the evolution equations system as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \dfrac{\textrm{d} \boldsymbol{x}^{(\textrm{p})}}{\textrm{d}t} = \textrm{J}^{(\textrm{p})} \boldsymbol{x}^{(\textrm{p})},</span>

<span class="sd">        where we introduced the Jacobian matrix </span>

<span class="sd">        .. math::</span>
<span class="sd">            \textrm{J}^{(\textrm{p})} </span>
<span class="sd">            = \dfrac{\partial \boldsymbol{f}^{(\textrm{p})} }{ \partial \boldsymbol{x}^{(\textrm{p})} }</span>
<span class="sd">            = \begin{bmatrix}</span>
<span class="sd">            \frac{\partial f_{a_0}}{\partial a_0} &amp; \frac{\partial f_{a_0}}{\partial \beta_0} &amp; \cdots &amp; \frac{\partial f_{a_0}}{\partial \beta_{N-1}} \\</span>
<span class="sd">            \frac{\partial f_{\beta_0}^*}{\partial a_0} &amp; \frac{\partial f_{\beta_0}^*}{\partial \beta_0} &amp; \cdots &amp; \frac{\partial f_{\beta_0}^*}{\partial \beta_{N-1}} \\</span>
<span class="sd">            \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\</span>
<span class="sd">            \frac{\partial f_{\beta_{N-1}}^*}{\partial a_0} &amp; \frac{\partial f_{\beta_{N-1}}^*}{\partial \beta_0} &amp; \cdots &amp; \frac{\partial f_{\beta_{N-1}}^*}{\partial \beta_{N-1}}</span>
<span class="sd">            \end{bmatrix}.</span>

<span class="sd">        -----------------------------------------</span>
<span class="sd">        Perturbation of the steady state solution</span>
<span class="sd">        -----------------------------------------</span>
<span class="sd">        Let us now consider a small perturbation :math:`\tilde{\boldsymbol{x}}^{(\textrm{p})}` of the steady state solution such that</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol{x}^{(\textrm{p})} = \hat{\boldsymbol{x}}^{(\textrm{p})} + \tilde{\boldsymbol{x}}^{(\textrm{p})} \quad \Leftrightarrow \quad \tilde{\boldsymbol{x}}^{(\textrm{p})} = \boldsymbol{x}^{(\textrm{p})} - \hat{\boldsymbol{x}}^{(\textrm{p})}.</span>

<span class="sd">        Using a first order Taylor expansion for :math:`\textrm{d} \tilde{\boldsymbol{x}}^{(\textrm{p})} / \textrm{d} t`, one can write</span>

<span class="sd">        .. math::</span>
<span class="sd">            \dfrac{\textrm{d} \tilde{\boldsymbol{x}}^{(\textrm{p})}}{\textrm{d}t} = \left.\textrm{J}^{(\textrm{p})}\right|_{\hat{\boldsymbol{x}}^{(\textrm{p})}} \tilde{\boldsymbol{x}}^{(\textrm{p})} + \mathcal{O}(||\tilde{\boldsymbol{x}}^{(\textrm{p})}||^2),</span>

<span class="sd">        where :math:`\left.\textrm{J}^{(\textrm{p})}\right|_{\hat{\boldsymbol{x}}^{(\textrm{p})}}` denotes the Jacobian matrix evaluated on the steady state solution. </span>
<span class="sd">        The perturbation solution takes the form</span>

<span class="sd">        .. math::</span>
<span class="sd">            \tilde{\boldsymbol{x}}^{(\textrm{p})} = \sum_{i=1}^{2N} C_i \boldsymbol{\psi}_i e^{\lambda_i t},</span>

<span class="sd">        where :math:`(\lambda_i, \boldsymbol{\psi}_i),\; i=1, ..., 2N` are the eigensolutions of the Jacobian (evaluated on :math:`\hat{\boldsymbol{x}}^{(\textrm{p})}`).</span>
<span class="sd">        </span>
<span class="sd">        -------------------</span>
<span class="sd">        Stability condition</span>
<span class="sd">        -------------------</span>
<span class="sd">        The steady state solution :math:`\hat{\boldsymbol{x}}^{(\textrm{p})}` is considered stable if a small perturbation :math:`\tilde{\boldsymbol{x}}^{(\textrm{p})}` vanishes in time, </span>
<span class="sd">        such that solutions close from :math:`\hat{\boldsymbol{x}}^{(\textrm{p})}` are converging towards it. This condition is fulfilled if</span>

<span class="sd">        .. math::</span>
<span class="sd">            \Re[\lambda_i] &lt; 0, \quad \forall i,</span>

<span class="sd">        meaning that all eigenvalues of the Jacobian evaluated on the steady state solution must have negative real parts.</span>
<span class="sd">        If this condition is not met, the system is either quasi stable or unstable.</span>

<span class="sd">        ------------</span>
<span class="sd">        Bifurcations</span>
<span class="sd">        ------------</span>
<span class="sd">        A bifurcation occurs when the stability state of the system changes. </span>
<span class="sd">        </span>
<span class="sd">        #. Simple bifurcations occur when at least one eigenvalue crosses the imaginary axis through 0.</span>
<span class="sd">           Such bifurcations include saddle node and pitchfork bifurcations, which cause jumps of the response and the appearance of lower symmetry solutions, respectively.</span>

<span class="sd">        #. Neimark-Sacker bifurcations occur when a pair of complex conjugate eigenvalues with nonzero real parts cross the imaginary axis.</span>
<span class="sd">           These bifurcations lead to non periodic solutions. </span>

<span class="sd">        Simple bifurcations can be detected by evaluating the sign of the Jacobian, as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \det \left.\textrm{J}^{(\textrm{p})}\right|_{\hat{\boldsymbol{x}}^{(\textrm{p})}} = \prod_{i=1}^{2N} \lambda_i,</span>

<span class="sd">        thereby making :math:`\det \left.\textrm{J}^{(\textrm{p})}\right|_{\hat{\boldsymbol{x}}^{(\textrm{p})}}` an important stability indicator.</span>
<span class="sd">        Neimark-Sacker bifurcations are more difficult to detect. Information from the trace of :math:`\left.\textrm{J}^{(\textrm{p})}\right|_{\hat{\boldsymbol{x}}^{(\textrm{p})}}` can be considered, or the Routh-Hurwitz criterion can be used. This is not detailed here.</span>

<span class="sd">        ------------------</span>
<span class="sd">        Bifurcation curves</span>
<span class="sd">        ------------------</span>
<span class="sd">        Bifurcation curves are curves constructed by evaluating the coordinates of bifurcation points when varying one or more parameters.</span>
<span class="sd">        The stability state of a solution changes when the response curve crosses a bifurcation curve.</span>

<span class="sd">        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="sd">        Stability analysis in cartesian coordinates</span>
<span class="sd">        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

<span class="sd">        --------------------------------</span>
<span class="sd">        Limitations of polar coordinates</span>
<span class="sd">        --------------------------------</span>
<span class="sd">        As mentioned previously, the approach described above fails when one of the oscillator&#39;s leading order amplitude is 0.</span>
<span class="sd">        Indeed, the Jacobian is constructed using the evolution functions</span>

<span class="sd">        .. math::</span>
<span class="sd">                f_{\beta_i}^*(\boldsymbol{a}, \boldsymbol{\beta}) = \frac{f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta})}{a_i},</span>

<span class="sd">        which are defined only if :math:`a_i=0`. </span>
<span class="sd">        This prevents evaluating the stability of</span>

<span class="sd">        - Trivial solutions, for which no oscillator responds,</span>

<span class="sd">        - 1 mode solutions, whose stability can be affected under perturbation from another mode.</span>

<span class="sd">        These limitations can be overcome using a change of coordinates.</span>

<span class="sd">        ---------------------</span>
<span class="sd">        Cartesian coordinates</span>
<span class="sd">        ---------------------</span>
<span class="sd">        The leading order homogeneous solution for oscillator :math:`i` can be written as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{split}</span>
<span class="sd">            x_{i,0}^{\textrm{h}}(t) &amp; = a_i \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t - \beta_i \right), \\</span>
<span class="sd">                                    &amp; = a_i \cos(\beta_i) \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right) </span>
<span class="sd">                                      + a_i \sin(\beta_i) \sin\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right).</span>
<span class="sd">            \end{split}</span>

<span class="sd">        It then appears natural to introduce the cartesian coordinates</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            p_i = a_i \cos(\beta_i), \\</span>
<span class="sd">            q_i = a_i \sin(\beta_i),</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        in order to rewrite the solution as</span>

<span class="sd">        .. math::</span>
<span class="sd">            x_{i,0}^{\textrm{h}}(t) = p_i \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right) + q_i \sin\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right).</span>

<span class="sd">        In the following it will be convenient to use the cartesian coordinates vectors</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{aligned}</span>
<span class="sd">            \boldsymbol{p}(t)^\intercal &amp; = [p_0(t), p_1(t), \cdots, p_{N-1}(t)], \\</span>
<span class="sd">            \boldsymbol{q}(t)^\intercal &amp; = [q_0(t), q_1(t), \cdots, q_{N-1}(t)].</span>
<span class="sd">            \end{aligned}</span>

<span class="sd">        -----------------------------</span>
<span class="sd">        Cartesian evolution equations</span>
<span class="sd">        -----------------------------</span>
<span class="sd">        The cartesian evolution equations can be obtained from the polar ones. To do so, one can write</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            \dfrac{\textrm{d} p_i}{\textrm{d}t} &amp; = \dfrac{\textrm{d} a_i}{\textrm{d}t} \cos(\beta_i) - a_i \sin(\beta_i) \dfrac{\textrm{d} \beta_i}{\textrm{d}t}, \\</span>
<span class="sd">            \dfrac{\textrm{d} q_i}{\textrm{d}t} &amp; = \dfrac{\textrm{d} a_i}{\textrm{d}t} \sin(\beta_i) + a_i \cos(\beta_i) \dfrac{\textrm{d} \beta_i}{\textrm{d}t}.</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        Then, by identification, one necessarily has</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            f_{p_i}(\boldsymbol{p}, \boldsymbol{q}) &amp; = f_{a_i}(\boldsymbol{a}, \boldsymbol{\beta}) \cos(\beta_i) - f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta}) \sin(\beta_i), \\</span>
<span class="sd">            f_{q_i}(\boldsymbol{p}, \boldsymbol{q}) &amp; = f_{a_i}(\boldsymbol{a}, \boldsymbol{\beta}) \sin(\beta_i) + f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta}) \cos(\beta_i),</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        in order to write the evolution equations in cartesian coordinates</span>

<span class="sd">        .. math::</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">            \dfrac{\textrm{d}}{dt} p_0(t) &amp; = f_{p_0}(\boldsymbol{p}, \boldsymbol{q}), \\</span>
<span class="sd">            \dfrac{\textrm{d}}{dt} q_0(t) &amp; = f_{q_0}(\boldsymbol{p}, \boldsymbol{q}), \\</span>
<span class="sd">            &amp; \vdots \\</span>
<span class="sd">            \dfrac{\textrm{d}}{dt} p_{N-1}(t) &amp; = f_{p_{N-1}}(\boldsymbol{p}, \boldsymbol{q}), \\</span>
<span class="sd">            \dfrac{\textrm{d}}{dt} q_{N-1}(t) &amp; = f_{q_{N-1}}(\boldsymbol{p}, \boldsymbol{q}).</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        ---------------</span>
<span class="sd">        Jacobian matrix</span>
<span class="sd">        ---------------</span>

<span class="sd">        As done previously for polar coordinates, let&#39;s introduce the vectors of cartesian coordinates and evolution equations as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol{x}^{(\textrm{c})\intercal} &amp; = [p_0, q_0, \cdots, p_{N-1}, q_{N-1}], \\</span>
<span class="sd">            \boldsymbol{f}^{(\textrm{c})\intercal} &amp; = [f_{p_0}, f_{q_0}, \cdots, f_{p_{N-1}}, f_{q_{N-1}}].</span>

<span class="sd">        Then one can write</span>

<span class="sd">        .. math::</span>
<span class="sd">            \dfrac{\textrm{d} \boldsymbol{x}^{(\textrm{c})}}{\textrm{d}t} = \textrm{J}^{(\textrm{c})} \boldsymbol{x}^{(\textrm{c})},</span>

<span class="sd">        where we introduced the Jacobian matrix </span>

<span class="sd">        .. math::</span>
<span class="sd">            \textrm{J}^{(\textrm{c})}</span>
<span class="sd">            = \dfrac{\partial \boldsymbol{f}^{(\textrm{c})} }{ \partial \boldsymbol{x}^{(\textrm{c})} }</span>
<span class="sd">            = \begin{bmatrix}</span>
<span class="sd">            \frac{\partial f_{p_0}}{\partial p_0} &amp; \frac{\partial f_{p_0}}{\partial q_0} &amp; \cdots &amp; \frac{\partial f_{p_0}}{\partial q_{N-1}} \\</span>
<span class="sd">            \frac{\partial f_{q_0}}{\partial p_0} &amp; \frac{\partial f_{q_0}}{\partial q_0} &amp; \cdots &amp; \frac{\partial f_{q_0}}{\partial q_{N-1}} \\</span>
<span class="sd">            \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\</span>
<span class="sd">            \frac{\partial f_{q_{N-1}}}{\partial p_0} &amp; \frac{\partial f_{q_{N-1}}}{\partial q_0} &amp; \cdots &amp; \frac{\partial f_{q_{N-1}}}{\partial q_{N-1}}</span>
<span class="sd">            \end{bmatrix}.</span>

<span class="sd">        Note that there are no constraints related to an oscillator&#39;s amplitude being 0 here. </span>
<span class="sd">        This cartesian coordinates approach therefore allows to investigate how the stability of a steady state solution is affected by a perturbation from an oscillator who&#39;s amplitude is 0 in that steady state solution.</span>

<span class="sd">        The stability analysis with :math:`\textrm{J}^{(\textrm{c})}` is carried out as described previously with :math:`\textrm{J}^{(\textrm{p})}`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if a solution has been computed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;sigma&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There is no solution to evaluate the stability of.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="c1"># Information</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Evaluating the stability of the solution of oscillator </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">))</span>
        
        <span class="c1"># Introduce the cartesian coordinates and evolution equations</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="o">==</span> <span class="s2">&quot;cartesian&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Rewritting the system in cartesian coordinates&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">analysis_coord</span> <span class="o">=</span> <span class="s2">&quot;cartesian&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cartesian_coordinates</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evolution_equations_cartesian</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">analysis_coord</span> <span class="o">=</span> <span class="s2">&quot;polar&quot;</span>
        
        <span class="c1"># Compute the Jacobian</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Computing the Jacobian&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">==</span><span class="s2">&quot;cartesian&quot;</span><span class="p">:</span>
            <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Jacobian_cartesian</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Jacobian_polar</span><span class="p">()</span>
        
        <span class="c1"># Set every oscillator amplitude to 0 except the one solved for</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">==</span><span class="s2">&quot;cartesian&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ix</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_solve</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">q</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="mi">0</span><span class="p">)]</span> <span class="p">)</span>
         
        <span class="c1"># Use the steady state solutions to perform substitutions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_solve</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sin_phase</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sin_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">cos_phase</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">cos_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">coord</span><span class="o">==</span><span class="s2">&quot;cartesian&quot;</span><span class="p">:</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">]</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_solve</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_solve</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_solve</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">fq</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_solve</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>
        
        <span class="c1"># Evaluate the Jacobian on the solution</span>
        <span class="n">Jsol</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_solve</span><span class="p">))</span> 
        
        <span class="c1"># Analyse the Jacobian</span>
        <span class="n">tr_Jsol</span>  <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">Jsol</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="n">det_Jsol</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">Jsol</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        
        <span class="c1"># Rewrite the results in polar form if cartesian coordinates were used (time consuming)</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">==</span><span class="s2">&quot;cartesian&quot;</span><span class="p">:</span> 
            <span class="c1"># Save cartesian results</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">Jsolc</span>     <span class="o">=</span> <span class="n">Jsol</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">tr_Jsolc</span>  <span class="o">=</span> <span class="n">tr_Jsol</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">det_Jsolc</span> <span class="o">=</span> <span class="n">det_Jsol</span>
            
            <span class="c1"># Write the results in polar form</span>
            <span class="k">if</span> <span class="n">rewrite_polar</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Expressing the stability results in polar coordinates&quot;</span><span class="p">)</span>
                <span class="n">Jsol</span>     <span class="o">=</span> <span class="n">cartesian_to_polar</span><span class="p">(</span><span class="n">Jsol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_polar</span><span class="p">,</span> <span class="n">sub_phase</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_phase</span><span class="p">)</span>
                <span class="n">tr_Jsol</span>  <span class="o">=</span> <span class="n">cartesian_to_polar</span><span class="p">(</span><span class="n">tr_Jsol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_polar</span><span class="p">,</span> <span class="n">sub_phase</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_phase</span><span class="p">)</span>
                <span class="n">det_Jsol</span> <span class="o">=</span> <span class="n">cartesian_to_polar</span><span class="p">(</span><span class="n">det_Jsol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_polar</span><span class="p">,</span> <span class="n">sub_phase</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_phase</span><span class="p">)</span>

        <span class="c1"># Store results</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">Jsol</span>     <span class="o">=</span> <span class="n">Jsol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">tr_Jsol</span>  <span class="o">=</span> <span class="n">tr_Jsol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">det_Jsol</span> <span class="o">=</span> <span class="n">det_Jsol</span>
        
        <span class="c1"># Compute eigenvalues and bifurcation curves from the analysis of Jsol</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">analyse_blocks</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eigenvalues</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">eigvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">Jsol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bifurcation_curves</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">bif_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">bif_sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bifurcation_curves</span><span class="p">(</span><span class="n">det_Jsol</span><span class="p">,</span> <span class="n">tr_Jsol</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_bif</span><span class="p">)</span>

        <span class="c1"># Analyse the blocks of Jsol</span>
        <span class="k">if</span> <span class="n">analyse_blocks</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Block analysis&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">coord</span> <span class="o">==</span> <span class="s2">&quot;cartesian&quot;</span><span class="p">:</span>
                <span class="n">Jsol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">Jsolc</span>

            <span class="k">if</span> <span class="n">sfun</span><span class="o">.</span><span class="n">is_block_diagonal</span><span class="p">(</span><span class="n">Jsol</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks</span>         <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks_det</span>     <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks_tr</span>      <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks_eigvals</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks_bif_a</span>   <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks_bif_sig</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Jsol</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="n">Jsol</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                    <span class="n">detA</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                    <span class="n">trA</span>  <span class="o">=</span> <span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> 
                    <span class="k">if</span> <span class="n">coord</span><span class="o">==</span><span class="s2">&quot;cartesian&quot;</span><span class="p">:</span>
                        <span class="n">detA</span> <span class="o">=</span> <span class="n">cartesian_to_polar</span><span class="p">(</span><span class="n">detA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_polar</span><span class="p">,</span> <span class="n">sub_phase</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_phase</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
                        <span class="n">trA</span>  <span class="o">=</span> <span class="n">cartesian_to_polar</span><span class="p">(</span><span class="n">trA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_polar</span><span class="p">,</span> <span class="n">sub_phase</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_phase</span><span class="p">)</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks_det</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">detA</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks_tr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trA</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">eigenvalues</span><span class="p">:</span>
                        <span class="n">eigvalsA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">coord</span><span class="o">==</span><span class="s2">&quot;cartesian&quot;</span><span class="p">:</span>
                            <span class="n">eigvalsA</span> <span class="o">=</span> <span class="p">[</span><span class="n">cartesian_to_polar</span><span class="p">(</span><span class="n">eigval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_polar</span><span class="p">,</span> <span class="n">sub_phase</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_phase</span><span class="p">)</span> <span class="k">for</span> <span class="n">eigval</span> <span class="ow">in</span> <span class="n">eigvalsA</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks_eigvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eigvalsA</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">bifurcation_curves</span><span class="p">:</span>
                        <span class="n">bif_aA</span><span class="p">,</span> <span class="n">bif_sigA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bifurcation_curves</span><span class="p">(</span><span class="n">detA</span><span class="p">,</span> <span class="n">trA</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_bif</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks_bif_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bif_aA</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">blocks_bif_sig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bif_sigA</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Trying to perform a block analysis while the Jacobian is not block-diagonal&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Steady_state.eigenvalues">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.eigenvalues">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eigenvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the eigenvalues of a matrix :math:`\textrm{J}`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        J: sympy.Matrix</span>
<span class="sd">            The matrix whose eigenvalues are to be computed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eigvals: list</span>
<span class="sd">            The eigenvalues of :math:`\textrm{J}`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Computing eigenvalues&quot;</span><span class="p">)</span>
        
        <span class="n">lamb</span>        <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\lambda&quot;</span><span class="p">)</span>
        <span class="n">eig_problem</span> <span class="o">=</span> <span class="n">J</span> <span class="o">-</span> <span class="n">lamb</span> <span class="o">*</span> <span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">detEP</span>       <span class="o">=</span> <span class="n">eig_problem</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
        <span class="n">eigvals</span>     <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">detEP</span><span class="p">,</span> <span class="n">lamb</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">eigvals</span></div>

            
<div class="viewcode-block" id="Steady_state.bifurcation_curves">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.bifurcation_curves">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">bifurcation_curves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detJ</span><span class="p">,</span> <span class="n">trJ</span><span class="p">,</span> <span class="n">var_a</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">var_sig</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">sfun</span><span class="o">.</span><span class="n">solve_poly2</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute bifurcation curves.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        detJ: sympy.Expr</span>
<span class="sd">            The determinant of the matrix.</span>
<span class="sd">        trJ: sympy.Expr</span>
<span class="sd">            The trace of the matrix.</span>
<span class="sd">        var_a: bool, optional</span>
<span class="sd">            Consider the :math:`i^{\textrm{th}}` oscillator&#39;s amplitude :math:`a_i` as the variable and find the bifurcation curve as an expression for :math:`a_i`.</span>
<span class="sd">            `detJ` is rarely a quadratic polynomial in :math:`a_i`, so this can rarely be computed easily.</span>
<span class="sd">            Default is `False`.</span>
<span class="sd">        var_sig: bool, optional</span>
<span class="sd">            Consider the detuning :math:`\sigma` as the variable and find the bifurcation curve as an expression for :math:`\sigma`.</span>
<span class="sd">            `detJ` is often a quadratic polynomial in :math:`\sigma`, so this can often be computed.</span>
<span class="sd">            Default is `True`.</span>
<span class="sd">        solver: function, optional</span>
<span class="sd">            The solver to use to compute the bifurcation curves.</span>
<span class="sd">            Available are solver called as `solve(expr, x)`, which solve `expr=0` for `x`.</span>
<span class="sd">            :func:`~sympy.solvers.solvers.solve` can be used but is sometimes slow.</span>
<span class="sd">            Default is :func:`~MMS.sympy_functions.solve_poly2`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bif_a : list</span>
<span class="sd">            The bifurcation curves for :math:`a_i^2`.</span>
<span class="sd">        bif_sig : list</span>
<span class="sd">            The bifurcation curves for :math:`\sigma`. </span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The bifurcation curves computed here are the curves defined by the bifurcation points obtained for any forcing frequency and amplitude. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Computing bifurcation curves&quot;</span><span class="p">)</span>

        <span class="c1"># Check if a stability analysis was performed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;Jsol&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There was no stability analysis performed.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Check if the stability analysis is expressed in polar coordinates</span>
        <span class="k">if</span> <span class="s2">&quot;p&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">cartesian_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">p</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">q</span>
            <span class="n">symbols_det</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">detJ</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">))</span> 
            <span class="k">for</span> <span class="n">cartesian_coordinate</span> <span class="ow">in</span> <span class="n">cartesian_coordinates</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cartesian_coordinate</span> <span class="ow">in</span> <span class="n">symbols_det</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Substitutions from cartesian back to polar coordinates were incomplete. </span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">,</span>
                          <span class="s2">&quot;Try other substitutions manually or compute the Jacobian&#39;s determinant using block partitions if possible&quot;</span><span class="p">)</span>

        <span class="c1"># Compute the bifurcation curves from the determinant of the Jacobian</span>
        <span class="k">if</span> <span class="n">var_a</span> <span class="ow">and</span> <span class="n">sfun</span><span class="o">.</span><span class="n">check_solvability</span><span class="p">(</span><span class="n">detJ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">bif_a</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">detJ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bif_a</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">var_sig</span> <span class="ow">and</span> <span class="n">sfun</span><span class="o">.</span><span class="n">check_solvability</span><span class="p">(</span><span class="n">detJ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">):</span>
            <span class="n">bif_sig</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">detJ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bif_sig</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Add bifurcation curves related to the trace of the Jacobian if it is not a constant</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">]</span> <span class="ow">in</span> <span class="n">trJ</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
            <span class="n">bif_a</span>   <span class="o">+=</span> <span class="n">solver</span><span class="p">(</span><span class="n">trJ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">solve_dof</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">trJ</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)):</span>
            <span class="n">bif_sig</span> <span class="o">+=</span> <span class="n">solver</span><span class="p">(</span><span class="n">trJ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>
        
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">bif_a</span><span class="p">,</span> <span class="n">bif_sig</span></div>

    
<div class="viewcode-block" id="Steady_state.plot_FRC">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.plot_FRC">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_FRC</span><span class="p">(</span><span class="n">FRC</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the frequency response curves (FRC), both frequency-amplitude and frequency-phase.</span>
<span class="sd">        Also includes the stability information if given.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        FRC : dict</span>
<span class="sd">            Dictionary containing the frequency response curves and the bifurcation curves.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig1 : Figure</span>
<span class="sd">            The amplitude plot :math:`a(\omega)`.</span>
<span class="sd">        fig2 : Figure</span>
<span class="sd">            The phase plot :math:`\beta(\omega)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract the FRC data</span>
        <span class="n">a</span>         <span class="o">=</span> <span class="n">FRC</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
        <span class="n">omega_bbc</span> <span class="o">=</span> <span class="n">FRC</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;omega_bbc&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
        <span class="n">omega</span>     <span class="o">=</span> <span class="n">FRC</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;omega&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)])</span>
        <span class="n">phase</span>     <span class="o">=</span> <span class="n">FRC</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;phase&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)])</span>
        <span class="n">omega_bif</span> <span class="o">=</span> <span class="n">FRC</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;omega_bif&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)])</span>
        <span class="n">phase_bif</span> <span class="o">=</span> <span class="n">FRC</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;phase_bif&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)])</span>
        
        <span class="c1"># Extract the keyword arguments</span>
        <span class="n">fig_param</span>  <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fig_param&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
        <span class="n">amp_name</span>   <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;amp_name&quot;</span><span class="p">,</span> <span class="s2">&quot;amplitude&quot;</span><span class="p">)</span>
        <span class="n">phase_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;phase_name&quot;</span><span class="p">,</span> <span class="s2">&quot;phase&quot;</span><span class="p">)</span>
        <span class="n">xlim</span>       <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;xlim&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">coeff</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">omega_bbc</span><span class="p">)</span> <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">xlim</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            
        <span class="c1"># FRC - amplitude </span>
        <span class="n">fig1</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="o">**</span><span class="n">fig_param</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omega_bbc</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:grey&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">omega_bbc</span><span class="p">),</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegai</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:blue&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">omegai</span> <span class="ow">in</span> <span class="n">omega</span><span class="p">]</span>
        <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegai</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:red&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span> <span class="k">for</span> <span class="n">omegai</span> <span class="ow">in</span> <span class="n">omega_bif</span><span class="p">]</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\omega$&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$</span><span class="si">{}</span><span class="s2">$&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">amp_name</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># FRC - phase</span>
        <span class="n">fig2</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="o">**</span><span class="n">fig_param</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">omega_bbc</span><span class="p">),</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
        <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegai</span><span class="p">,</span> <span class="n">phasei</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:blue&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">omegai</span><span class="p">,</span> <span class="n">phasei</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">phase</span><span class="p">)]</span>
        <span class="p">[</span><span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegai</span><span class="p">,</span> <span class="n">phasei</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:red&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">omegai</span><span class="p">,</span> <span class="n">phasei</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">omega_bif</span><span class="p">,</span> <span class="n">phase_bif</span><span class="p">)]</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\omega$&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$</span><span class="si">{}</span><span class="s2">$&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phase_name</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">fig1</span><span class="p">,</span> <span class="n">fig2</span></div>

    
<div class="viewcode-block" id="Steady_state.plot_ARC">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Steady_state.plot_ARC">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_ARC</span><span class="p">(</span><span class="n">ARC</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the amplitude-response curves (ARC), both forcing amplitude-amplitude and forcing amplitude-phase.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ARC : dict</span>
<span class="sd">            Dictionary containing the amplitude response curves.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig1 : Figure</span>
<span class="sd">            The amplitude plot :math:`a(F)`.</span>
<span class="sd">        fig2 : Figure</span>
<span class="sd">            The phase plot :math:`\beta(F)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="c1"># Extract the FRC data and keyword arguments</span>
        <span class="n">a</span>     <span class="o">=</span> <span class="n">ARC</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
        <span class="n">F</span>     <span class="o">=</span> <span class="n">ARC</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">ARC</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;phase&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
        
        <span class="c1"># Extract the keyword arguments</span>
        <span class="n">fig_param</span>  <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fig_param&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
        <span class="n">amp_name</span>   <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;amp_name&quot;</span><span class="p">,</span> <span class="s2">&quot;amplitude&quot;</span><span class="p">)</span>
        <span class="n">phase_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;phase_name&quot;</span><span class="p">,</span> <span class="s2">&quot;phase&quot;</span><span class="p">)</span>
        <span class="n">xlim</span>       <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;xlim&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">F</span><span class="p">)])</span>

        <span class="c1"># ARC - amplitude </span>
        <span class="n">fig1</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="o">**</span><span class="n">fig_param</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:blue&quot;</span><span class="p">)</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$F$&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$</span><span class="si">{}</span><span class="s2">$&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">amp_name</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># ARC - phase</span>
        <span class="n">fig2</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="o">**</span><span class="n">fig_param</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;tab:blue&quot;</span><span class="p">)</span>
        
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xlim</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$F$&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$</span><span class="si">{}</span><span class="s2">$&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phase_name</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">fig1</span><span class="p">,</span> <span class="n">fig2</span></div>
</div>



<div class="viewcode-block" id="Substitutions_SS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Substitutions_SS">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Substitutions_SS</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Substitutions used in the steady state evaluations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mms</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_scaling_back</span> <span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_scaling_back</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_B</span>            <span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_B</span>
        <span class="k">pass</span></div>

        
    
<div class="viewcode-block" id="Forcing_SS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Forcing_SS">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Forcing_SS</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define the forcing on the system.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mms</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span>            <span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_order</span>      <span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">f_order</span></div>

        
<div class="viewcode-block" id="Coord_SS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Coord_SS">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Coord_SS</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The coordinates used in the steady state analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>      
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>

    
<div class="viewcode-block" id="Sol_SS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Sol_SS">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Sol_SS</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solutions obtained when evaluating at steady state.</span>
<span class="sd">    &quot;&quot;&quot;</span>                
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">mms</span><span class="p">):</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">ndof</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="n">xio</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">ss</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_SS</span><span class="p">)</span> <span class="k">for</span> <span class="n">xio</span> <span class="ow">in</span> <span class="n">mms</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">xMMS_polar</span><span class="p">[</span><span class="n">ix</span><span class="p">]]</span> <span class="p">)</span></div>

        
<div class="viewcode-block" id="Stab_SS">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Stab_SS">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Stab_SS</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stability analysis parameters and outputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>                
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>  </div>

    
<span class="c1">#%% Chain rule functions written for the MMS</span>
<div class="viewcode-block" id="Chain_rule_dfdt">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Chain_rule_dfdt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">Chain_rule_dfdt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">tS</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the chain rule to express first order time derivatives in terms of the time scales&#39; derivatives.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f: sympy.Function  </span>
<span class="sd">        Time scales-dependent function :math:`f(\boldsymbol{t})`.</span>
<span class="sd">    tS: list </span>
<span class="sd">        Time scales :math:`\boldsymbol{t}^\intercal = [t_0, \cdots, t_{N_e}]`.</span>
<span class="sd">    eps: sympy.Symbol</span>
<span class="sd">        Small parameter :math:`\epsilon`.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dfdt: sympy.Function</span>
<span class="sd">        :math:`\mathrm{d} f/ \mathrm{d}t` expressed in terms of the time scales.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Consider a time scales-dependent function :math:`f(t_0, t_1, ...)`, where :math:`t_0` is the fast time and :math:`t_1, ...` are the slow times. </span>
<span class="sd">    The Chain Rule is applied to give the expression of :math:`\mathrm{d} f/ \mathrm{d}t` in terms of the time scales.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tS</span><span class="p">)</span>
    <span class="n">dfdt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nt</span><span class="p">):</span>
        <span class="n">dfdt</span> <span class="o">+=</span> <span class="n">eps</span><span class="o">**</span><span class="n">ii</span> <span class="o">*</span> <span class="n">f</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tS</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">dfdt</span></div>


<div class="viewcode-block" id="Chain_rule_d2fdt2">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.Chain_rule_d2fdt2">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">Chain_rule_d2fdt2</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">tS</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the chain rule to express second order time derivatives in terms of the time scales&#39; derivatives.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f: sympy.Function  </span>
<span class="sd">        Time scales-dependent function :math:`f(\boldsymbol{t})`.</span>
<span class="sd">    tS: list </span>
<span class="sd">        Time scales :math:`\boldsymbol{t}^\intercal = [t_0, \cdots, t_{N_e}]`.</span>
<span class="sd">    eps: sympy.Symbol</span>
<span class="sd">        Small parameter :math:`\epsilon`.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    d2fdt2: sympy.Function</span>
<span class="sd">        :math:`\mathrm{d}^2 f/ \mathrm{d}t^2` expressed in terms of the time scales.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Consider a time scales-dependent function :math:`f(t_0, t_1, ...)`, where :math:`t_0` is the fast time and :math:`t_1, ...` are the slow times. </span>
<span class="sd">    The Chain Rule is applied to give the expression of :math:`\mathrm{d}^2 f/ \mathrm{d}t^2` in terms of the time scales.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tS</span><span class="p">)</span>
    <span class="n">d2fdt2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nt</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nt</span><span class="p">):</span>
            <span class="n">d2fdt2</span> <span class="o">+=</span> <span class="n">eps</span><span class="o">**</span><span class="p">(</span><span class="n">jj</span><span class="o">+</span><span class="n">ii</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tS</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">tS</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">d2fdt2</span></div>


<div class="viewcode-block" id="cartesian_to_polar">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.cartesian_to_polar">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cartesian_to_polar</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">sub_polar</span><span class="p">,</span> <span class="n">sub_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rewrites an expression or a matrix `y` from cartesian to polar coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : sympy.Expr or sympy.Matrix</span>
<span class="sd">        A sympy expression or matrix written in cartesian coordinates.</span>
<span class="sd">    sub_polar: list</span>
<span class="sd">        A list of substitutions to perform to go from cartesian to polar coordinates. </span>
<span class="sd">    sub_phase: list, optional</span>
<span class="sd">        Additional substitutions to try and get rid of phases, so that only the amplitude remains in the expression.</span>
<span class="sd">        Default is `None`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    yp: sympy.Expr or sympy.Matrix</span>
<span class="sd">        The initial expression or matrix written in polar coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">is_Matrix</span><span class="p">:</span>
        <span class="n">yp</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_polar</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sub_phase</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">yp</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_polar</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phase</span>     <span class="o">=</span> <span class="n">sub_phase</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sub_tan</span>   <span class="o">=</span> <span class="p">[(</span><span class="n">tan</span><span class="p">(</span><span class="n">phase</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))]</span>
            <span class="n">yp</span> <span class="o">=</span> <span class="n">TR8</span><span class="p">((</span><span class="n">TR5</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_polar</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_phase</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_tan</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub_phase</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">yp</span></div>


<span class="c1">#%% Numpy transforms and plot functions</span>


<div class="viewcode-block" id="rescale">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.rescale">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rescale</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">mms</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rescales a scaled expression.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    expr: sympy.Expr</span>
<span class="sd">        An unscaled expression, i.e. an expression appearing at some order of :math:`\epsilon`.</span>
<span class="sd">    mms: Multiple_scales_system</span>
<span class="sd">        The mms system, containing substitutions to scale an expression.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    expr_scaled: sympy.Expr</span>
<span class="sd">        The scaled expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr_rescaled</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="o">*</span><span class="n">mms</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_sigma</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">sub</span><span class="o">.</span><span class="n">sub_scaling_back</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">expr_rescaled</span></div>


<div class="viewcode-block" id="numpise_FRC">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.numpise_FRC">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">numpise_FRC</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">dyn</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">bbc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">forced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bif</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the frequency-response and bifurcation curves at given numerical values.</span>
<span class="sd">    This transforms the sympy expressions to numpy arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mms : Multiple_scales_system</span>
<span class="sd">        The MMS object.</span>
<span class="sd">    ss : Steady_state</span>
<span class="sd">        The MMS results evaluated at steady state.</span>
<span class="sd">    dyn : Dynamical_system</span>
<span class="sd">        The initial dynamical system.</span>
<span class="sd">    param : dict</span>
<span class="sd">        A dictionary whose values are tuples with 2 elements:</span>

<span class="sd">        1. The sympy symbol of a parameter,</span>

<span class="sd">        2. The numerical value(s) taken by that parameter.</span>

<span class="sd">        The key of the amplitude vector must be ``&quot;a&quot;``.</span>
<span class="sd">        The key of the forcing amplitude must be ``&quot;F&quot;``.</span>
<span class="sd">    bbc : bool, optional</span>
<span class="sd">        Evaluate the backbone curve. </span>
<span class="sd">        Default is `True`.</span>
<span class="sd">    forced : bool, optional</span>
<span class="sd">        Evaluate the forced response. </span>
<span class="sd">        Default is `True`.</span>
<span class="sd">    bif : bool, optional</span>
<span class="sd">        Evaluate the bifurcation curves. </span>
<span class="sd">        Default is `True`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    FRC : dict</span>
<span class="sd">        The frequency-response curves data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    
    <span class="c1"># Information</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Converting sympy FRC expressions to numpy&quot;</span><span class="p">)</span>

    <span class="c1"># Initialisation</span>
    <span class="n">a</span>     <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">F_val</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">FRC</span>   <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="n">a</span><span class="p">}</span>

    <span class="c1"># Evaluation of the FRC</span>
    <span class="k">if</span> <span class="n">bbc</span><span class="p">:</span>
        <span class="n">FRC</span><span class="p">[</span><span class="s2">&quot;omega_bbc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpise_omega_bbc</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">forced</span><span class="p">:</span>
        <span class="n">FRC</span><span class="p">[</span><span class="s2">&quot;omega&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpise_omega_FRC</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
        <span class="n">FRC</span><span class="p">[</span><span class="s2">&quot;phase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpise_phase</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">dyn</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">FRC</span><span class="p">[</span><span class="s2">&quot;omega&quot;</span><span class="p">],</span> <span class="n">F_val</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bif</span><span class="p">:</span>
        <span class="n">FRC</span><span class="p">[</span><span class="s2">&quot;omega_bif&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpise_omega_bif</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
        <span class="n">FRC</span><span class="p">[</span><span class="s2">&quot;phase_bif&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpise_phase</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">dyn</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">FRC</span><span class="p">[</span><span class="s2">&quot;omega_bif&quot;</span><span class="p">],</span> <span class="n">F_val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">FRC</span></div>


<div class="viewcode-block" id="numpise_ARC">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.numpise_ARC">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">numpise_ARC</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">dyn</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the amplitude-response curves at given numerical values. </span>
<span class="sd">    This transforms the sympy expressions to numpy arrays. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mms : Multiple_scales_system</span>
<span class="sd">        The MMS object.</span>
<span class="sd">    ss : Steady_state</span>
<span class="sd">        The MMS results evaluated at steady state.</span>
<span class="sd">    dyn : Dynamical_system</span>
<span class="sd">        The initial dynamical system.</span>
<span class="sd">    param : dict</span>
<span class="sd">        A dictionnary whose values are tuples with 2 elements:</span>

<span class="sd">        1. The sympy symbol of a parameter,</span>

<span class="sd">        2. The numerical value(s) taken by that parameter.</span>

<span class="sd">        The key of the amplitude vector must be ``&quot;a&quot;``.</span>
<span class="sd">        The key of the angular frequency must be ``&quot;omega&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ARC: dict</span>
<span class="sd">        The amplitude-response curves data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Information</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Converting sympy ARC expressions to numpy&quot;</span><span class="p">)</span>

    <span class="c1"># Initialisation</span>
    <span class="n">a</span>         <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">omega_val</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;omega&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ARC</span>       <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="n">a</span><span class="p">}</span>

    <span class="c1"># Evaluation of the FRC</span>
    <span class="n">ARC</span><span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">]</span>     <span class="o">=</span> <span class="n">numpise_F_ARC</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="n">ARC</span><span class="p">[</span><span class="s2">&quot;phase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpise_phase</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">dyn</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">omega_val</span><span class="p">,</span> <span class="n">ARC</span><span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ARC</span></div>


<div class="viewcode-block" id="numpise_omega_bbc">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.numpise_omega_bbc">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">numpise_omega_bbc</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numpise the backbone curve&#39;s frequency :math:`\omega_{\textrm{bbc}}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mms: Multiple_scales_system</span>
<span class="sd">    ss: Steady_state</span>
<span class="sd">    param: dict</span>
<span class="sd">        See :func:`~MMS.sympy_functions.sympy_to_numpy`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    omega_bbc: numpy.ndarray</span>
<span class="sd">        Numpised backbone curve&#39;s frequency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">omega_bbc</span>  <span class="o">=</span> <span class="n">sfun</span><span class="o">.</span><span class="n">sympy_to_numpy</span><span class="p">(</span><span class="n">rescale</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">omega_bbc</span><span class="p">,</span> <span class="n">mms</span><span class="p">),</span> <span class="n">param</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">omega_bbc</span></div>


<div class="viewcode-block" id="numpise_omega_FRC">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.numpise_omega_FRC">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">numpise_omega_FRC</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numpise the forced response&#39;s frequency :math:`\omega`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mms: Multiple_scales_system</span>
<span class="sd">    ss: Steady_state</span>
<span class="sd">    param: dict</span>
<span class="sd">        See :func:`~MMS.sympy_functions.sympy_to_numpy`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    omega: numpy.ndarray</span>
<span class="sd">        Numpised forced response&#39;s frequency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">sfun</span><span class="o">.</span><span class="n">sympy_to_numpy</span><span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">omegaMMS</span> <span class="o">+</span> <span class="n">rescale</span><span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">eps</span><span class="o">*</span><span class="n">sigmai</span><span class="p">,</span> <span class="n">mms</span><span class="p">),</span> <span class="n">param</span><span class="p">))</span> <span class="k">for</span> <span class="n">sigmai</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sigma</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">omega</span></div>


<div class="viewcode-block" id="numpise_omega_bif">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.numpise_omega_bif">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">numpise_omega_bif</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numpise the bifurcation curves&#39; frequency :math:`\omega_{\textrm{bif}}`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mms: Multiple_scales_system</span>
<span class="sd">    ss: Steady_state</span>
<span class="sd">    param: dict</span>
<span class="sd">        See :func:`~MMS.sympy_functions.sympy_to_numpy`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    omega_bif: list of numpy.ndarray</span>
<span class="sd">        Numpised bifurcation curves&#39; frequency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">omega_bif</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">sfun</span><span class="o">.</span><span class="n">sympy_to_numpy</span><span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">omegaMMS</span> <span class="o">+</span> <span class="n">rescale</span><span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">eps</span><span class="o">*</span><span class="n">sigmai</span><span class="p">,</span> <span class="n">mms</span><span class="p">),</span> <span class="n">param</span><span class="p">))</span> <span class="k">for</span> <span class="n">sigmai</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">stab</span><span class="o">.</span><span class="n">bif_sigma</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">omega_bif</span></div>


<div class="viewcode-block" id="numpise_phase">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.numpise_phase">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">numpise_phase</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">dyn</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numpise the phase :math:`\beta_i`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mms: Multiple_scales_system</span>
<span class="sd">    ss: Steady_state</span>
<span class="sd">    dyn: Dynamical_system</span>
<span class="sd">    param: dict</span>
<span class="sd">        See :func:`~MMS.sympy_functions.sympy_to_numpy`.</span>
<span class="sd">    omega: numpy.ndarray or list of numpy.ndarray</span>
<span class="sd">        The frequency array.</span>
<span class="sd">    F: numpy.ndarray</span>
<span class="sd">        The forcing amplitude array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phase: list of numpy.ndarray</span>
<span class="sd">        Numpised phase.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="p">[</span><span class="n">omega</span><span class="p">]</span>
        
    <span class="n">phase</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">omegai</span> <span class="ow">in</span> <span class="n">omega</span><span class="p">:</span>
        <span class="n">param_phase</span> <span class="o">=</span> <span class="n">param</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="n">omegai</span><span class="p">),</span> <span class="n">F</span><span class="o">=</span><span class="p">(</span><span class="n">dyn</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">F</span><span class="p">))</span>
        <span class="n">sin_phase</span> <span class="o">=</span> <span class="n">sfun</span><span class="o">.</span><span class="n">sympy_to_numpy</span><span class="p">(</span> <span class="n">rescale</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">sin_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mms</span><span class="p">),</span> <span class="n">param_phase</span> <span class="p">)</span>
        <span class="n">cos_phase</span> <span class="o">=</span> <span class="n">sfun</span><span class="o">.</span><span class="n">sympy_to_numpy</span><span class="p">(</span> <span class="n">rescale</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">cos_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mms</span><span class="p">),</span> <span class="n">param_phase</span> <span class="p">)</span>
        <span class="n">phase</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">sin_phase</span><span class="p">,</span> <span class="n">cos_phase</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">phase</span></div>


<div class="viewcode-block" id="numpise_F_ARC">
<a class="viewcode-back" href="../../modules.html#MMS.MMS.numpise_F_ARC">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">numpise_F_ARC</span><span class="p">(</span><span class="n">mms</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">param</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numpise the forced response&#39;s forcing amplitude :math:`F`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mms: Multiple_scales_system</span>
<span class="sd">    ss: Steady_state</span>
<span class="sd">    param: dict</span>
<span class="sd">        See :func:`~MMS.sympy_functions.sympy_to_numpy`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    F: numpy.ndarray</span>
<span class="sd">        Numpised forced response&#39;s forcing amplitude.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">sfun</span><span class="o">.</span><span class="n">sympy_to_numpy</span><span class="p">(</span><span class="n">rescale</span><span class="p">(</span><span class="n">mms</span><span class="o">.</span><span class="n">eps</span><span class="o">**</span><span class="n">mms</span><span class="o">.</span><span class="n">forcing</span><span class="o">.</span><span class="n">f_order</span> <span class="o">*</span> <span class="n">ss</span><span class="o">.</span><span class="n">sol</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">mms</span><span class="p">),</span> <span class="n">param</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">F</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Vincent MAHE.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>