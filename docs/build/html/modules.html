

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modules &mdash; OSCILATE 0.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=7026087e"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="_static/copybutton.js?v=f281be69"></script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Package Architecture" href="architecture.html" />
    <link rel="prev" title="OSCILATE documentation" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            OSCILATE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-oscilate.MMS">MMS Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Chain_rule_d2fdt2"><code class="docutils literal notranslate"><span class="pre">Chain_rule_d2fdt2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Chain_rule_dfdt"><code class="docutils literal notranslate"><span class="pre">Chain_rule_dfdt()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Coord_MMS"><code class="docutils literal notranslate"><span class="pre">Coord_MMS</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Coord_SS"><code class="docutils literal notranslate"><span class="pre">Coord_SS</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Dynamical_system"><code class="docutils literal notranslate"><span class="pre">Dynamical_system</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Forcing"><code class="docutils literal notranslate"><span class="pre">Forcing</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Forcing_MMS"><code class="docutils literal notranslate"><span class="pre">Forcing_MMS</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Forcing_SS"><code class="docutils literal notranslate"><span class="pre">Forcing_SS</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.apply_MMS"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.apply_MMS()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.asymptotic_series"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.asymptotic_series()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.autonomous_phases"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.autonomous_phases()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.compute_EqMMS"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.compute_EqMMS()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.evolution_equations"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.evolution_equations()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.find_harmonics"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.find_harmonics()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.forcing_MMS"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.forcing_MMS()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.oscillators_frequencies"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.oscillators_frequencies()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.polar_coordinates"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.polar_coordinates()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.secular_analysis"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.secular_analysis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.sol_higher_order"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.sol_higher_order()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.sol_order_0"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.sol_order_0()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.sol_xMMS_polar"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.sol_xMMS_polar()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.system_t0"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.system_t0()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.time_scales"><code class="docutils literal notranslate"><span class="pre">Multiple_scales_system.time_scales()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Sol_MMS"><code class="docutils literal notranslate"><span class="pre">Sol_MMS</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Sol_SS"><code class="docutils literal notranslate"><span class="pre">Sol_SS</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Stab_SS"><code class="docutils literal notranslate"><span class="pre">Stab_SS</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Steady_state"><code class="docutils literal notranslate"><span class="pre">Steady_state</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.Jacobian_cartesian"><code class="docutils literal notranslate"><span class="pre">Steady_state.Jacobian_cartesian()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.Jacobian_polar"><code class="docutils literal notranslate"><span class="pre">Steady_state.Jacobian_polar()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.additional_cartesian_substitutions"><code class="docutils literal notranslate"><span class="pre">Steady_state.additional_cartesian_substitutions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.bifurcation_curves"><code class="docutils literal notranslate"><span class="pre">Steady_state.bifurcation_curves()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.cartesian_coordinates"><code class="docutils literal notranslate"><span class="pre">Steady_state.cartesian_coordinates()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.check_cartesian_substitutions"><code class="docutils literal notranslate"><span class="pre">Steady_state.check_cartesian_substitutions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.eigenvalues"><code class="docutils literal notranslate"><span class="pre">Steady_state.eigenvalues()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.evolution_equations_SS"><code class="docutils literal notranslate"><span class="pre">Steady_state.evolution_equations_SS()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.evolution_equations_cartesian"><code class="docutils literal notranslate"><span class="pre">Steady_state.evolution_equations_cartesian()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.plot_ARC"><code class="docutils literal notranslate"><span class="pre">Steady_state.plot_ARC()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.plot_FRC"><code class="docutils literal notranslate"><span class="pre">Steady_state.plot_FRC()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.polar_coordinates_SS"><code class="docutils literal notranslate"><span class="pre">Steady_state.polar_coordinates_SS()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.solve_F"><code class="docutils literal notranslate"><span class="pre">Steady_state.solve_F()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.solve_a"><code class="docutils literal notranslate"><span class="pre">Steady_state.solve_a()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.solve_bbc"><code class="docutils literal notranslate"><span class="pre">Steady_state.solve_bbc()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.solve_forced"><code class="docutils literal notranslate"><span class="pre">Steady_state.solve_forced()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.solve_phase"><code class="docutils literal notranslate"><span class="pre">Steady_state.solve_phase()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.solve_sigma"><code class="docutils literal notranslate"><span class="pre">Steady_state.solve_sigma()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.stability_analysis"><code class="docutils literal notranslate"><span class="pre">Steady_state.stability_analysis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#oscilate.MMS.Steady_state.substitution_solve_dof"><code class="docutils literal notranslate"><span class="pre">Steady_state.substitution_solve_dof()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Substitutions_MMS"><code class="docutils literal notranslate"><span class="pre">Substitutions_MMS</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.Substitutions_SS"><code class="docutils literal notranslate"><span class="pre">Substitutions_SS</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.cartesian_to_polar"><code class="docutils literal notranslate"><span class="pre">cartesian_to_polar()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.numpise_ARC"><code class="docutils literal notranslate"><span class="pre">numpise_ARC()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.numpise_FRC"><code class="docutils literal notranslate"><span class="pre">numpise_FRC()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.numpise_F_ARC"><code class="docutils literal notranslate"><span class="pre">numpise_F_ARC()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.numpise_omega_FRC"><code class="docutils literal notranslate"><span class="pre">numpise_omega_FRC()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.numpise_omega_bbc"><code class="docutils literal notranslate"><span class="pre">numpise_omega_bbc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.numpise_omega_bif"><code class="docutils literal notranslate"><span class="pre">numpise_omega_bif()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.numpise_phase"><code class="docutils literal notranslate"><span class="pre">numpise_phase()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.rescale"><code class="docutils literal notranslate"><span class="pre">rescale()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.MMS.scale_parameters"><code class="docutils literal notranslate"><span class="pre">scale_parameters()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-oscilate.sympy_functions">sympy_functions Module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.sympy_functions.check_solvability"><code class="docutils literal notranslate"><span class="pre">check_solvability()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.sympy_functions.get_block_diagonal_indices"><code class="docutils literal notranslate"><span class="pre">get_block_diagonal_indices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.sympy_functions.get_exponent"><code class="docutils literal notranslate"><span class="pre">get_exponent()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.sympy_functions.is_block_diagonal"><code class="docutils literal notranslate"><span class="pre">is_block_diagonal()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.sympy_functions.polynomial_terms"><code class="docutils literal notranslate"><span class="pre">polynomial_terms()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.sympy_functions.solve_poly2"><code class="docutils literal notranslate"><span class="pre">solve_poly2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.sympy_functions.sub_deep"><code class="docutils literal notranslate"><span class="pre">sub_deep()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#oscilate.sympy_functions.sympy_to_numpy"><code class="docutils literal notranslate"><span class="pre">sympy_to_numpy()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">Package Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Application Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="readme.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="citation.html">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="notice.html">Legal Notices</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">OSCILATE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Modules</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/modules.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="modules">
<h1>Modules<a class="headerlink" href="#modules" title="Link to this heading"></a></h1>
<section id="module-oscilate.MMS">
<span id="mms-module"></span><h2>MMS Module<a class="headerlink" href="#module-oscilate.MMS" title="Link to this heading"></a></h2>
<p>Started on Tue Feb 15 17:25:59 2022</p>
<p>&#64;author: Vincent MAHE</p>
<p>Analyse systems of coupled nonlinear equations using the Method of Multiple Scales (MMS).</p>
<table class="autosummary longtable docutils align-default">
<tbody>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.Chain_rule_d2fdt2">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Chain_rule_d2fdt2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Chain_rule_d2fdt2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Chain_rule_d2fdt2" title="Link to this definition"></a></dt>
<dd><p>Apply the chain rule to express second order time derivatives in terms of the time scales’ derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>sympy.Function</em>) – Time scales-dependent function <span class="math notranslate nohighlight">\(f(\boldsymbol{t})\)</span>.</p></li>
<li><p><strong>tS</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a>) – Time scales <span class="math notranslate nohighlight">\(\boldsymbol{t}^\intercal = [t_0, \cdots, t_{N_e}]\)</span>.</p></li>
<li><p><strong>eps</strong> (<em>sympy.Symbol</em>) – Small parameter <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>d2fdt2</strong> – <span class="math notranslate nohighlight">\(\mathrm{d}^2 f/ \mathrm{d}t^2\)</span> expressed in terms of the time scales.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Function</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Consider a time scales-dependent function <span class="math notranslate nohighlight">\(f(t_0, t_1, ...)\)</span>, where <span class="math notranslate nohighlight">\(t_0\)</span> is the fast time and <span class="math notranslate nohighlight">\(t_1, ...\)</span> are the slow times.
The Chain Rule is applied to give the expression of <span class="math notranslate nohighlight">\(\mathrm{d}^2 f/ \mathrm{d}t^2\)</span> in terms of the time scales.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.Chain_rule_dfdt">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Chain_rule_dfdt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Chain_rule_dfdt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Chain_rule_dfdt" title="Link to this definition"></a></dt>
<dd><p>Apply the chain rule to express first order time derivatives in terms of the time scales’ derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>sympy.Function</em>) – Time scales-dependent function <span class="math notranslate nohighlight">\(f(\boldsymbol{t})\)</span>.</p></li>
<li><p><strong>tS</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a>) – Time scales <span class="math notranslate nohighlight">\(\boldsymbol{t}^\intercal = [t_0, \cdots, t_{N_e}]\)</span>.</p></li>
<li><p><strong>eps</strong> (<em>sympy.Symbol</em>) – Small parameter <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dfdt</strong> – <span class="math notranslate nohighlight">\(\mathrm{d} f/ \mathrm{d}t\)</span> expressed in terms of the time scales.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Function</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Consider a time scales-dependent function <span class="math notranslate nohighlight">\(f(t_0, t_1, ...)\)</span>, where <span class="math notranslate nohighlight">\(t_0\)</span> is the fast time and <span class="math notranslate nohighlight">\(t_1, ...\)</span> are the slow times.
The Chain Rule is applied to give the expression of <span class="math notranslate nohighlight">\(\mathrm{d} f/ \mathrm{d}t\)</span> in terms of the time scales.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Coord_MMS">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Coord_MMS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Coord_MMS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Coord_MMS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The coordinates used in the MMS.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Coord_SS">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Coord_SS</span></span><a class="reference internal" href="_modules/oscilate/MMS.html#Coord_SS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Coord_SS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The coordinates used in the steady state analysis.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Dynamical_system">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Dynamical_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omegas</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Dynamical_system"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Dynamical_system" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The dynamical system studied.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>sympy.Symbol</em>) – time <span class="math notranslate nohighlight">\(t\)</span>.</p></li>
<li><p><strong>x</strong> (<em>sympy.Function</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Function</em>) – Unknown(s) of the problem.</p></li>
<li><p><strong>Eq</strong> (<em>sympy.Expr</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Expr</em>) – System’s equations without forcing, which can be defined separately (see parameters <cite>F</cite> and <cite>fF</cite>).
Eq is the unforced system of equations describing the system’s dynamics.</p></li>
<li><p><strong>omegas</strong> (<em>sympy.Symbol</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Symbol</em>) – The natural frequency of each oscillator.</p></li>
<li><p><strong>F</strong> (<em>sympy.Symbol</em><em> or </em><em>0</em><em>, </em><em>optional</em>) – Forcing amplitude <span class="math notranslate nohighlight">\(F\)</span>.
Default is 0.</p></li>
<li><p><strong>fF</strong> (<em>sympy.Expr</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Expr</em><em>, </em><em>optional</em>) – For each oscillator, specify the coefficient multiplying the forcing terms in the equation.
It can be used to define parametric forcing. Typically, if the forcing is <span class="math notranslate nohighlight">\(x F \cos(\omega t)\)</span>, then <code class="docutils literal notranslate"><span class="pre">fF</span> <span class="pre">=</span> <span class="pre">x</span></code>.
Default is a list of 1, so the forcing is direct.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Systems considered are typically composed of <span class="math notranslate nohighlight">\(N\)</span> coupled nonlinear equations of the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
\ddot{x}_0 + \omega_0^2 x_0 &amp; = f_0(\boldsymbol{x}, \dot{\boldsymbol{x}}, \ddot{\boldsymbol{x}}, t), \\
&amp; \vdots \\
\ddot{x}_{N-1} + \omega_{N-1}^2 x_{N-1} &amp; = f_{N-1}(\boldsymbol{x}, \dot{\boldsymbol{x}}, \ddot{\boldsymbol{x}}, t).
\end{cases}\end{split}\]</div>
<p>The <span class="math notranslate nohighlight">\(x_i(t)\)</span> (<span class="math notranslate nohighlight">\(i=0,...,N-1\)</span>) are the oscillators’ coordinates (dof for degrees of freedom),</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{x}(t)^\intercal = [x_0(t), x_1(t), \cdots, x_{N-1}(t)]\]</div>
<p>is the vector containing all the oscillators’ coordinates (<span class="math notranslate nohighlight">\(^\intercal\)</span> denotes the transpose),
<span class="math notranslate nohighlight">\(\omega_i\)</span> are their natural frequencies,
<span class="math notranslate nohighlight">\(t\)</span> is the time,
<span class="math notranslate nohighlight">\(\dot{(\bullet)} = \textrm{d}(\bullet)/\textrm{d}t\)</span> denotes a time-derivative.
<span class="math notranslate nohighlight">\(f_i\)</span> are functions which can contain:</p>
<ul>
<li><p><strong>Weak linear terms</strong> in <span class="math notranslate nohighlight">\(x_i\)</span>, <span class="math notranslate nohighlight">\(\dot{x}_i\)</span>, or <span class="math notranslate nohighlight">\(\ddot{x}_i\)</span>.</p></li>
<li><p><strong>Weak linear coupling terms</strong> involving <span class="math notranslate nohighlight">\(x_j\)</span>, <span class="math notranslate nohighlight">\(\dot{x}_j\)</span>, or <span class="math notranslate nohighlight">\(\ddot{x}_j\)</span> with <span class="math notranslate nohighlight">\(j \neq i\)</span>.</p></li>
<li><p><strong>Weak nonlinear terms</strong>. Taylor expansions are performed to approximate nonlinear terms as polynomial nonlinearities.</p></li>
<li><p><strong>Forcing terms</strong>, which can be:</p>
<blockquote>
<div><ul class="simple">
<li><p><em>Hard</em> (appearing at leading order) or <em>weak</em> (small).</p></li>
<li><p>Primarily harmonic, e.g., <span class="math notranslate nohighlight">\(F \cos(\omega t)\)</span>, where <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(\omega\)</span> are the forcing amplitude and frequency, respectively.</p></li>
<li><p>Modulated by any function (constant, linear, or nonlinear) to model parametric forcing (e.g., <span class="math notranslate nohighlight">\(x_i(t) F \cos(\omega t)\)</span>).</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>Internal resonance relations among oscillators can be specified in a second step by expressing the <span class="math notranslate nohighlight">\(\omega_i\)</span> as a function of a reference frequency.
Detuning can also be introduced during this step.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Forcing">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Forcing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fF</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Forcing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Forcing" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Define the forcing on the system as</p>
<ul class="simple">
<li><p>A forcing amplitude <cite>F</cite>,</p></li>
<li><p>Forcing coefficients <cite>fF</cite>, used to introduce parametric forcing or simply weight the harmonic forcing.</p></li>
</ul>
<p>For the <span class="math notranslate nohighlight">\(i^\textrm{th}\)</span> oscillator, denoting <cite>fF[i]</cite> as <span class="math notranslate nohighlight">\(f_{F,i}(\boldsymbol{x}(t), \dot{\boldsymbol{x}}(t), \ddot{\boldsymbol{x}}(t))\)</span>,
the forcing term on that oscillator is <span class="math notranslate nohighlight">\(f_{F,i} F \cos(\omega t)\)</span>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Forcing_MMS">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Forcing_MMS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">F</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fF</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forcing_term</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Forcing_MMS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Forcing_MMS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Define the forcing on the system as</p>
<ul class="simple">
<li><p>A forcing amplitude <cite>F</cite></p></li>
<li><p>A scaling order <cite>f_order</cite> for the forcing</p></li>
<li><p>Forcing coefficients <cite>fF</cite></p></li>
<li><p>Forcing terms (direct or parametric) <cite>forcing_term</cite></p></li>
</ul>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Forcing_SS">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Forcing_SS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Forcing_SS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Forcing_SS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Define the forcing on the system.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Multiple_scales_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamical_system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ne</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega_ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_scaling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio_omegaMMS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps_pow_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The multiple scales system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dynamical_system</strong> (<a class="reference internal" href="#oscilate.MMS.Dynamical_system" title="oscilate.MMS.Dynamical_system"><em>Dynamical_system</em></a>) – The dynamical system.</p></li>
<li><p><strong>eps</strong> (<em>sympy.Symbol</em>) – Small perturbation parameter <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p></li>
<li><p><strong>Ne</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – Truncation order of the asymptotic series and order of the slowest time scale.</p></li>
<li><p><strong>omega_ref</strong> (<em>sympy.Symbol</em>) – Reference frequency <span class="math notranslate nohighlight">\(\omega_{\textrm{ref}}\)</span> of the MMS.
Not necessarily the frequency around which the MMS is going to be applied, see <cite>ratio_omegaMMS</cite>.</p></li>
<li><p><strong>sub_scaling</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>tuples</em>) – Substitutions to do to scale the equations.
Links small parameters to their scaled counterpart through <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p></li>
<li><p><strong>ratio_omegaMMS</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> or </em><em>sympy.Rational</em><em>, </em><em>optional</em>) – <p>Specify the frequency <cite>omegaMMS</cite> around which the MMS is going to be applied in terms of <span class="math notranslate nohighlight">\(\omega_{\textrm{ref}}\)</span>.
Denoting <cite>ratio_omegaMMS</cite> as <span class="math notranslate nohighlight">\(r_{\textrm{MMS}}\)</span>, this means that</p>
<div class="math notranslate nohighlight">
\[\omega_{\textrm{MMS}} = r_{\textrm{MMS}} \omega_{\textrm{ref}}.\]</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">ratio_omegaMMS=Rational(p,q)</span></code> for</p>
<div class="math notranslate nohighlight">
\[q \omega_{\textrm{MMS}} = p \omega_{\textrm{ref}}\]</div>
<p>to get better-looking results than the float <span class="math notranslate nohighlight">\(p/q\)</span>.
Default is 1.</p>
</p></li>
<li><p><strong>eps_pow_0</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em>, </em><em>optional</em>) – <p>Order of the leading order term in the asymptotic series of each oscillators’ response.
For the <span class="math notranslate nohighlight">\(i^{\textrm{th}}\)</span> oscillator and denoting <cite>eps_pow_0</cite> as <span class="math notranslate nohighlight">\(\lambda_0\)</span>, this means that</p>
<div class="math notranslate nohighlight">
\[x_i = \epsilon^{\lambda_0} x_{i,0} + \epsilon^{\lambda_0+1} x_{i,1} + \cdots.\]</div>
<p>Default is 0.</p>
</p></li>
<li><p><strong>ratio_omega_osc</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> or </em><em>sympy.Rational</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – <p>Specify the natural frequencies of the oscillators <span class="math notranslate nohighlight">\(\omega_i\)</span> in terms of the reference frequency <span class="math notranslate nohighlight">\(\omega_{\textrm{ref}}\)</span>.
Denoting <code class="docutils literal notranslate"><span class="pre">ratio_omega_osc[i]</span></code> as <span class="math notranslate nohighlight">\(r_i\)</span>, this means that</p>
<div class="math notranslate nohighlight">
\[\omega_i \approx r_i \omega_{\textrm{ref}}.\]</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">ratio_omega_osc[i]=Rational(p,q)</span></code> for</p>
<div class="math notranslate nohighlight">
\[q \omega_{i} \approx p \omega_{\textrm{ref}}\]</div>
<p>to get better-looking results than the float <span class="math notranslate nohighlight">\(p/q\)</span>.
Default is <cite>None</cite> for each oscillator, so the <span class="math notranslate nohighlight">\(\omega_i\)</span> are arbitrary and there are no internal resonances.
Detuning can be introduced through the <cite>detunings</cite> keyword argument.</p>
</p></li>
<li><p><strong>detunings</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Symbol</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em>, </em><em>optional</em>) – <p>The detuning of each oscillator. Denoting <code class="docutils literal notranslate"><span class="pre">detunings[i]</span></code> as <span class="math notranslate nohighlight">\(\delta_i\)</span>, this means that</p>
<div class="math notranslate nohighlight">
\[\omega_i = r_i \omega_{\textrm{ref}} + \delta_i.\]</div>
<p>Default is 0 for each oscillator.</p>
</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Description of the method of multiple scales.</p>
<section id="asymptotic-series-and-time-scales">
<h3>Asymptotic series and time scales<a class="headerlink" href="#asymptotic-series-and-time-scales" title="Link to this heading"></a></h3>
<p>The starting point is to introduce asymptotic series and multiple time scales in the initial dynamical system.
The solution for oscillator <span class="math notranslate nohighlight">\(i\)</span> is sought as a series expansion up to order <span class="math notranslate nohighlight">\(N_e\)</span> (for a leading order term <span class="math notranslate nohighlight">\(\epsilon^0 = 1\)</span>). This expansion takes the form</p>
<div class="math notranslate nohighlight">
\[x_i(t) = x_{i,0}(t) + \epsilon x_{i,1}(t) + \epsilon^2 x_{i,2}(t) + \cdots + \epsilon^{N_e} x_{i,N_e}(t) + \mathcal{O}(\epsilon^{N_e+1}).\]</div>
<p>Time scales are introduced as follows:</p>
<div class="math notranslate nohighlight">
\[t_0 = t, \; t_1 = \epsilon t, \; t_2 = \epsilon^2 t, \cdots, t_{N_e} = \epsilon^{N_e} t,\]</div>
<p>where <span class="math notranslate nohighlight">\(t_0\)</span> is the fast time, i.e. the time used to describe the oscillations,
while <span class="math notranslate nohighlight">\(t_1, \; t_2,\; \cdots,\; t_{N_e}\)</span> are slow times, associated to amplitude and phase variations of the solutions in time. In addition, the chain rule gives</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\dfrac{\textrm{d}(\bullet)}{\textrm{d}t}     &amp; = \sum_{i=0}^{N_e} \epsilon^{i} \dfrac{\partial(\bullet)}{\partial t_i} + \mathcal{O}(\epsilon^{N_e+1}), \\
\dfrac{\textrm{d}^2(\bullet)}{\textrm{d}t^2} &amp; = \sum_{j=0}^{N_e}\sum_{i=0}^{N_e} \epsilon^{i+j} \dfrac{\partial}{\partial t_j}\dfrac{\partial(\bullet)}{\partial t_i} + \mathcal{O}(\epsilon^{N_e+1}).
\end{aligned}\end{split}\]</div>
<p>The introduction of asymptotic series and time scales are performed using <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.asymptotic_series" title="oscilate.MMS.Multiple_scales_system.asymptotic_series"><code class="xref py py-func docutils literal notranslate"><span class="pre">asymptotic_series()</span></code></a> and <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.time_scales" title="oscilate.MMS.Multiple_scales_system.time_scales"><code class="xref py py-func docutils literal notranslate"><span class="pre">time_scales()</span></code></a>.</p>
</section>
<section id="scaling">
<h3>Scaling<a class="headerlink" href="#scaling" title="Link to this heading"></a></h3>
<p>The construction of the MMS system requires a scaling of the parameters. Most scalings are already passed to the MMS through the <cite>sub_scaling</cite> parameter.
However, the natural frequencies also need to be scaled as they can contain both a leading order term and a detuning term.
Natural frequencies <span class="math notranslate nohighlight">\(\omega_i\)</span> are defined as a function of the reference frequency <span class="math notranslate nohighlight">\(\omega_{\textrm{ref}}\)</span> through the <cite>ratio_omega_osc</cite> optional parameter, which is then used in <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.oscillators_frequencies" title="oscilate.MMS.Multiple_scales_system.oscillators_frequencies"><code class="xref py py-func docutils literal notranslate"><span class="pre">oscillators_frequencies()</span></code></a>.
This allows to define internal resonance relations among the oscillators.
If these internal resonances are not perfect, detunings can be introduced through the <cite>detunings</cite> optional parameter, which needs to be scaled and part of the <cite>sub_scaling</cite> parameter.</p>
<p>To write the MMS system it is convenient to introduce the leading order natural frequencies</p>
<div class="math notranslate nohighlight">
\[\omega_{i,0} = r_i \omega_{\textrm{ref}},\]</div>
<p>where <span class="math notranslate nohighlight">\(r_i\)</span> stands for <code class="docutils literal notranslate"><span class="pre">ratio_omega_osc[i]</span></code>.</p>
</section>
<section id="the-multiple-scales-system">
<h3>The multiple scales system<a class="headerlink" href="#the-multiple-scales-system" title="Link to this heading"></a></h3>
<p>Introducing the asymptotic series, the time scales and the scaled parameters in the initial dynamical system (see <code class="xref py py-class docutils literal notranslate"><span class="pre">Dynamical_system</span></code>) results in <span class="math notranslate nohighlight">\(N_e+1\)</span> dynamical systems, each one appearing at different orders of <span class="math notranslate nohighlight">\(\epsilon\)</span>.
Denoting time scales derivatives as</p>
<div class="math notranslate nohighlight">
\[\textrm{D}_i(\bullet) = \partial (\bullet) / \partial t_i,\]</div>
<p>introducing the vector of time scales</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{t}^\intercal = [t_0, t_1, \cdots, t_{N_e}],\]</div>
<p>where <span class="math notranslate nohighlight">\(^\intercal\)</span> denotes the transpose, and the vectors of asymptotic coordinates</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{x}_i(\boldsymbol{t})^\intercal = [x_{0,i}(\boldsymbol{t}), x_{1,i}(\boldsymbol{t}), \cdots, x_{N-1, i}(\boldsymbol{t})],\]</div>
<p>which contains all the asymptotic terms of order <span class="math notranslate nohighlight">\(i\)</span>, the MMS equations can be written as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
&amp; \epsilon^0 \rightarrow \;
\begin{cases}
\textrm{D}_0 x_{0,0} + \omega_{0,0}^2 x_{0,0} &amp; = f_{0,0}(t_0, t_1), \\
&amp; \vdots \\
\textrm{D}_0 x_{N-1,0} + \omega_{N-1,0}^2 x_{N-1,0} &amp; = f_{N-1,0}(t_0, t_1),
\end{cases} \\[15pt]
&amp; \epsilon^1 \rightarrow \;
\begin{cases}
\textrm{D}_0 x_{0,1} + \omega_{0,0}^2 x_{0,1} &amp; = f_{0,1}  (\boldsymbol{x}_0, \textrm{D}_0 \boldsymbol{x}_0, \textrm{D}_0^2 \boldsymbol{x}_0, \textrm{D}_1 \boldsymbol{x}_0, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_0, t_0, t_1), \\
&amp; \vdots \\
\textrm{D}_0 x_{N-1,1} + \omega_{N-1,0}^2 x_{N-1,1} &amp; = f_{N-1,1}(\boldsymbol{x}_0, \textrm{D}_0 \boldsymbol{x}_0, \textrm{D}_0^2 \boldsymbol{x}_0, \textrm{D}_1 \boldsymbol{x}_0, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_0, t_0, t_1),
\end{cases} \\[15pt]
&amp; \epsilon^2 \rightarrow \;
\begin{cases}
\textrm{D}_0 x_{0,2} + \omega_{0,0}^2 x_{0,2} &amp; = f_{0,2}  (\boldsymbol{x}_0, \cdots, \textrm{D}_0 \textrm{D}_2 \boldsymbol{x}_0, \boldsymbol{x}_1, \cdots, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_1, t_0, t_1), \\
&amp; \vdots \\
\textrm{D}_0 x_{N-1,2} + \omega_{N-1,0}^2 x_{N-1,2} &amp; = f_{N-1,2}(\boldsymbol{x}_0, \cdots, \textrm{D}_0 \textrm{D}_2 \boldsymbol{x}_0, \boldsymbol{x}_1, \cdots, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_1, t_0, t_1),
\end{cases} \\[10pt]
&amp; \hspace{3cm} \vdots \\[10pt]
&amp; \epsilon^{N_e} \rightarrow \;
\begin{cases}
\textrm{D}_0 x_{0,N_e} + \omega_{0,0}^2 x_{0,N_e} &amp; = f_{0,N_e}  (\boldsymbol{x}_0, \cdots, \textrm{D}_0 \textrm{D}_{N_e} \boldsymbol{x}_0, \cdots, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_{N_e-1}, t_0, t_1), \\
&amp; \vdots \\
\textrm{D}_0 x_{N-1,N_e} + \omega_{N-1,0}^2 x_{N-1,N_e} &amp; = f_{N-1,N_e}(\boldsymbol{x}_0, \cdots, \textrm{D}_0 \textrm{D}_{N_e} \boldsymbol{x}_0, \cdots, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_{N_e-1}, t_0, t_1).
\end{cases}
\end{aligned}\end{split}\]</div>
<p>Consider oscillator <span class="math notranslate nohighlight">\(i\)</span> at order <span class="math notranslate nohighlight">\(j\)</span>:</p>
<ul class="simple">
<li><p>The left-hand side term represents a harmonic oscillator of frequency <span class="math notranslate nohighlight">\(\omega_{i,0}\)</span> oscillating with respect to the fast time <span class="math notranslate nohighlight">\(t_0\)</span>.</p></li>
<li><p>The right-hand side term <span class="math notranslate nohighlight">\(f_{i,j}\)</span> is analogous to a forcing generated by all combinations of terms that appear on oscillator <span class="math notranslate nohighlight">\(i\)</span>’s equation at order <span class="math notranslate nohighlight">\(\epsilon^j\)</span>.
This can involve lower order terms <span class="math notranslate nohighlight">\(x_{i,\ell}, \; \ell \leq j\)</span>, coupling terms <span class="math notranslate nohighlight">\(x_{k, \ell}, \; k \neq j,\; \ell \leq j\)</span>, their derivatives and cross-derivatives with respect to the time scales, and physical forcing terms.
The later is responsible for the dependency on <span class="math notranslate nohighlight">\(t_0,\; t_1\)</span>. The reason why slower time scales are not involved will be explained in the following.</p></li>
</ul>
<p>Function <span class="math notranslate nohighlight">\(f_{i,j}\)</span> tends to get increasingly complex as the order increases because the initial equations generate more high order terms than low order ones.</p>
<p>This operation is performed using <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.compute_EqMMS" title="oscilate.MMS.Multiple_scales_system.compute_EqMMS"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_EqMMS()</span></code></a>.</p>
<p>Note that internal resonance relations can be given through the <cite>ratio_omega_osc</cite> optional parameter, which is then used in <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.oscillators_frequencies" title="oscilate.MMS.Multiple_scales_system.oscillators_frequencies"><code class="xref py py-func docutils literal notranslate"><span class="pre">oscillators_frequencies()</span></code></a>.</p>
</section>
<section id="frequency-of-interest">
<h3>Frequency of interest<a class="headerlink" href="#frequency-of-interest" title="Link to this heading"></a></h3>
<p>The response of <span class="math notranslate nohighlight">\(x_i\)</span> will be analysed at a frequency <span class="math notranslate nohighlight">\(\omega\)</span>, defined as</p>
<div class="math notranslate nohighlight">
\[\omega = \omega_{\textrm{MMS}} + \epsilon \sigma,\]</div>
<p>where <span class="math notranslate nohighlight">\(\omega_{\textrm{MMS}}\)</span> is the <strong>central MMS frequency</strong>, controlled through the <cite>ratio_omegaMMS</cite> optional parameter and expressed in terms of <cite>omega_ref</cite>,
and <span class="math notranslate nohighlight">\(\sigma\)</span> is a detuning about that frequency.
In case the forced response is studied, <span class="math notranslate nohighlight">\(\omega\)</span> corresponds to the forcing frequency.
In case the free response is studied, <span class="math notranslate nohighlight">\(\omega\)</span> corresponds to the frequency of free oscillations, which generates the backbone curve of the forced response.
Note that <span class="math notranslate nohighlight">\(\omega t = \omega_{\textrm{MMS}} t_0 + \sigma t_1\)</span>. This is the reason why the forcing only involves these two time scales in the right-hand side functions of the MMS system.</p>
</section>
<section id="iteratively-solving-the-mms-system">
<h3>Iteratively solving the MMS system<a class="headerlink" href="#iteratively-solving-the-mms-system" title="Link to this heading"></a></h3>
<p>The multiple scales system can be solved iteratively by solving successively the systems of equations at each order.</p>
<section id="leading-order-solution">
<h4>Leading order solution<a class="headerlink" href="#leading-order-solution" title="Link to this heading"></a></h4>
<p>The leading order solution for oscillator <span class="math notranslate nohighlight">\(i\)</span> must satisfy</p>
<div class="math notranslate nohighlight">
\[\textrm{D}_0 x_{i,0} + \omega_{i,0}^2 x_{i,0} = f_{i,0}(t_0, t_1).\]</div>
<p>It is sought as</p>
<div class="math notranslate nohighlight">
\[x_{i,0}(\boldsymbol{t}) = x_{i,0}^\textrm{h}(\boldsymbol{t}) + x_{i,0}^\textrm{p}(t_0, t_1),\]</div>
<p>where <span class="math notranslate nohighlight">\(x_{i,0}^\textrm{h}(\boldsymbol{t})\)</span> and <span class="math notranslate nohighlight">\(x_{i,0}^\textrm{p}(t_0, t_1)\)</span> are the leading order homogeneous and particular sollutions, respectively.</p>
<p>It is now conveninent to introduce the slow times vector</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{t}_s^\intercal = [t_1, \cdots, t_{N_e}].\]</div>
<p>This way, one can express the leading order solutions as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
x_{i,0}^\textrm{h}(\boldsymbol{t}) &amp; = A_i(\boldsymbol{t}_s) e^{\textrm{j} \omega_{i,0} t_0} + cc = |A_i(\boldsymbol{t}_s)| \cos(\omega_{i,0} t_0 + \arg{A_i(\boldsymbol{t}_s)}),
\\
x_{i,0}^\textrm{p}(t_0, t_1) &amp; = B_i e^{\textrm{j} \omega t} + cc = B_i e^{\textrm{j} (\omega_{\textrm{MMS}} t_0 + \sigma t_1)} + cc = |B_i| \cos(\omega_{\textrm{MMS}} t_0 + \sigma t_1 + \arg{B_i}),
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(A_i\)</span> is a slow time-dependent complex amplitude to be determined while <span class="math notranslate nohighlight">\(B_i\)</span> is a time-independent function of the forcing parameters.
<span class="math notranslate nohighlight">\(cc\)</span> denotes the complex conjugate.
Note that in most situations, forcing does not appear at leading order (i.e. forcing is weak), so <span class="math notranslate nohighlight">\(B_i=0\)</span>.</p>
<p>In the following it will be convenient to use the notations</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\boldsymbol{A}(\boldsymbol{t}_s)^\intercal &amp; = [A_0(\boldsymbol{t}_s), A_1(\boldsymbol{t}_s), \cdots, A_{N-1}(\boldsymbol{t}_s)], \\
\boldsymbol{B}^\intercal &amp; = [B_0, B_1, \cdots, B_{N-1}].
\end{split}\end{split}\]</div>
<p>The leading order solutions are defined in <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.sol_order_0" title="oscilate.MMS.Multiple_scales_system.sol_order_0"><code class="xref py py-func docutils literal notranslate"><span class="pre">sol_order_0()</span></code></a>.</p>
</section>
<section id="higher-order-solutions">
<h4>Higher order solutions<a class="headerlink" href="#higher-order-solutions" title="Link to this heading"></a></h4>
<p>Once the leading order solutions are computed, they can be injected in the <span class="math notranslate nohighlight">\(1^\textrm{st}\)</span> higher order equations, where they (and their derivatives) appear as <em>forcing terms</em>, potentially together with physical forcing.
The <span class="math notranslate nohighlight">\(1^\textrm{st}\)</span> higher order equation for oscillator <span class="math notranslate nohighlight">\(i\)</span> is</p>
<div class="math notranslate nohighlight">
\[\textrm{D}_0 x_{i,1} + \omega_{i,0}^2 x_{i,1} = f_{i,1}(\boldsymbol{x}_0, \textrm{D}_0 \boldsymbol{x}_0, \textrm{D}_0^2 \boldsymbol{x}_0, \textrm{D}_1 \boldsymbol{x}_0, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_0, t_0, t_1).\]</div>
<p>The forcing terms that involve oscillations at <span class="math notranslate nohighlight">\(\omega_{i,0}\)</span> would force the oscillator on its natural frequency. Moreover, damping is always weak in the MMS, so damping terms of the form
<span class="math notranslate nohighlight">\(c \textrm{D}_0 x_{i,1}\)</span> do not appear at this order.
The aforementioned forcing terms would thus lead to unbounded solutions, which is unphysical.
These forcing terms, called <strong>secular terms</strong>, must therefore be eliminated.
For instance, the <span class="math notranslate nohighlight">\(1^\textrm{st}\)</span> higher order equation for oscillator <span class="math notranslate nohighlight">\(i\)</span> with the secular terms cancelled is</p>
<div class="math notranslate nohighlight">
\[\textrm{D}_0 x_{i,1} + \omega_{i,0}^2 x_{i,1} = \bar{f}_{i,1}(\boldsymbol{x}_0, \textrm{D}_0 \boldsymbol{x}_0, \textrm{D}_0^2 \boldsymbol{x}_0, \textrm{D}_1 \boldsymbol{x}_0, \textrm{D}_0\textrm{D}_1 \boldsymbol{x}_0, t_0, t_1).\]</div>
<p>where <span class="math notranslate nohighlight">\(\bar{f}_{i,1}\)</span> is <span class="math notranslate nohighlight">\(f_{i,1}\)</span> with the secular terms cancelled, i.e. without terms oscillating as <span class="math notranslate nohighlight">\(\omega_{i,0}\)</span>.
After cancelation of the secular terms, each oscillator’s equation can be solved as a forced harmonic oscillator with the independent variable <span class="math notranslate nohighlight">\(t_0\)</span>.</p>
<p>Note that only the particular solutions are considered when solving higher order terms, i.e.</p>
<div class="math notranslate nohighlight">
\[x_{i,1}(\boldsymbol{t}) = \underbrace{x_{i,1}^\textrm{h}(\boldsymbol{t})}_{=0} + x_{i,1}^\textrm{p}(t_0, t_1).\]</div>
<p>This choice can be justified if one assumes that initial conditions are of leading order. Though this is questionable, it is assumed here.</p>
<p>The higher order solutions <span class="math notranslate nohighlight">\(x_{i,1}(\boldsymbol{t})\)</span> are expressed as a function of the leading order unknown amplitudes <span class="math notranslate nohighlight">\(\boldsymbol{A}(\boldsymbol{t}_s)\)</span>,
their slow time derivatives <span class="math notranslate nohighlight">\(\textrm{D}_i\boldsymbol{A}(\boldsymbol{t}_s), \; i=1, ..., N_e\)</span>, and forcing terms if any (including the hard forcing amplitudes <span class="math notranslate nohighlight">\(\boldsymbol{B}\)</span>).</p>
<p>This process is repeated successively at each order, i.e. the computed solutions are introduced in the next higher order system of equations,
secular terms are cancelled and the next higher order solutions are computed.</p>
<p>The secular terms are identified in <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.secular_analysis" title="oscilate.MMS.Multiple_scales_system.secular_analysis"><code class="xref py py-func docutils literal notranslate"><span class="pre">secular_analysis()</span></code></a> and the leading order solutions are computed in <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.sol_higher_order" title="oscilate.MMS.Multiple_scales_system.sol_higher_order"><code class="xref py py-func docutils literal notranslate"><span class="pre">sol_higher_order()</span></code></a>.
Note that <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.sol_higher_order" title="oscilate.MMS.Multiple_scales_system.sol_higher_order"><code class="xref py py-func docutils literal notranslate"><span class="pre">sol_higher_order()</span></code></a> is applied on equations with only <span class="math notranslate nohighlight">\(t_0\)</span> as the independent variable so as to allow the use of <a class="reference external" href="https://docs.sympy.org/latest/modules/solvers/ode.html#sympy.solvers.ode.dsolve" title="(in SymPy v1.14.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.
This is enforced using <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.system_t0" title="oscilate.MMS.Multiple_scales_system.system_t0"><code class="xref py py-func docutils literal notranslate"><span class="pre">system_t0()</span></code></a>, which temporarily ignores the dependency of <span class="math notranslate nohighlight">\(\boldsymbol{A}(\boldsymbol{t}_s)\)</span> on the slow time scales.</p>
</section>
<section id="secular-analysis">
<h4>Secular analysis<a class="headerlink" href="#secular-analysis" title="Link to this heading"></a></h4>
<p>At this stage, the solutions are all expressed in terms of the unknown amplitudes <span class="math notranslate nohighlight">\(\boldsymbol{A}(\boldsymbol{t}_s)\)</span> and their slow time derivatives <span class="math notranslate nohighlight">\(\textrm{D}_1 A_i(\boldsymbol{t}_s),\; \cdots,\; \textrm{D}_{N_e} A_i(\boldsymbol{t}_s)\)</span>.
These can be obtained from the elimination of the secular terms (called <strong>secular conditions</strong>), as described below.</p>
<p>The <span class="math notranslate nohighlight">\(i^\textrm{th}\)</span> MMS equation at <span class="math notranslate nohighlight">\(1^\textrm{st}\)</span> higher order involves the slow time derivative <span class="math notranslate nohighlight">\(\textrm{D}_1 A_i(\boldsymbol{t}_s)\)</span>, which appears
in the secular term. It is coming from the chain rule</p>
<div class="math notranslate nohighlight">
\[\dfrac{\textrm{d}^2 x_i(t)}{\textrm{d}t^2} = \dfrac{\partial^2 x_{i,0}(\boldsymbol{t})}{\partial t_0^2} + \epsilon \dfrac{\partial^2 x_{i,1}(\boldsymbol{t})}{\partial t_0^2} + 2 \epsilon \dfrac{\partial^2 x_{i,0}(\boldsymbol{t})}{\partial t_0 \partial t_1} + \mathcal{O}(\epsilon^2).\]</div>
<p>In addition, the <span class="math notranslate nohighlight">\(\textrm{D}_1 A_j(\boldsymbol{t}_s),\; j\neq i\)</span> do not appear in the <span class="math notranslate nohighlight">\(i^\textrm{th}\)</span> MMS equation as couplings among oscillators are weak.
It is thus possible to use the secular conditions in order to express the <span class="math notranslate nohighlight">\(\textrm{D}_1 A_i(\boldsymbol{t}_s)\)</span> as a function of <span class="math notranslate nohighlight">\(\boldsymbol{A}(\boldsymbol{t}_s)\)</span>.</p>
<p>This process can be done successively at each order to obtain the system of complex evolution equations</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
\textrm{D}_1 A_i(\boldsymbol{t}_s) &amp; = f_{A_i}^{(1)}(\boldsymbol{A}, t_1), \\
&amp; \vdots \\
\textrm{D}_{N_e} A_i(\boldsymbol{t}_s) &amp; = f_{A_i}^{(N_e)}(\boldsymbol{A}, t_1).
\end{cases}\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(f_{A_i}^{(j)}(\boldsymbol{A}, t_1)\)</span> are functions governing the evolution of <span class="math notranslate nohighlight">\(A_i\)</span> with respect to the slow time <span class="math notranslate nohighlight">\(t_j\)</span>.
Note the dependency of <span class="math notranslate nohighlight">\(f_{A_i}^{(j)}\)</span> on <span class="math notranslate nohighlight">\(t_1\)</span> due to the possible presence of forcing. The complex evolution equations are derived in <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.secular_analysis" title="oscilate.MMS.Multiple_scales_system.secular_analysis"><code class="xref py py-func docutils literal notranslate"><span class="pre">secular_analysis()</span></code></a>.</p>
<p>The above system of <span class="math notranslate nohighlight">\(1^\textrm{st}\)</span> order PDE can theoretically be solved to obtain the complex amplitudes <span class="math notranslate nohighlight">\(\boldsymbol{A}\)</span>.
However, this approach is not the prefered one as</p>
<ul class="simple">
<li><p>It is more convenient to deal with real variables than complex ones to get a physical meaning from the analysis,</p></li>
<li><p>It is more convenient to deal with autonomous systems (without the explicit <span class="math notranslate nohighlight">\(t_1\)</span>-dependency) than nonautonomous ones,</p></li>
<li><p>The PDEs are complex.</p></li>
</ul>
<p>The first two points can be achieved introducing new coordinates, as described thereafter.</p>
</section>
</section>
<section id="evolution-equations">
<h3>Evolution equations<a class="headerlink" href="#evolution-equations" title="Link to this heading"></a></h3>
<section id="polar-coordinates">
<h4>Polar coordinates<a class="headerlink" href="#polar-coordinates" title="Link to this heading"></a></h4>
<p>As discussed previously, it is more convenient to deal with real variables than complex ones. This can be done introducing the polar coordinates <span class="math notranslate nohighlight">\(a_i\)</span> and <span class="math notranslate nohighlight">\(\phi_i\)</span> for oscillator <span class="math notranslate nohighlight">\(i\)</span> such that</p>
<div class="math notranslate nohighlight">
\[A_i(\boldsymbol{t}_s) = \dfrac{1}{2} a_i(\boldsymbol{t}_s) e^{\textrm{j} \phi_i(\boldsymbol{t}_s)}.\]</div>
<p><span class="math notranslate nohighlight">\(a_i\)</span> and <span class="math notranslate nohighlight">\(\phi_i\)</span> correspond to the amplitude and phase of the leading solution for oscillator <span class="math notranslate nohighlight">\(i\)</span>, respectively.
With these new coordinates and introducing</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\boldsymbol{a}(\boldsymbol{t}_s)^\intercal &amp; = [a_0(\boldsymbol{t}_s), a_1(\boldsymbol{t}_s), \cdots, a_{N-1}(\boldsymbol{t}_s)], \\
\boldsymbol{\phi}(\boldsymbol{t}_s)^\intercal &amp; = [\phi_0(\boldsymbol{t}_s), \phi_1(\boldsymbol{t}_s), \cdots, \phi_{N-1}(\boldsymbol{t}_s)],
\end{aligned}\end{split}\]</div>
<p>the evolution equations on the <span class="math notranslate nohighlight">\(A_i(\boldsymbol{t}_s)\)</span> can be split into real and imaginary terms, leading to</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
&amp; \epsilon^1 \rightarrow \;
\begin{cases}
\textrm{D}_1 a_i &amp; = \hat{f}_{a_i}^{(1)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1), \\
a_i \textrm{D}_1 \phi_i &amp; = \hat{f}_{\phi_i}^{(1)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1),
\end{cases}
\\[5pt]
&amp; \hspace{3cm} \vdots \\[5pt]
&amp; \epsilon^{N_e} \rightarrow \;
\begin{cases}
\textrm{D}_{N_e} a_i &amp; = \hat{f}_{a_i}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1), \\
a_i \textrm{D}_{N_e} \phi_i &amp; = \hat{f}_{\phi_i}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1).
\end{cases}
\end{aligned}\end{split}\]</div>
<p>The <span class="math notranslate nohighlight">\(\epsilon^j \rightarrow\)</span> indicate a system of 2 equations originating from the secular analysis at order <span class="math notranslate nohighlight">\(j\)</span>.
As one has</p>
<div class="math notranslate nohighlight">
\[\textrm{D}_j A_i = \textrm{D}_j \dfrac{1}{2} a_i e^{\textrm{j} \phi_i} = \dfrac{1}{2} \textrm{D}_j \left( a_i \right) e^{\textrm{j} \phi_i} + \textrm{j} \dfrac{1}{2} a_i e^{\textrm{j} \phi_i} \textrm{D}_j \left( \phi_i \right),\]</div>
<p>it is convenient to pre-multiply the evolution equations on the <span class="math notranslate nohighlight">\(A_i(\boldsymbol{t}_s)\)</span> by <span class="math notranslate nohighlight">\(e^{-\textrm{j} \phi_i(\boldsymbol{t}_s)}\)</span> or even <span class="math notranslate nohighlight">\(\gamma e^{-\textrm{j} \phi_i(\boldsymbol{t}_s)}\)</span> with, for instance, <span class="math notranslate nohighlight">\(\gamma = 2\)</span>.
This avoids the presence of <span class="math notranslate nohighlight">\(\cos(\phi_i)\)</span>, <span class="math notranslate nohighlight">\(\sin(\phi_i)\)</span> and many <span class="math notranslate nohighlight">\(1/2\)</span> terms in the evolution equations.
The evolution functions on polar coordinates are therefore defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
\hat{f}_{a_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1) &amp; = \Re\left[ 2 e^{-\textrm{j} \phi_i(\boldsymbol{t}_s)} f_{A_i}^{(j)}(\boldsymbol{A}, t_1) \right], \\
\hat{f}_{\phi_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\phi}, t_1) &amp; = \Im\left[ 2 e^{-\textrm{j} \phi_i(\boldsymbol{t}_s)} f_{A_i}^{(j)}(\boldsymbol{A}, t_1) \right].
\end{cases}\end{split}\]</div>
<p>The evolution equations system on the polar coordinates involves only real variables, but functions <span class="math notranslate nohighlight">\(\hat{f}_{a_i}^{(j)}\)</span> and <span class="math notranslate nohighlight">\(\hat{f}_{\phi_i}^{(j)}\)</span> are
still nonautonomous due to the explicit dependency on <span class="math notranslate nohighlight">\(t_1\)</span>.</p>
<p>The polar coordinates are introduced in <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.polar_coordinates" title="oscilate.MMS.Multiple_scales_system.polar_coordinates"><code class="xref py py-func docutils literal notranslate"><span class="pre">polar_coordinates()</span></code></a>. The real evolution equations are only computed for the autonomous system, as described below.</p>
</section>
<section id="autonomous-phase-coordinates">
<h4>Autonomous phase coordinates<a class="headerlink" href="#autonomous-phase-coordinates" title="Link to this heading"></a></h4>
<p>The presence of nonautonomous terms stems from forcing terms, which involve <span class="math notranslate nohighlight">\(\cos(\sigma t_1 - \phi_i), \; \sin(\sigma t_1 - \phi_i)\)</span> in the polar evolution functions of oscillator <span class="math notranslate nohighlight">\(i\)</span>.
A change of phase coordinates is required to make this autonomous.
Moreover, the change of phase coordinate is necessary even in the absence of forcing for a convenient representation of the leading order solution.
Indeed, the solution for <span class="math notranslate nohighlight">\(x^{\textrm{h}}_{i,0}(\boldsymbol{t})\)</span> written in terms of the current polar coordinates is</p>
<div class="math notranslate nohighlight">
\[x^{\textrm{h}}_{i,0}(\boldsymbol{t}) = a_i(\boldsymbol{t}_s) \cos(\omega_{i,0} t_0 + \phi_i(\boldsymbol{t}_s)).\]</div>
<p>However, one would eventually like to express the oscillations of oscillator <span class="math notranslate nohighlight">\(i\)</span> in terms of the frequency <span class="math notranslate nohighlight">\(\omega\)</span>. To force its appearance, we recall that</p>
<div class="math notranslate nohighlight">
\[\omega_{i,0} = r_i \omega_{\textrm{ref}}, \quad \omega_{\textrm{ref}} = \frac{1}{r_{\textrm{MMS}}} \omega_{\textrm{MMS}}, \quad \textrm{and} \quad \omega_{\textrm{MMS}} = \omega - \epsilon \sigma.\]</div>
<p>Introducing this in the leading order solution leads to</p>
<div class="math notranslate nohighlight">
\[x^{\textrm{h}}_{i,0}(\boldsymbol{t}) = a_i(\boldsymbol{t}_s) \cos\left( \frac{r_i}{r_{\textrm{MMS}}} \omega t_0 - \frac{r_i}{r_{\textrm{MMS}}} \sigma t_1 + \phi_i(\boldsymbol{t}_s)\right).\]</div>
<p>It therefore appears convenient to introduce the new phase coordinate <span class="math notranslate nohighlight">\(\beta_i(\boldsymbol{t}_s)\)</span> as</p>
<div class="math notranslate nohighlight">
\[\beta_i(\boldsymbol{t}_s) = \frac{r_i}{r_{\textrm{MMS}}} \sigma t_1 - \phi_i(\boldsymbol{t}_s),\]</div>
<p>which allows to write the leading order solution as</p>
<div class="math notranslate nohighlight">
\[x^{\textrm{h}}_{i,0}(\boldsymbol{t}) = a_i(\boldsymbol{t}_s) \cos\left( \frac{r_i}{r_{\textrm{MMS}}} \omega t_0 - \beta_i(\boldsymbol{t}_s)\right).\]</div>
<p>In addition, and as discussed previously, the introduction of these new phase coordinates removes the explicit dependency of the evolution functions on <span class="math notranslate nohighlight">\(t_1\)</span>, which was due to terms <span class="math notranslate nohighlight">\(\cos(\sigma t_1 - \phi_i), \; \sin(\sigma t_1 - \phi_i)\)</span>.
The forcing phase being zero (i.e. reference phase), the <span class="math notranslate nohighlight">\(\beta_i(\boldsymbol{t}_s)\)</span> can be seen as the phases relative to the forcing.</p>
<p>Introducing the notation</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{\beta}(\boldsymbol{t}_s)^\intercal = [\beta_1(\boldsymbol{t}_s), \beta_2(\boldsymbol{t}_s), \dots, \beta_{N_e}(\boldsymbol{t}_s)],\]</div>
<p>the evolution equations can be rewritten as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
&amp; \epsilon^1 \rightarrow \;
\begin{cases}
\textrm{D}_1 a_0(\boldsymbol{t}_s) &amp; = f_{a_0}^{(1)}(\boldsymbol{a}, \boldsymbol{\beta}), \\
a_0 \textrm{D}_1 \beta_0(\boldsymbol{t}_s) &amp; = f_{\beta_0}^{(1)}(\boldsymbol{a}, \boldsymbol{\beta}), \\
&amp; \vdots \\
\textrm{D}_1 a_{N-1}(\boldsymbol{t}_s) &amp; = f_{a_{N-1}}^{(1)}(\boldsymbol{a}, \boldsymbol{\beta}), \\
a_{N-1} \textrm{D}_1 \beta_{N-1}(\boldsymbol{t}_s) &amp; = f_{\beta_{N-1}}^{(1)}(\boldsymbol{a}, \boldsymbol{\beta}),
\end{cases} \\[5pt]
&amp; \hspace{3cm} \vdots \\[5pt]
&amp; \epsilon^{N_e} \rightarrow \;
\begin{cases}
\textrm{D}_{N_e} a_0(\boldsymbol{t}_s) &amp; = f_{a_0}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\beta}), \\
a_0 \textrm{D}_{N_e} \beta_0(\boldsymbol{t}_s) &amp; = f_{\beta_0}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\beta}), \\
&amp; \vdots \\
\textrm{D}_{N_e} a_{N-1}(\boldsymbol{t}_s) &amp; = f_{a_{N-1}}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\beta}), \\
a_{N-1} \textrm{D}_{N_e} \beta_{N-1}(\boldsymbol{t}_s) &amp; = f_{\beta_{N-1}}^{(N_e)}(\boldsymbol{a}, \boldsymbol{\beta}).
\end{cases}
\end{aligned}\end{split}\]</div>
<p>The above system is the key result of the application of the MMS as it governs the evolution of leading order amplitudes and phases, on which all higher order solutions depend.
It can be solved numerically or analytically, if analytical solutions exist, though it is generally not the case.
It can also be rewritten in a more compact form as discussed in the following.</p>
<p>The autonomous phase coordinates are introduced in <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.autonomous_phases" title="oscilate.MMS.Multiple_scales_system.autonomous_phases"><code class="xref py py-func docutils literal notranslate"><span class="pre">autonomous_phases()</span></code></a> and the evolution equations are computed in <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.evolution_equations" title="oscilate.MMS.Multiple_scales_system.evolution_equations"><code class="xref py py-func docutils literal notranslate"><span class="pre">evolution_equations()</span></code></a>.</p>
<p>All solutions previously computed using the complex amplitudes <span class="math notranslate nohighlight">\(\boldsymbol{A}(\boldsymbol{t}_s)\)</span> can be rewritten in terms of the polar coordinates <span class="math notranslate nohighlight">\(\boldsymbol{a}(\boldsymbol{t}_s),\; \boldsymbol{\beta}(\boldsymbol{t}_s)\)</span> using <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.sol_xMMS_polar" title="oscilate.MMS.Multiple_scales_system.sol_xMMS_polar"><code class="xref py py-func docutils literal notranslate"><span class="pre">sol_xMMS_polar()</span></code></a>.</p>
</section>
<section id="reintroduction-of-the-physical-time">
<h4>Reintroduction of the physical time<a class="headerlink" href="#reintroduction-of-the-physical-time" title="Link to this heading"></a></h4>
<p>Recalling the chain rule</p>
<div class="math notranslate nohighlight">
\[\dfrac{\textrm{d}(\bullet)}{\textrm{d}t} = \sum_{i=0}^{N_e} \epsilon^{i} \textrm{D}_i(\bullet),\]</div>
<p>and reintroducing the physical time, the systems at each order can be summed up to write</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
\dfrac{\textrm{d}}{dt} a_0(t) &amp; = f_{a_0}(\boldsymbol{a}, \boldsymbol{\beta}), \\
a_0 \dfrac{\textrm{d}}{dt} \beta_0(t) &amp; = f_{\beta_0}(\boldsymbol{a}, \boldsymbol{\beta}), \\
&amp; \vdots \\
\dfrac{\textrm{d}}{dt} a_{N-1}(t) &amp; = f_{a_{N-1}}(\boldsymbol{a}, \boldsymbol{\beta}), \\
a_{N-1} \dfrac{\textrm{d}}{dt} \beta_{N-1}(t) &amp; = f_{\beta_{N-1}}(\boldsymbol{a}, \boldsymbol{\beta}),
\end{cases}\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
f_{a_i}(\boldsymbol{a}, \boldsymbol{\beta}) &amp; = \sum_{j=1}^{N_e} \epsilon^{j} f_{a_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\beta}), \\
f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta}) &amp; = \sum_{j=1}^{N_e} \epsilon^{j} f_{\beta_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\beta}).
\end{cases}\end{split}\]</div>
<p>The MMS system then obtained represents a nonlinear autonomous system of <span class="math notranslate nohighlight">\(2N\)</span> coupled <span class="math notranslate nohighlight">\(1^{\textrm{st}}\)</span> order PDEs, with the physical time <span class="math notranslate nohighlight">\(t\)</span> as the independent variable.
Like the time scales-dependent evolution equations, they can be solved numerically or analytically, if analytical solutions exist.</p>
<p>These physical time-dependent evolution equations are also computed in <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.evolution_equations" title="oscilate.MMS.Multiple_scales_system.evolution_equations"><code class="xref py py-func docutils literal notranslate"><span class="pre">evolution_equations()</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.apply_MMS">
<span class="sig-name descname"><span class="pre">apply_MMS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rewrite_polar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.apply_MMS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.apply_MMS" title="Link to this definition"></a></dt>
<dd><p>Apply the MMS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rewrite_polar</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em>, </em><em>optional</em>) – The orders at which the solutions will be rewritten in polar form.
See <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.sol_xMMS_polar" title="oscilate.MMS.Multiple_scales_system.sol_xMMS_polar"><code class="xref py py-func docutils literal notranslate"><span class="pre">sol_xMMS_polar()</span></code></a>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The application of the MMS is operated by successively calling the following methods.</p>
<ol class="arabic">
<li><p><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.system_t0" title="oscilate.MMS.Multiple_scales_system.system_t0"><code class="xref py py-func docutils literal notranslate"><span class="pre">system_t0()</span></code></a>: An equivalent system is written in terms of the fast time scale <span class="math notranslate nohighlight">\(t_0\)</span>.
This introduces the temporary unknowns <span class="math notranslate nohighlight">\(\tilde{x}_{i,j}(t_0)\)</span> and allows the use of <a class="reference external" href="https://docs.sympy.org/latest/modules/solvers/ode.html#sympy.solvers.ode.dsolve" title="(in SymPy v1.14.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.sol_order_0" title="oscilate.MMS.Multiple_scales_system.sol_order_0"><code class="xref py py-func docutils literal notranslate"><span class="pre">sol_order_0()</span></code></a>: Leading order solutions <span class="math notranslate nohighlight">\(x_{i,0}(\boldsymbol{t})\)</span> are defined.</p></li>
<li><p><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.secular_analysis" title="oscilate.MMS.Multiple_scales_system.secular_analysis"><code class="xref py py-func docutils literal notranslate"><span class="pre">secular_analysis()</span></code></a>: The leading order solutions are introduced in the equations and the secular terms at each order are identified.
Cancelling those secular terms is a condition for bounded solutions.
It leads to a system of equations governing the slow evolution of the complex amplitude of the homogeneous leading order solutions.
Each equation takes the form</p>
<div class="math notranslate nohighlight">
\[\textrm{D}_{j} A_i(\boldsymbol{t}_s) = f_{A_i}^{(j)}(\boldsymbol{A}, t_1).\]</div>
<p>After cancelling the secular terms the higher order equations are solved successively to express the higher order solutions <span class="math notranslate nohighlight">\(x_{i,j}(\boldsymbol{t}),\; j&gt;0\)</span> in terms of the leading order ones.</p>
</li>
<li><p><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.autonomous_phases" title="oscilate.MMS.Multiple_scales_system.autonomous_phases"><code class="xref py py-func docutils literal notranslate"><span class="pre">autonomous_phases()</span></code></a>: The phase coordinates are changed from <span class="math notranslate nohighlight">\(\phi_i(\boldsymbol{t}_s)\)</span> to <span class="math notranslate nohighlight">\(\beta_i(\boldsymbol{t}_s)\)</span> to cancel the slow time <span class="math notranslate nohighlight">\(t_1\)</span> in the secular terms. This will be used afterwards to obtain an autonomous system.</p></li>
<li><p><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.evolution_equations" title="oscilate.MMS.Multiple_scales_system.evolution_equations"><code class="xref py py-func docutils literal notranslate"><span class="pre">evolution_equations()</span></code></a>: The secular conditions are split into real and imaginary parts, polar coordinates are used and the autonomous phases are introduced,
resulting in an autonomous system of evolution equations on polar coordinates.
Equations come by two, one representing the amplitude evolution while the other represents the phase’s, such that</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
\textrm{D}_{j} a_i(\boldsymbol{t}_s) &amp; = f_{a_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\beta}), \\
a_i \textrm{D}_{j} \beta_i(\boldsymbol{t}_s) &amp; = f_{\beta_i}^{(j)}(\boldsymbol{a}, \boldsymbol{\beta}).
\end{cases}\end{split}\]</div>
<p>This is the key result of the MMS. The evolution on each time scale are combined to reintroduce the physical time, resulting in a system of the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
\dfrac{\textrm{d}}{dt} a_i(t) &amp; = f_{a_i}(\boldsymbol{a}, \boldsymbol{\beta}), \\
a_i \dfrac{\textrm{d}}{dt} \beta_i(t) &amp; = f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta}).
\end{cases}\end{split}\]</div>
</li>
<li><p><a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.sol_xMMS_polar" title="oscilate.MMS.Multiple_scales_system.sol_xMMS_polar"><code class="xref py py-func docutils literal notranslate"><span class="pre">sol_xMMS_polar()</span></code></a>: The leading and higher order solutions are rewritten in terms of polar coordinates using <span class="math notranslate nohighlight">\(\cos\)</span> and <span class="math notranslate nohighlight">\(\sin\)</span> functions.</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.asymptotic_series">
<span class="sig-name descname"><span class="pre">asymptotic_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamical_system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps_pow_0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.asymptotic_series"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.asymptotic_series" title="Link to this definition"></a></dt>
<dd><p>Define the asymptotic series.</p>
<p class="rubric">Notes</p>
<p>The series expansion for oscillator <span class="math notranslate nohighlight">\(i\)</span> (and for a leading order term <span class="math notranslate nohighlight">\(\epsilon^0 = 1\)</span>) takes the form (see <code class="xref py py-class docutils literal notranslate"><span class="pre">Multiple_scales_system</span></code>)</p>
<div class="math notranslate nohighlight">
\[x_i(t) = x_{i,0}(t) + \epsilon x_{i,1}(t) + \epsilon^2 x_{i,2}(t) + \cdots + \epsilon^{N_e} x_{i,N_e}(t) + \mathcal{O}(\epsilon^{N_e+1}).\]</div>
<p>On top of introducing the terms of the asymptotic series, this function prepares substitutions from</p>
<ol class="arabic">
<li><p>dof <span class="math notranslate nohighlight">\(x_i(t)\)</span> to temporary <span class="math notranslate nohighlight">\(t\)</span>-dependent asymptotic terms <span class="math notranslate nohighlight">\(x_{i,j}(t)\)</span>, such that</p>
<div class="math notranslate nohighlight">
\[x_i(t) = x_{i,0}(t) + \epsilon x_{i,1}(t) + \epsilon^2 x_{i,2}(t) + \cdots + \epsilon^{N_e} x_{i,N_e}(t),\]</div>
</li>
<li><p>Temporary <span class="math notranslate nohighlight">\(x_{i,j}(t)\)</span> to the time scales-dependent terms <span class="math notranslate nohighlight">\(x_{i,j}(\boldsymbol{t})\)</span>, such that</p>
<div class="math notranslate nohighlight">
\[x_i(\boldsymbol{t}) = x_{i,0}(\boldsymbol{t}) + \epsilon x_{i,1}(\boldsymbol{t}) + \epsilon^2 x_{i,2}(\boldsymbol{t}) + \cdots + \epsilon^{N_e} x_{i,N_e}(\boldsymbol{t}).\]</div>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.autonomous_phases">
<span class="sig-name descname"><span class="pre">autonomous_phases</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.autonomous_phases"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.autonomous_phases" title="Link to this definition"></a></dt>
<dd><p>Define phase coordinates that render an autonomous system.</p>
<p class="rubric">Notes</p>
<p>Define new phase coordinates <span class="math notranslate nohighlight">\(\beta_i\)</span> to transform nonautonomous equations into autonomous ones.
The <span class="math notranslate nohighlight">\(\beta_i\)</span> are defined as</p>
<div class="math notranslate nohighlight">
\[\beta_i = \frac{r_i}{r_{\textrm{MMS}}} \sigma t_1 - \phi_i,\]</div>
<p>where we recall that
<span class="math notranslate nohighlight">\(\omega = r_{\textrm{MMS}} \omega_{\textrm{ref}} + \epsilon \sigma\)</span> and <span class="math notranslate nohighlight">\(\omega_{i,0} = r_i \omega_{\textrm{ref}}\)</span>.
See details on this choice in <code class="xref py py-class docutils literal notranslate"><span class="pre">Multiple_scales_system</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.compute_EqMMS">
<span class="sig-name descname"><span class="pre">compute_EqMMS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamical_system</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.compute_EqMMS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.compute_EqMMS" title="Link to this definition"></a></dt>
<dd><p>Compute the system of equations for each oscillator at each order of <span class="math notranslate nohighlight">\(\epsilon\)</span>. This system is described in <code class="xref py py-class docutils literal notranslate"><span class="pre">Multiple_scales_system</span></code>.</p>
<p>The output <cite>EqMMS</cite> is a list of lists:</p>
<ul class="simple">
<li><p>The <span class="math notranslate nohighlight">\(1^{\text{st}}\)</span> level lists are associated to the equations for each oscillator,</p></li>
<li><p>The <span class="math notranslate nohighlight">\(2^{\text{nd}}\)</span> level lists are associated to the orders of <span class="math notranslate nohighlight">\(\epsilon\)</span> from the lowest to the highest order.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dynamical_system</strong> (<a class="reference internal" href="#oscilate.MMS.Dynamical_system" title="oscilate.MMS.Dynamical_system"><em>Dynamical_system</em></a>) – The dynamical system.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.evolution_equations">
<span class="sig-name descname"><span class="pre">evolution_equations</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.evolution_equations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.evolution_equations" title="Link to this definition"></a></dt>
<dd><p>Derive the evolution equations of the polar coordinates system.</p>
<p class="rubric">Notes</p>
<p>Derive the evolution equations of the polar coordinates system (defined in <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.polar_coordinates" title="oscilate.MMS.Multiple_scales_system.polar_coordinates"><code class="xref py py-func docutils literal notranslate"><span class="pre">polar_coordinates()</span></code></a> and <a class="reference internal" href="#oscilate.MMS.Multiple_scales_system.autonomous_phases" title="oscilate.MMS.Multiple_scales_system.autonomous_phases"><code class="xref py py-func docutils literal notranslate"><span class="pre">autonomous_phases()</span></code></a>) from the secular conditions. For oscillator <span class="math notranslate nohighlight">\(i\)</span>, these are defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
\dfrac{\textrm{d} a_i}{\textrm{d} t}         &amp; = f_{a_i}(\boldsymbol{a}, \boldsymbol{\beta}), \\
a_i \dfrac{\textrm{d} \beta_i}{\textrm{d} t} &amp; = f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta}),
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{a}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{\beta}\)</span> are vectors containing the polar amplitudes and phases.</p>
<p>The aim here is to compute all the <span class="math notranslate nohighlight">\(f_{a_i}\)</span> and <span class="math notranslate nohighlight">\(f_{\beta_i}\)</span>.
This is done by:</p>
<ol class="arabic simple">
<li><p>Introducing polar coordinates in the secular terms</p></li>
<li><p>Splitting the real and imaginary parts of the (complex) secular terms</p></li>
<li><p>Using the autonomous phase coordinates</p></li>
<li><p>Collecting the terms governing the slow amplitude and phase dynamics.</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.find_harmonics">
<span class="sig-name descname"><span class="pre">find_harmonics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.find_harmonics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.find_harmonics" title="Link to this definition"></a></dt>
<dd><p>Determine the harmonics contained in the MMS solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>harmonics</strong> – list of the harmonics appearing in the MMS solutions.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.forcing_MMS">
<span class="sig-name descname"><span class="pre">forcing_MMS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dynamical_system</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.forcing_MMS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.forcing_MMS" title="Link to this definition"></a></dt>
<dd><p>Rewrite the forcing terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dynamical_system</strong> (<a class="reference internal" href="#oscilate.MMS.Dynamical_system" title="oscilate.MMS.Dynamical_system"><em>Dynamical_system</em></a>) – The dynamical system.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The initial forcing terms are</p>
<div class="math notranslate nohighlight">
\[f_{F,i}(\boldsymbol{x}(t), \dot{\boldsymbol{x}}(t), \ddot{\boldsymbol{x}}(t)) F \cos(\omega t), \quad i=1,...,N.\]</div>
<p>Rewritting them involves</p>
<ol class="arabic">
<li><p>Replacing the <span class="math notranslate nohighlight">\(x_i(t)\)</span> by their series expansions written in terms of time scales,</p></li>
<li><p>Scaling the forcing and the parameters in <span class="math notranslate nohighlight">\(f_{F,i}\)</span> if any,</p></li>
<li><p>Truncating terms whose order is larger than the largest order retained in the MMS,</p></li>
<li><p>Rewrite <span class="math notranslate nohighlight">\(\cos(\omega t)\)</span> as</p>
<div class="math notranslate nohighlight">
\[\cos(\omega t) = \frac{1}{2} e^{\mathrm{j}(\omega_{\textrm{MMS}} + \epsilon \sigma)t} + cc = \frac{1}{2} e^{\mathrm{j}(\omega_{\textrm{MMS}}t_0 + \sigma t_1)} + cc.\]</div>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.oscillators_frequencies">
<span class="sig-name descname"><span class="pre">oscillators_frequencies</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.oscillators_frequencies"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.oscillators_frequencies" title="Link to this definition"></a></dt>
<dd><p>Gives the expression of every oscillator frequency in terms of the reference frequency, possibly with a detuning.</p>
<p class="rubric">Notes</p>
<p>For the <span class="math notranslate nohighlight">\(i^\textrm{th}\)</span> oscillator, this leads to</p>
<div class="math notranslate nohighlight">
\[\omega_i = r_i \omega_{\textrm{ref}} + \delta_i .\]</div>
<p>An associated first-order natural frequency <span class="math notranslate nohighlight">\(\omega_{i,0}\)</span> is defined by neglecting the detuning <span class="math notranslate nohighlight">\(\delta_i\)</span>, which is at least of order <span class="math notranslate nohighlight">\(\epsilon\)</span>, resulting in</p>
<div class="math notranslate nohighlight">
\[\omega_{i,0} = r_i \omega_{\textrm{ref}}.\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.polar_coordinates">
<span class="sig-name descname"><span class="pre">polar_coordinates</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.polar_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.polar_coordinates" title="Link to this definition"></a></dt>
<dd><p>Define the polar coordinates.</p>
<p class="rubric">Notes</p>
<p>Define polar coordinates such that, for oscillator <span class="math notranslate nohighlight">\(i\)</span>, the complex amplitude of the homogeneous leading order solution is defined as</p>
<div class="math notranslate nohighlight">
\[A_i(\boldsymbol{t}_s) = \frac{1}{2} a_i(\boldsymbol{t}_s) e^{\textrm{j} \phi_i(\boldsymbol{t}_s)},\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i(\boldsymbol{t}_s)\)</span> and <span class="math notranslate nohighlight">\(\phi_i(\boldsymbol{t}_s)\)</span> are the solution’s amplitude and phase, respectively.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.secular_analysis">
<span class="sig-name descname"><span class="pre">secular_analysis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.secular_analysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.secular_analysis" title="Link to this definition"></a></dt>
<dd><p>Identify the secular terms in the MMS equations.
This allows to:</p>
<ol class="arabic simple">
<li><p>Compute the evolution equations of the complex amplitudes <span class="math notranslate nohighlight">\(A_i(\boldsymbol{t}_s)\)</span>, coming from the elimination of the secular terms,</p></li>
<li><p>Derive nonsecular MMS equations, i.e. MMS equations with the secular terms cancelled,</p></li>
<li><p>Use the nonsecular equations to express the higher order solutions <span class="math notranslate nohighlight">\(x_{i,j}(\boldsymbol{t}),\; j&gt;0\)</span> in terms of the <span class="math notranslate nohighlight">\(\boldsymbol{A}(\boldsymbol{t}_s)\)</span>.</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.sol_higher_order">
<span class="sig-name descname"><span class="pre">sol_higher_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">EqMMS_t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xMMS_t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">io</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.sol_higher_order"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.sol_higher_order" title="Link to this definition"></a></dt>
<dd><p>Compute the higher order solutions <span class="math notranslate nohighlight">\(x_{i,j}(\boldsymbol{t}_s),\; j&gt;0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>EqMMS_t0</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Expr</em>) – The MMS equations at each order and for each oscillator written with <span class="math notranslate nohighlight">\(t_0\)</span> as the only independent variable.</p></li>
<li><p><strong>xMMS_t0</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Function</em>) – Oscillators’ response at each order written in terms of <span class="math notranslate nohighlight">\(t_0\)</span> only, <span class="math notranslate nohighlight">\(\tilde{x}_{i,j}(t_0)\)</span>.</p></li>
<li><p><strong>io</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – The order of <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p></li>
<li><p><strong>ix</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – The dof number.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.sol_order_0">
<span class="sig-name descname"><span class="pre">sol_order_0</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.sol_order_0"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.sol_order_0" title="Link to this definition"></a></dt>
<dd><p>Compute the leading-order solutions for each oscillator.</p>
<p class="rubric">Notes</p>
<p>For oscillator <span class="math notranslate nohighlight">\(i\)</span>, the homogeneous solution takes the general form</p>
<div class="math notranslate nohighlight">
\[x_{i,0}^{\textrm{h}}(\boldsymbol{t}) = A_i(\boldsymbol{t}_s) e^{\textrm{j} \omega_{i,0} t_0} + cc,\]</div>
<p>where <span class="math notranslate nohighlight">\(A_i(\boldsymbol{t}_s)\)</span> is an unknown complex amplitude.</p>
<p>If the oscillator is subject to hard forcing (i.e. forcing appears at leading order), then the particular solution</p>
<div class="math notranslate nohighlight">
\[x_{i,0}^{\textrm{p}}(t_0, t_1) = B_i e^{\textrm{j} \omega t} + cc = B_i e^{\textrm{j} (\omega_{\textrm{MMS}} t_0 + \sigma t_1)} + cc\]</div>
<p>is also taken into account. <span class="math notranslate nohighlight">\(B_i\)</span> is a time-independent function of the forcing parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.sol_xMMS_polar">
<span class="sig-name descname"><span class="pre">sol_xMMS_polar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rewrite_polar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.sol_xMMS_polar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.sol_xMMS_polar" title="Link to this definition"></a></dt>
<dd><p>Write the solutions using the polar coordinates and <span class="math notranslate nohighlight">\(\cos\)</span> and <span class="math notranslate nohighlight">\(\sin\)</span> functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rewrite_polar</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> or </em><em>optional</em>) – The orders at which the solutions will be rewritten in polar form.
If <code class="docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code>, then all solution orders will be rewritten.
If <cite>int</cite>, then only a single order will be rewritten.
If <cite>list</cite> of <cite>int</cite>, then the listed orders will be rewritten.
Default is 0, so only the leading order solution will be rewritten.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.system_t0">
<span class="sig-name descname"><span class="pre">system_t0</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.system_t0"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.system_t0" title="Link to this definition"></a></dt>
<dd><p>Rewrite the system with the fast time scale as the only independent variable.</p>
<p class="rubric">Notes</p>
<p>This is a trick to use <a class="reference external" href="https://docs.sympy.org/latest/modules/solvers/ode.html#sympy.solvers.ode.dsolve" title="(in SymPy v1.14.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">dsolve()</span></code></a>, which only accepts functions of 1 variable, to solve higher order equations.
The higher order equations are rewritten in terms of temporary coordinates <span class="math notranslate nohighlight">\(\tilde{x}_{i,j}(t_0)\)</span> in place of <span class="math notranslate nohighlight">\(x_{i,j}(\boldsymbol{t})\)</span>, with <span class="math notranslate nohighlight">\(i,j\)</span> denoting the oscillator number and <span class="math notranslate nohighlight">\(\epsilon\)</span> order, respectively.
This is equivalent to temporary considering that <span class="math notranslate nohighlight">\(\boldsymbol{A}(\boldsymbol{t}_s)\)</span> does not depend on the slow times, which is of no consequence as there are no slow time derivatives appearing in the higher order equations at this stage.
Indeed, they were either substituted using the complex evolution equations, or they disappeared when eliminating the secular terms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Multiple_scales_system.time_scales">
<span class="sig-name descname"><span class="pre">time_scales</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Multiple_scales_system.time_scales"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Multiple_scales_system.time_scales" title="Link to this definition"></a></dt>
<dd><p>Define the time scales.</p>
<p class="rubric">Notes</p>
<p>The time scales are defined as (see <code class="xref py py-class docutils literal notranslate"><span class="pre">Multiple_scales_system</span></code>)</p>
<div class="math notranslate nohighlight">
\[t_0 = t, \quad t_1 = \epsilon t, \quad \cdots, \quad t_{N_e} = \epsilon^{N_e} t.\]</div>
<p>Substitutions from the physical time <span class="math notranslate nohighlight">\(t\)</span> to the time scales <span class="math notranslate nohighlight">\(t_i, \; i=0, ..., N_e\)</span> are also prepared.
Note that <span class="math notranslate nohighlight">\(t_0\)</span> is refered-to as the fast time as it captures the oscillations.
Other time scales are refered-to as slow time as they capture the modulations.</p>
</dd></dl>

</section>
</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Sol_MMS">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Sol_MMS</span></span><a class="reference internal" href="_modules/oscilate/MMS.html#Sol_MMS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Sol_MMS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Solutions obtained when applying the MMS.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Sol_SS">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Sol_SS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Sol_SS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Sol_SS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Solutions obtained when evaluating at steady state.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Stab_SS">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Stab_SS</span></span><a class="reference internal" href="_modules/oscilate/MMS.html#Stab_SS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Stab_SS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Stability analysis parameters and outputs.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Steady_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Steady state analysis of the multiple scales system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mms</strong> (<a class="reference internal" href="#oscilate.MMS.Multiple_scales_system" title="oscilate.MMS.Multiple_scales_system"><em>Multiple_scales_system</em></a>) – The multiple scales system.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Description of the steady state analysis.</p>
<section id="steady-state-solutions">
<h3>Steady state solutions<a class="headerlink" href="#steady-state-solutions" title="Link to this heading"></a></h3>
<section id="steady-state-conditions">
<h4>Steady state conditions<a class="headerlink" href="#steady-state-conditions" title="Link to this heading"></a></h4>
<p>At steady state, the solutions’ amplitudes and phases are time-independent. One therefore has, for each oscillator <span class="math notranslate nohighlight">\(i=1,...,N\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
\dfrac{\textrm{d}}{dt} a_i &amp; = 0, \\
\dfrac{\textrm{d}}{dt} \beta_i &amp; = 0, \\
\end{cases}\end{split}\]</div>
<p>and the homogeneous steady state solutions take the form</p>
<div class="math notranslate nohighlight">
\[x^{\textrm{h}}_{i,0}(t) = a_i \cos\left( \frac{r_i}{r_{\textrm{MMS}}} \omega t - \frac{r_i}{r_{\textrm{MMS}}} \beta_i \right).\]</div>
</section>
<section id="mms-evolution-equations-at-steady-state">
<h4>MMS evolution equations at steady state<a class="headerlink" href="#mms-evolution-equations-at-steady-state" title="Link to this heading"></a></h4>
<p>The steady state amplitudes <span class="math notranslate nohighlight">\(\boldsymbol{a}\)</span> and phases <span class="math notranslate nohighlight">\(\boldsymbol{\beta}\)</span> are governed by the evolution equations evaluated at steady state, which take the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
f_{a_0}(\boldsymbol{a}, \boldsymbol{\beta})     &amp; = 0, \\
f_{\beta_0}(\boldsymbol{a}, \boldsymbol{\beta}) &amp; = 0, \\
&amp; \vdots \\
f_{a_{N-1}}(\boldsymbol{a}, \boldsymbol{\beta})     &amp; = 0, \\
f_{\beta_{N-1}}(\boldsymbol{a}, \boldsymbol{\beta}) &amp; = 0.
\end{cases}\end{split}\]</div>
<p>This is now an algebraic system of equations.</p>
</section>
<section id="mms-solutions-at-steady-state">
<h4>MMS solutions at steady state<a class="headerlink" href="#mms-solutions-at-steady-state" title="Link to this heading"></a></h4>
<p>Solving the evolution equations at steady state yields the steady state solutions <span class="math notranslate nohighlight">\(\boldsymbol{a}, \boldsymbol{\beta}\)</span>.
The system can be solved directly for <span class="math notranslate nohighlight">\(\boldsymbol{a}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{\beta}\)</span>, yielding explicit analytical solutions, but this is often complex as the system is nonlinear.</p>
<p>A possibility that is sometimes available to obtain <strong>analytical solutions</strong> is to rearrange the equations to isolate the phase terms <span class="math notranslate nohighlight">\(\cos(f(\boldsymbol{\beta})),\; \sin(f(\boldsymbol{\beta}))\)</span> where <span class="math notranslate nohighlight">\(f(\boldsymbol{\beta})\)</span> is a linear function of the <span class="math notranslate nohighlight">\(\beta_i\)</span>.
Then the equations can be squared and summed up to obtain an equation on <span class="math notranslate nohighlight">\(a_i\)</span> only and/or <span class="math notranslate nohighlight">\(a_j\)</span> as a function of <span class="math notranslate nohighlight">\(a_i\)</span>. The <span class="math notranslate nohighlight">\(a_j\)</span> can be expressed as a function of <span class="math notranslate nohighlight">\(a_i\)</span>, leading to a polynomial equation on <span class="math notranslate nohighlight">\(a_i\)</span>.
The resulting polynomial equation can rarely be solved directly as the polynomial involved are often of high order.
However, the polynomial is often quadratic in the detuning <span class="math notranslate nohighlight">\(\sigma\)</span> and forcing amplitude <span class="math notranslate nohighlight">\(F\)</span>.
It can therefore be solved for <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(F\)</span> with <span class="math notranslate nohighlight">\(a_i\)</span> seen as a parameter.
This yields an implicit solution for <span class="math notranslate nohighlight">\(a_i(\sigma) \Rightarrow a_i(\omega)\)</span> and <span class="math notranslate nohighlight">\(a_i(F)\)</span>, from which one can deduce the other amplitudes <span class="math notranslate nohighlight">\(a_j\)</span> and phases <span class="math notranslate nohighlight">\(\boldsymbol{\beta}\)</span>, thus reconstructing the oscillators’ solutions.</p>
<p>The processus described above is not always feasible. The blocking points are typically to</p>
<ol class="lowerroman simple">
<li><p>get rid of phase terms <span class="math notranslate nohighlight">\(\cos(f(\boldsymbol{\beta})),\; \sin(f(\boldsymbol{\beta}))\)</span> in the equations,</p></li>
<li><p>express every amplitude <span class="math notranslate nohighlight">\(a_j\)</span> in terms of a single one, <span class="math notranslate nohighlight">\(a_i\)</span>,</p></li>
<li><p>end up with a polynomial of order 2 in <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(F\)</span></p></li>
</ol>
<p>These difficulties become more pronounced when the system involves several oscillator, in which case the amplitudes and phases may only be <strong>computed numerically</strong>.</p>
<p>To facilitate the derivation of an analytical solution, it is possible to consider the <strong>backbone curve</strong> (bbc) of the forced solution rather than the forced solution itself.
This bbc is computed in the absence of damping and forcing, therefore simplifying the system. Typically, this reduces the number of phase terms appearing.
The solving procedure is then the same as that described previously.</p>
</section>
</section>
<section id="stability-analysis">
<h3>Stability analysis<a class="headerlink" href="#stability-analysis" title="Link to this heading"></a></h3>
<p>The stability analysis is described in details in <a class="reference internal" href="#oscilate.MMS.Steady_state.stability_analysis" title="oscilate.MMS.Steady_state.stability_analysis"><code class="xref py py-func docutils literal notranslate"><span class="pre">stability_analysis()</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.Jacobian_cartesian">
<span class="sig-name descname"><span class="pre">Jacobian_cartesian</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.Jacobian_cartesian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.Jacobian_cartesian" title="Link to this definition"></a></dt>
<dd><p>Compute the Jacobian of the evolution equations systems expressed in cartesian coordinates (see <a class="reference internal" href="#oscilate.MMS.Steady_state.stability_analysis" title="oscilate.MMS.Steady_state.stability_analysis"><code class="xref py py-func docutils literal notranslate"><span class="pre">stability_analysis()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>J</strong> – Jacobian of the cartesian system.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>sympy.Matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.Jacobian_polar">
<span class="sig-name descname"><span class="pre">Jacobian_polar</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.Jacobian_polar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.Jacobian_polar" title="Link to this definition"></a></dt>
<dd><p>Compute the Jacobian of the evolution equations systems expressed in polar coordinates (see <a class="reference internal" href="#oscilate.MMS.Steady_state.stability_analysis" title="oscilate.MMS.Steady_state.stability_analysis"><code class="xref py py-func docutils literal notranslate"><span class="pre">stability_analysis()</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>J</strong> – Jacobian of the polar system.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>sympy.Matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.additional_cartesian_substitutions">
<span class="sig-name descname"><span class="pre">additional_cartesian_substitutions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fq</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.additional_cartesian_substitutions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.additional_cartesian_substitutions" title="Link to this definition"></a></dt>
<dd><p>Reformulate the already-existing substitutions from polar to cartesian to try and substitute leftover polar terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fp</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Expr</em>) – Evolution functions for the cartesian coordinates <span class="math notranslate nohighlight">\(p_i\)</span>.
There are polar coordinates remaining.</p></li>
<li><p><strong>fq</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Expr</em>) – Evolution functions for the cartesian coordinates <span class="math notranslate nohighlight">\(q_i\)</span>.
There are polar coordinates remaining.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fp</strong> (<em>list of sympy.Expr</em>) – Evolution functions for the cartesian coordinates <span class="math notranslate nohighlight">\(p_i\)</span>.
Additional substitutions were performed to get rid of polar coordinates.</p></li>
<li><p><strong>fq</strong> (<em>list of sympy.Expr</em>) – Evolution functions for the cartesian coordinates <span class="math notranslate nohighlight">\(q_i\)</span>.
Additional substitutions were performed to get rid of polar coordinates.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.bifurcation_curves">
<span class="sig-name descname"><span class="pre">bifurcation_curves</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">detJ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trJ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_a=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_sig=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver=&lt;function</span> <span class="pre">solve_poly2&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.bifurcation_curves"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.bifurcation_curves" title="Link to this definition"></a></dt>
<dd><p>Compute bifurcation curves.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>detJ</strong> (<em>sympy.Expr</em>) – The determinant of the matrix.</p></li>
<li><p><strong>trJ</strong> (<em>sympy.Expr</em>) – The trace of the matrix.</p></li>
<li><p><strong>var_a</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><em>optional</em>) – Consider the <span class="math notranslate nohighlight">\(i^{\textrm{th}}\)</span> oscillator’s amplitude <span class="math notranslate nohighlight">\(a_i\)</span> as the variable and find the bifurcation curve as an expression for <span class="math notranslate nohighlight">\(a_i\)</span>.
<cite>detJ</cite> is rarely a quadratic polynomial in <span class="math notranslate nohighlight">\(a_i\)</span>, so this can rarely be computed easily.
Default is <cite>False</cite>.</p></li>
<li><p><strong>var_sig</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><em>optional</em>) – Consider the detuning <span class="math notranslate nohighlight">\(\sigma\)</span> as the variable and find the bifurcation curve as an expression for <span class="math notranslate nohighlight">\(\sigma\)</span>.
<cite>detJ</cite> is often a quadratic polynomial in <span class="math notranslate nohighlight">\(\sigma\)</span>, so this can often be computed.
Default is <cite>True</cite>.</p></li>
<li><p><strong>solver</strong> (<em>function</em><em>, </em><em>optional</em>) – The solver to use to compute the bifurcation curves.
Available are solver called as <cite>solve(expr, x)</cite>, which solve <cite>expr=0</cite> for <cite>x</cite>.
<a class="reference external" href="https://docs.sympy.org/latest/modules/solvers/solvers.html#sympy.solvers.solvers.solve" title="(in SymPy v1.14.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve()</span></code></a> can be used but is sometimes slow.
Default is <code class="xref py py-func docutils literal notranslate"><span class="pre">solve_poly2()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>bif_a</strong> (<em>list</em>) – The bifurcation curves for <span class="math notranslate nohighlight">\(a_i^2\)</span>.</p></li>
<li><p><strong>bif_sig</strong> (<em>list</em>) – The bifurcation curves for <span class="math notranslate nohighlight">\(\sigma\)</span>.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The bifurcation curves computed here are the curves defined by the bifurcation points obtained for any forcing frequency and amplitude.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.cartesian_coordinates">
<span class="sig-name descname"><span class="pre">cartesian_coordinates</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.cartesian_coordinates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.cartesian_coordinates" title="Link to this definition"></a></dt>
<dd><p>Define cartesian coordinates from the polar ones.</p>
<p class="rubric">Notes</p>
<p>The homogeneous leading order solution for oscillator <span class="math notranslate nohighlight">\(i\)</span> expressed in polar coordinates takes the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
x_{i,0}^{\textrm{h}}(t) &amp; = a_i \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t - \beta_i \right), \\
                        &amp; = a_i \cos(\beta_i) \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right)
                          + a_i \sin(\beta_i) \sin\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right)
\end{split}\end{split}\]</div>
<p>The polar coordinates are defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
p_i = a_i \cos (\beta_i), \\
q_i = a_i \sin (\beta_i),
\end{cases}\end{split}\]</div>
<p>such that the leading order solution can be written as</p>
<div class="math notranslate nohighlight">
\[x_{i,0}^{\textrm{h}}(t) = p_i \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right) + q_i \sin\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right).\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.check_cartesian_substitutions">
<span class="sig-name descname"><span class="pre">check_cartesian_substitutions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fq</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.check_cartesian_substitutions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.check_cartesian_substitutions" title="Link to this definition"></a></dt>
<dd><p>Check if substitutions from polar to cartesian coordinates are complete.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Symbol</em>) – Amplitudes of the leading order solutions.</p></li>
<li><p><strong>beta</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Symbol</em>) – Phases of the leading order solutions.</p></li>
<li><p><strong>fp</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Expr</em>) – Evolution functions for the cartesian coordinates <span class="math notranslate nohighlight">\(p_i\)</span>.</p></li>
<li><p><strong>fq</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Expr</em>) – Evolution functions for the cartesian coordinates <span class="math notranslate nohighlight">\(q_i\)</span>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>substitution_OK</strong> – <cite>True</cite> if substitutions are complete.
<cite>False</cite> otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.eigenvalues">
<span class="sig-name descname"><span class="pre">eigenvalues</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.eigenvalues"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.eigenvalues" title="Link to this definition"></a></dt>
<dd><p>Computes the eigenvalues of a matrix <span class="math notranslate nohighlight">\(\textrm{A}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>sympy.Matrix</em>) – The matrix whose eigenvalues are to be computed.</p></li>
<li><p><strong>detA</strong> (<em>sympy.Expr</em>) – Determinant of A.
Default is <cite>None</cite>.</p></li>
<li><p><strong>trA</strong> (<em>sympy.Expr</em>) – Trace of A.
Default is <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>eigvals</strong> – The eigenvalues of <span class="math notranslate nohighlight">\(\textrm{A}\)</span>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.evolution_equations_SS">
<span class="sig-name descname"><span class="pre">evolution_equations_SS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.evolution_equations_SS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.evolution_equations_SS" title="Link to this definition"></a></dt>
<dd><p>Evaluate the evolution equations at steady state (polar system).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.evolution_equations_cartesian">
<span class="sig-name descname"><span class="pre">evolution_equations_cartesian</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.evolution_equations_cartesian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.evolution_equations_cartesian" title="Link to this definition"></a></dt>
<dd><p>Compute the evolution equations of the cartesian coordinates system.</p>
<p class="rubric">Notes</p>
<p>Write the evolution equations using the cartesian coordinates (defined in <a class="reference internal" href="#oscilate.MMS.Steady_state.cartesian_coordinates" title="oscilate.MMS.Steady_state.cartesian_coordinates"><code class="xref py py-func docutils literal notranslate"><span class="pre">cartesian_coordinates()</span></code></a>).
For oscillator <span class="math notranslate nohighlight">\(i\)</span>, this results in</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
\dfrac{\textrm{d} p_i}{\textrm{d} t} &amp; = f_{p_i}(\boldsymbol{p}, \boldsymbol{q}), \\
\dfrac{\textrm{d} q_i}{\textrm{d} t} &amp; = f_{q_i}(\boldsymbol{p}, \boldsymbol{q}),
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{p}(t)\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{q}(t)\)</span> are vectors containing the cartesian coordinates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.plot_ARC">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plot_ARC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ARC</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.plot_ARC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.plot_ARC" title="Link to this definition"></a></dt>
<dd><p>Plots the amplitude-response curves (ARC), both forcing amplitude-amplitude and forcing amplitude-phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ARC</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>) – Dictionary containing the amplitude response curves.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fig1</strong> (<em>Figure</em>) – The amplitude plot <span class="math notranslate nohighlight">\(a(F)\)</span>.</p></li>
<li><p><strong>fig2</strong> (<em>Figure</em>) – The phase plot <span class="math notranslate nohighlight">\(\beta(F)\)</span>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.plot_FRC">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">plot_FRC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">FRC</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.plot_FRC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.plot_FRC" title="Link to this definition"></a></dt>
<dd><p>Plots the frequency response curves (FRC), both frequency-amplitude and frequency-phase.
Also includes the stability information if given.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>FRC</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>) – Dictionary containing the frequency response curves and the bifurcation curves.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fig1</strong> (<em>Figure</em>) – The amplitude plot <span class="math notranslate nohighlight">\(a(\omega)\)</span>.</p></li>
<li><p><strong>fig2</strong> (<em>Figure</em>) – The phase plot <span class="math notranslate nohighlight">\(\beta(\omega)\)</span>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.polar_coordinates_SS">
<span class="sig-name descname"><span class="pre">polar_coordinates_SS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.polar_coordinates_SS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.polar_coordinates_SS" title="Link to this definition"></a></dt>
<dd><p>Introduce time-independent amplitudes and phases (polar coordinates).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.solve_F">
<span class="sig-name descname"><span class="pre">solve_F</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.solve_F"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.solve_F" title="Link to this definition"></a></dt>
<dd><p>Solve the forced response in terms of the forcing amplitude <span class="math notranslate nohighlight">\(F\)</span>. Returns <span class="math notranslate nohighlight">\(F(a_i)\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.solve_a">
<span class="sig-name descname"><span class="pre">solve_a</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.solve_a"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.solve_a" title="Link to this definition"></a></dt>
<dd><p>Solve the forced response in terms of the oscillator’s amplitude.
For readability, the output actually returned is <span class="math notranslate nohighlight">\(a_i^2(\sigma, F)\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.solve_bbc">
<span class="sig-name descname"><span class="pre">solve_bbc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solve_dof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.solve_bbc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.solve_bbc" title="Link to this definition"></a></dt>
<dd><p>Find the backbone curve (bbc) of a given oscillator with the other oscillators’ amplitude set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>c</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em>, </em><em>optional</em>) – Damping terms. They will be set to 0 to compute the backbone curve.
Note that these are the scaled damping terms.
Default is <cite>[]</cite>.</p></li>
<li><p><strong>solve_dof</strong> (<em>None</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em>, </em><em>oprtional</em>) – The oscillator number to solve for.
If <cite>None</cite>, no oscillator is solved for.
Default is <cite>None</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The backbone curve describes the frequency of free oscillations as a function of the oscillator’s amplitude.
In the presence of small damping (as in the case in the MMS) the frequency of free oscillations is close from the resonance frequency.
The backbone curve can therefore be interpreted as the <em>backbone</em> of the forced response.</p>
<p>The backbone curve of oscillator <span class="math notranslate nohighlight">\(i\)</span> typically takes the form</p>
<div class="math notranslate nohighlight">
\[\omega_{\textrm{bbc}}^{(i)} = k\omega_{i} + f_{\textrm{bbc}}^{(i)} (a_i),\]</div>
<p>where <span class="math notranslate nohighlight">\(k=1,\; k&lt;1,\; k&gt;1\)</span> are associated to direct, superharmonic and subharmonic responses, respectively.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.solve_forced">
<span class="sig-name descname"><span class="pre">solve_forced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solve_dof</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.solve_forced"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.solve_forced" title="Link to this definition"></a></dt>
<dd><p>Solve the forced response of an oscillator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>solve_dof</strong> (<em>None</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em>, </em><em>optional</em>) – The oscillator to solve for.
If <cite>None</cite>, no oscillator is solved for.
Default is <cite>None</cite>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Find the steady state solution for a given oscillator with the other oscillators’ amplitude set to 0.</p>
<p>To do so, one must choose an oscillator to chose for, say oscillator <span class="math notranslate nohighlight">\(i\)</span>. Then, the following methods are called:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#oscilate.MMS.Steady_state.substitution_solve_dof" title="oscilate.MMS.Steady_state.substitution_solve_dof"><code class="xref py py-func docutils literal notranslate"><span class="pre">substitution_solve_dof()</span></code></a>: Set the other oscillators’ amplitude to 0, i.e. <span class="math notranslate nohighlight">\(a_j = 0 \; \forall j \neq i\)</span>.</p></li>
<li><p><a class="reference internal" href="#oscilate.MMS.Steady_state.solve_phase" title="oscilate.MMS.Steady_state.solve_phase"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_phase()</span></code></a>: express the oscillator’s phase <span class="math notranslate nohighlight">\(\beta_i\)</span> as a function of its amplitude <span class="math notranslate nohighlight">\(a_i\)</span>.</p></li>
<li><p><a class="reference internal" href="#oscilate.MMS.Steady_state.solve_sigma" title="oscilate.MMS.Steady_state.solve_sigma"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_sigma()</span></code></a>: find the expression of <span class="math notranslate nohighlight">\(\sigma(a_i)\)</span>.</p></li>
<li><p><a class="reference internal" href="#oscilate.MMS.Steady_state.solve_a" title="oscilate.MMS.Steady_state.solve_a"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_a()</span></code></a>: find the expression of <span class="math notranslate nohighlight">\(a_i (\sigma, F)\)</span>.</p></li>
<li><p><a class="reference internal" href="#oscilate.MMS.Steady_state.solve_F" title="oscilate.MMS.Steady_state.solve_F"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve_F()</span></code></a>: find the expression of <span class="math notranslate nohighlight">\(F(a_i)\)</span>.</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.solve_phase">
<span class="sig-name descname"><span class="pre">solve_phase</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.solve_phase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.solve_phase" title="Link to this definition"></a></dt>
<dd><p>Find solutions for the oscillator’s phase <span class="math notranslate nohighlight">\(\beta_i\)</span>.
The solutions actually returned are <span class="math notranslate nohighlight">\(\sin(\beta_i)\)</span> and <span class="math notranslate nohighlight">\(\cos(\beta_i)\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.solve_sigma">
<span class="sig-name descname"><span class="pre">solve_sigma</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.solve_sigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.solve_sigma" title="Link to this definition"></a></dt>
<dd><p>Solve the forced response in terms of the detuning <span class="math notranslate nohighlight">\(\sigma\)</span>.
Returns <span class="math notranslate nohighlight">\(\sigma(a_i)\)</span>.
It is recalled that <span class="math notranslate nohighlight">\(\omega = \omega_{\textrm{MMS}} + \epsilon \sigma\)</span>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.stability_analysis">
<span class="sig-name descname"><span class="pre">stability_analysis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cartesian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rewrite_polar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigenvalues</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bifurcation_curves</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">analyse_blocks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs_bif</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.stability_analysis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.stability_analysis" title="Link to this definition"></a></dt>
<dd><p>Evaluate the stability of a steady state solution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coord</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em>, </em><em>optional</em>) – Either <code class="docutils literal notranslate"><span class="pre">&quot;cartesian&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;polar&quot;</span></code>.
Specifies the coordinates to use for the stability analysis.
<code class="docutils literal notranslate"><span class="pre">&quot;cartesian&quot;</span></code> is recommended as it prevents divisions by 0, which occur when at least one of the oscillator has a 0 ampliutude.
Default is <code class="docutils literal notranslate"><span class="pre">&quot;cartesian&quot;</span></code>.</p></li>
<li><p><strong>rewrite_polar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><em>optional</em>) – Rewrite the Jacobian’s determinant and trace in polar coordinates (if computed using cartesian ones).
This is time consuming and the current back substitutions from cartesian to polar coordinates are not always sufficient.
Default is <cite>False</cite>.</p></li>
<li><p><strong>eigenvalues</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><em>optional</em>) – Compute the eigenvalues of the Jacobian.
Default is <cite>False</cite>.</p></li>
<li><p><strong>bifurcation_curves</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><em>optional</em>) – Compute the bifurcation curves.
Default is <cite>False</cite>.</p></li>
<li><p><strong>analyse_blocks</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><em>optional</em>) – Analyse the diagonal blocks of the Jacobian rather than the Jacobian itself. This is relevant if the Jacobian is block-diagonal.</p></li>
<li><p><strong>kwargs_bif</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a><em>, </em><em>optional</em>) – Passed to <a class="reference internal" href="#oscilate.MMS.Steady_state.bifurcation_curves" title="oscilate.MMS.Steady_state.bifurcation_curves"><code class="xref py py-func docutils literal notranslate"><span class="pre">bifurcation_curves()</span></code></a>
Default is <cite>dict()</cite>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<section id="stability-information">
<h4>Stability information<a class="headerlink" href="#stability-information" title="Link to this heading"></a></h4>
<p>Consider a steady state solution <span class="math notranslate nohighlight">\((\hat{\boldsymbol{a}} , \hat{\boldsymbol{\beta}})\)</span> such that, for <span class="math notranslate nohighlight">\(i=1,...,N\)</span>,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
f_{a_i}(\hat{\boldsymbol{a}}, \hat{\boldsymbol{\beta}})     &amp; = 0, \\
f_{\beta_i}(\hat{\boldsymbol{a}}, \hat{\boldsymbol{\beta}}) &amp; = 0.
\end{cases}\end{split}\]</div>
<p>The aim is to determine the stability state of that steady solution, which corresponds to a fixed point in the phase space.</p>
<section id="jacobian-matrix">
<h5>Jacobian matrix<a class="headerlink" href="#jacobian-matrix" title="Link to this heading"></a></h5>
<p>Let’s first introduce the vector of polar coordinates and polar evolution functions</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{x}^{(\textrm{p})\intercal} &amp; = [a_0, \beta_0, \cdots, a_{N-1}, \beta_{N-1}], \\
\boldsymbol{f}^{(\textrm{p})\intercal} &amp; = [f_{a_0}, f_{\beta_0}^*, \cdots, f_{a_{N-1}}, f_{\beta_{N-1}}^*].\end{split}\]</div>
<p>Note that the appearance of <span class="math notranslate nohighlight">\(f_{\beta_i}^*\)</span> in <span class="math notranslate nohighlight">\(\boldsymbol{f}^{(\textrm{p})}\)</span> requires <span class="math notranslate nohighlight">\(a_i \neq 0\)</span>, which strongly constraints the type of steady state solutions that can be considered in the approach described below.
To relax this constraint, one can use a change of coordinates from polar to cartesian ones.
This will be discussed in following sections, after the description of this polar approach.</p>
<p>Using the vectors of polar coordinates and evolution functions, one can write the evolution equations system as</p>
<div class="math notranslate nohighlight">
\[\dfrac{\textrm{d} \boldsymbol{x}^{(\textrm{p})}}{\textrm{d}t} = \textrm{J}^{(\textrm{p})} \boldsymbol{x}^{(\textrm{p})},\]</div>
<p>where we introduced the Jacobian matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}\textrm{J}^{(\textrm{p})}
= \dfrac{\partial \boldsymbol{f}^{(\textrm{p})} }{ \partial \boldsymbol{x}^{(\textrm{p})} }
= \begin{bmatrix}
\frac{\partial f_{a_0}}{\partial a_0} &amp; \frac{\partial f_{a_0}}{\partial \beta_0} &amp; \cdots &amp; \frac{\partial f_{a_0}}{\partial \beta_{N-1}} \\
\frac{\partial f_{\beta_0}^*}{\partial a_0} &amp; \frac{\partial f_{\beta_0}^*}{\partial \beta_0} &amp; \cdots &amp; \frac{\partial f_{\beta_0}^*}{\partial \beta_{N-1}} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\frac{\partial f_{\beta_{N-1}}^*}{\partial a_0} &amp; \frac{\partial f_{\beta_{N-1}}^*}{\partial \beta_0} &amp; \cdots &amp; \frac{\partial f_{\beta_{N-1}}^*}{\partial \beta_{N-1}}
\end{bmatrix}.\end{split}\]</div>
</section>
<section id="perturbation-of-the-steady-state-solution">
<h5>Perturbation of the steady state solution<a class="headerlink" href="#perturbation-of-the-steady-state-solution" title="Link to this heading"></a></h5>
<p>Let us now consider a small perturbation <span class="math notranslate nohighlight">\(\tilde{\boldsymbol{x}}^{(\textrm{p})}\)</span> of the steady state solution such that</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{x}^{(\textrm{p})} = \hat{\boldsymbol{x}}^{(\textrm{p})} + \tilde{\boldsymbol{x}}^{(\textrm{p})} \quad \Leftrightarrow \quad \tilde{\boldsymbol{x}}^{(\textrm{p})} = \boldsymbol{x}^{(\textrm{p})} - \hat{\boldsymbol{x}}^{(\textrm{p})}.\]</div>
<p>Using a first order Taylor expansion for <span class="math notranslate nohighlight">\(\textrm{d} \tilde{\boldsymbol{x}}^{(\textrm{p})} / \textrm{d} t\)</span>, one can write</p>
<div class="math notranslate nohighlight">
\[\dfrac{\textrm{d} \tilde{\boldsymbol{x}}^{(\textrm{p})}}{\textrm{d}t} = \left.\textrm{J}^{(\textrm{p})}\right|_{\hat{\boldsymbol{x}}^{(\textrm{p})}} \tilde{\boldsymbol{x}}^{(\textrm{p})} + \mathcal{O}(||\tilde{\boldsymbol{x}}^{(\textrm{p})}||^2),\]</div>
<p>where <span class="math notranslate nohighlight">\(\left.\textrm{J}^{(\textrm{p})}\right|_{\hat{\boldsymbol{x}}^{(\textrm{p})}}\)</span> denotes the Jacobian matrix evaluated on the steady state solution.
The perturbation solution takes the form</p>
<div class="math notranslate nohighlight">
\[\tilde{\boldsymbol{x}}^{(\textrm{p})} = \sum_{i=1}^{2N} C_i \boldsymbol{\psi}_i e^{\lambda_i t},\]</div>
<p>where <span class="math notranslate nohighlight">\((\lambda_i, \boldsymbol{\psi}_i),\; i=1, ..., 2N\)</span> are the eigensolutions of the Jacobian (evaluated on <span class="math notranslate nohighlight">\(\hat{\boldsymbol{x}}^{(\textrm{p})}\)</span>).</p>
</section>
<section id="stability-condition">
<h5>Stability condition<a class="headerlink" href="#stability-condition" title="Link to this heading"></a></h5>
<p>The steady state solution <span class="math notranslate nohighlight">\(\hat{\boldsymbol{x}}^{(\textrm{p})}\)</span> is considered stable if a small perturbation <span class="math notranslate nohighlight">\(\tilde{\boldsymbol{x}}^{(\textrm{p})}\)</span> vanishes in time,
such that solutions close from <span class="math notranslate nohighlight">\(\hat{\boldsymbol{x}}^{(\textrm{p})}\)</span> are converging towards it. This condition is fulfilled if</p>
<div class="math notranslate nohighlight">
\[\Re[\lambda_i] &lt; 0, \quad \forall i,\]</div>
<p>meaning that all eigenvalues of the Jacobian evaluated on the steady state solution must have negative real parts.
If this condition is not met, the system is either quasi stable or unstable.</p>
</section>
<section id="bifurcations">
<h5>Bifurcations<a class="headerlink" href="#bifurcations" title="Link to this heading"></a></h5>
<p>A bifurcation occurs when the stability state of the system changes.</p>
<ol class="arabic simple">
<li><p>Simple bifurcations occur when at least one eigenvalue crosses the imaginary axis through 0.
Such bifurcations include saddle node and pitchfork bifurcations, which cause jumps of the response and the appearance of lower symmetry solutions, respectively.</p></li>
<li><p>Neimark-Sacker bifurcations occur when a pair of complex conjugate eigenvalues with nonzero real parts cross the imaginary axis.
These bifurcations lead to non periodic solutions.</p></li>
</ol>
<p>Simple bifurcations can be detected by evaluating the sign of the Jacobian, as</p>
<div class="math notranslate nohighlight">
\[\det \left.\textrm{J}^{(\textrm{p})}\right|_{\hat{\boldsymbol{x}}^{(\textrm{p})}} = \prod_{i=1}^{2N} \lambda_i,\]</div>
<p>thereby making <span class="math notranslate nohighlight">\(\det \left.\textrm{J}^{(\textrm{p})}\right|_{\hat{\boldsymbol{x}}^{(\textrm{p})}}\)</span> an important stability indicator.
Neimark-Sacker bifurcations are more difficult to detect. Information from the trace of <span class="math notranslate nohighlight">\(\left.\textrm{J}^{(\textrm{p})}\right|_{\hat{\boldsymbol{x}}^{(\textrm{p})}}\)</span> can be considered, or the Routh-Hurwitz criterion can be used. This is not detailed here.</p>
</section>
<section id="bifurcation-curves">
<h5>Bifurcation curves<a class="headerlink" href="#bifurcation-curves" title="Link to this heading"></a></h5>
<p>Bifurcation curves are curves constructed by evaluating the coordinates of bifurcation points when varying one or more parameters.
The stability state of a solution changes when the response curve crosses a bifurcation curve.</p>
</section>
</section>
<section id="stability-analysis-in-cartesian-coordinates">
<h4>Stability analysis in cartesian coordinates<a class="headerlink" href="#stability-analysis-in-cartesian-coordinates" title="Link to this heading"></a></h4>
<section id="limitations-of-polar-coordinates">
<h5>Limitations of polar coordinates<a class="headerlink" href="#limitations-of-polar-coordinates" title="Link to this heading"></a></h5>
<p>As mentioned previously, the approach described above fails when one of the oscillator’s leading order amplitude is 0.
Indeed, the Jacobian is constructed using the evolution functions</p>
<div class="math notranslate nohighlight">
\[f_{\beta_i}^*(\boldsymbol{a}, \boldsymbol{\beta}) = \frac{f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta})}{a_i},\]</div>
<p>which are defined only if <span class="math notranslate nohighlight">\(a_i=0\)</span>.
This prevents evaluating the stability of</p>
<ul class="simple">
<li><p>Trivial solutions, for which no oscillator responds,</p></li>
<li><p>1 mode solutions, whose stability can be affected under perturbation from another mode.</p></li>
</ul>
<p>These limitations can be overcome using a change of coordinates.</p>
</section>
<section id="cartesian-coordinates">
<h5>Cartesian coordinates<a class="headerlink" href="#cartesian-coordinates" title="Link to this heading"></a></h5>
<p>The leading order homogeneous solution for oscillator <span class="math notranslate nohighlight">\(i\)</span> can be written as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
x_{i,0}^{\textrm{h}}(t) &amp; = a_i \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t - \beta_i \right), \\
                        &amp; = a_i \cos(\beta_i) \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right)
                          + a_i \sin(\beta_i) \sin\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right).
\end{split}\end{split}\]</div>
<p>It then appears natural to introduce the cartesian coordinates</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
p_i = a_i \cos(\beta_i), \\
q_i = a_i \sin(\beta_i),
\end{cases}\end{split}\]</div>
<p>in order to rewrite the solution as</p>
<div class="math notranslate nohighlight">
\[x_{i,0}^{\textrm{h}}(t) = p_i \cos\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right) + q_i \sin\left(\frac{r_i}{r_{\textrm{MMS}}}\omega t\right).\]</div>
<p>In the following it will be convenient to use the cartesian coordinates vectors</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\boldsymbol{p}(t)^\intercal &amp; = [p_0(t), p_1(t), \cdots, p_{N-1}(t)], \\
\boldsymbol{q}(t)^\intercal &amp; = [q_0(t), q_1(t), \cdots, q_{N-1}(t)].
\end{aligned}\end{split}\]</div>
</section>
<section id="cartesian-evolution-equations">
<h5>Cartesian evolution equations<a class="headerlink" href="#cartesian-evolution-equations" title="Link to this heading"></a></h5>
<p>The cartesian evolution equations can be obtained from the polar ones. To do so, one can write</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
\dfrac{\textrm{d} p_i}{\textrm{d}t} &amp; = \dfrac{\textrm{d} a_i}{\textrm{d}t} \cos(\beta_i) - a_i \sin(\beta_i) \dfrac{\textrm{d} \beta_i}{\textrm{d}t}, \\
\dfrac{\textrm{d} q_i}{\textrm{d}t} &amp; = \dfrac{\textrm{d} a_i}{\textrm{d}t} \sin(\beta_i) + a_i \cos(\beta_i) \dfrac{\textrm{d} \beta_i}{\textrm{d}t}.
\end{cases}\end{split}\]</div>
<p>Then, by identification, one necessarily has</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
f_{p_i}(\boldsymbol{p}, \boldsymbol{q}) &amp; = f_{a_i}(\boldsymbol{a}, \boldsymbol{\beta}) \cos(\beta_i) - f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta}) \sin(\beta_i), \\
f_{q_i}(\boldsymbol{p}, \boldsymbol{q}) &amp; = f_{a_i}(\boldsymbol{a}, \boldsymbol{\beta}) \sin(\beta_i) + f_{\beta_i}(\boldsymbol{a}, \boldsymbol{\beta}) \cos(\beta_i),
\end{cases}\end{split}\]</div>
<p>in order to write the evolution equations in cartesian coordinates</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
\dfrac{\textrm{d}}{dt} p_0(t) &amp; = f_{p_0}(\boldsymbol{p}, \boldsymbol{q}), \\
\dfrac{\textrm{d}}{dt} q_0(t) &amp; = f_{q_0}(\boldsymbol{p}, \boldsymbol{q}), \\
&amp; \vdots \\
\dfrac{\textrm{d}}{dt} p_{N-1}(t) &amp; = f_{p_{N-1}}(\boldsymbol{p}, \boldsymbol{q}), \\
\dfrac{\textrm{d}}{dt} q_{N-1}(t) &amp; = f_{q_{N-1}}(\boldsymbol{p}, \boldsymbol{q}).
\end{cases}\end{split}\]</div>
</section>
<section id="id1">
<h5>Jacobian matrix<a class="headerlink" href="#id1" title="Link to this heading"></a></h5>
<p>As done previously for polar coordinates, let’s introduce the vectors of cartesian coordinates and evolution equations as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{x}^{(\textrm{c})\intercal} &amp; = [p_0, q_0, \cdots, p_{N-1}, q_{N-1}], \\
\boldsymbol{f}^{(\textrm{c})\intercal} &amp; = [f_{p_0}, f_{q_0}, \cdots, f_{p_{N-1}}, f_{q_{N-1}}].\end{split}\]</div>
<p>Then one can write</p>
<div class="math notranslate nohighlight">
\[\dfrac{\textrm{d} \boldsymbol{x}^{(\textrm{c})}}{\textrm{d}t} = \textrm{J}^{(\textrm{c})} \boldsymbol{x}^{(\textrm{c})},\]</div>
<p>where we introduced the Jacobian matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}\textrm{J}^{(\textrm{c})}
= \dfrac{\partial \boldsymbol{f}^{(\textrm{c})} }{ \partial \boldsymbol{x}^{(\textrm{c})} }
= \begin{bmatrix}
\frac{\partial f_{p_0}}{\partial p_0} &amp; \frac{\partial f_{p_0}}{\partial q_0} &amp; \cdots &amp; \frac{\partial f_{p_0}}{\partial q_{N-1}} \\
\frac{\partial f_{q_0}}{\partial p_0} &amp; \frac{\partial f_{q_0}}{\partial q_0} &amp; \cdots &amp; \frac{\partial f_{q_0}}{\partial q_{N-1}} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\frac{\partial f_{q_{N-1}}}{\partial p_0} &amp; \frac{\partial f_{q_{N-1}}}{\partial q_0} &amp; \cdots &amp; \frac{\partial f_{q_{N-1}}}{\partial q_{N-1}}
\end{bmatrix}.\end{split}\]</div>
<p>Note that there are no constraints related to an oscillator’s amplitude being 0 here.
This cartesian coordinates approach therefore allows to investigate how the stability of a steady state solution is affected by a perturbation from an oscillator who’s amplitude is 0 in that steady state solution.</p>
<p>The stability analysis with <span class="math notranslate nohighlight">\(\textrm{J}^{(\textrm{c})}\)</span> is carried out as described previously with <span class="math notranslate nohighlight">\(\textrm{J}^{(\textrm{p})}\)</span>.</p>
</section>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="oscilate.MMS.Steady_state.substitution_solve_dof">
<span class="sig-name descname"><span class="pre">substitution_solve_dof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">solve_dof</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Steady_state.substitution_solve_dof"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Steady_state.substitution_solve_dof" title="Link to this definition"></a></dt>
<dd><p>Set every oscillator amplitude to 0 except the one to solve for.</p>
<p class="rubric">Notes</p>
<p>If one wants to solve for <span class="math notranslate nohighlight">\(a_i\)</span>, then the system is evaluated for <span class="math notranslate nohighlight">\(a_j=0, \; \forall j \neq i\)</span>.</p>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Substitutions_MMS">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Substitutions_MMS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_xMMS_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_scaling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_sigma</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Substitutions_MMS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Substitutions_MMS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Substitutions used in the MMS.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="oscilate.MMS.Substitutions_SS">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">Substitutions_SS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#Substitutions_SS"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.Substitutions_SS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Substitutions used in the steady state evaluations.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.cartesian_to_polar">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">cartesian_to_polar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_polar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_phase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#cartesian_to_polar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.cartesian_to_polar" title="Link to this definition"></a></dt>
<dd><p>Rewrites an expression or a matrix <cite>y</cite> from cartesian to polar coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y</strong> (<em>sympy.Expr</em><em> or </em><em>sympy.Matrix</em>) – A sympy expression or matrix written in cartesian coordinates.</p></li>
<li><p><strong>sub_polar</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a>) – A list of substitutions to perform to go from cartesian to polar coordinates.</p></li>
<li><p><strong>sub_phase</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em>, </em><em>optional</em>) – Additional substitutions to try and get rid of phases, so that only the amplitude remains in the expression.
Default is <cite>None</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>yp</strong> – The initial expression or matrix written in polar coordinates.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expr or sympy.Matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.numpise_ARC">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">numpise_ARC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#numpise_ARC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.numpise_ARC" title="Link to this definition"></a></dt>
<dd><p>Evaluate the amplitude-response curves at given numerical values.
This transforms the sympy expressions to numpy arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mms</strong> (<a class="reference internal" href="#oscilate.MMS.Multiple_scales_system" title="oscilate.MMS.Multiple_scales_system"><em>Multiple_scales_system</em></a>) – The MMS object.</p></li>
<li><p><strong>ss</strong> (<a class="reference internal" href="#oscilate.MMS.Steady_state" title="oscilate.MMS.Steady_state"><em>Steady_state</em></a>) – The MMS results evaluated at steady state.</p></li>
<li><p><strong>dyn</strong> (<a class="reference internal" href="#oscilate.MMS.Dynamical_system" title="oscilate.MMS.Dynamical_system"><em>Dynamical_system</em></a>) – The initial dynamical system.</p></li>
<li><p><strong>param</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>) – <p>A dictionnary whose values are tuples with 2 elements:</p>
<ol class="arabic simple">
<li><p>The sympy symbol of a parameter,</p></li>
<li><p>The numerical value(s) taken by that parameter.</p></li>
</ol>
<p>The key of the amplitude vector must be <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code>.
The key of the angular frequency must be <code class="docutils literal notranslate"><span class="pre">&quot;omega&quot;</span></code>.</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ARC</strong> – The amplitude-response curves data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.numpise_FRC">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">numpise_FRC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bbc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bif</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#numpise_FRC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.numpise_FRC" title="Link to this definition"></a></dt>
<dd><p>Evaluate the frequency-response and bifurcation curves at given numerical values.
This transforms the sympy expressions to numpy arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mms</strong> (<a class="reference internal" href="#oscilate.MMS.Multiple_scales_system" title="oscilate.MMS.Multiple_scales_system"><em>Multiple_scales_system</em></a>) – The MMS object.</p></li>
<li><p><strong>ss</strong> (<a class="reference internal" href="#oscilate.MMS.Steady_state" title="oscilate.MMS.Steady_state"><em>Steady_state</em></a>) – The MMS results evaluated at steady state.</p></li>
<li><p><strong>dyn</strong> (<a class="reference internal" href="#oscilate.MMS.Dynamical_system" title="oscilate.MMS.Dynamical_system"><em>Dynamical_system</em></a>) – The initial dynamical system.</p></li>
<li><p><strong>param</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>) – <p>A dictionary whose values are tuples with 2 elements:</p>
<ol class="arabic simple">
<li><p>The sympy symbol of a parameter,</p></li>
<li><p>The numerical value(s) taken by that parameter.</p></li>
</ol>
<p>The key of the amplitude vector must be <code class="docutils literal notranslate"><span class="pre">&quot;a&quot;</span></code>.
The key of the forcing amplitude must be <code class="docutils literal notranslate"><span class="pre">&quot;F&quot;</span></code>.</p>
</p></li>
<li><p><strong>bbc</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><em>optional</em>) – Evaluate the backbone curve.
Default is <cite>True</cite>.</p></li>
<li><p><strong>forced</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><em>optional</em>) – Evaluate the forced response.
Default is <cite>True</cite>.</p></li>
<li><p><strong>bif</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><em>optional</em>) – Evaluate the bifurcation curves.
Default is <cite>True</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>FRC</strong> – The frequency-response curves data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)">dict</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.numpise_F_ARC">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">numpise_F_ARC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#numpise_F_ARC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.numpise_F_ARC" title="Link to this definition"></a></dt>
<dd><p>Numpise the forced response’s forcing amplitude <span class="math notranslate nohighlight">\(F\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mms</strong> (<a class="reference internal" href="#oscilate.MMS.Multiple_scales_system" title="oscilate.MMS.Multiple_scales_system"><em>Multiple_scales_system</em></a>)</p></li>
<li><p><strong>ss</strong> (<a class="reference internal" href="#oscilate.MMS.Steady_state" title="oscilate.MMS.Steady_state"><em>Steady_state</em></a>)</p></li>
<li><p><strong>param</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>) – See <code class="xref py py-func docutils literal notranslate"><span class="pre">sympy_to_numpy()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>F</strong> – Numpised forced response’s forcing amplitude.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.numpise_omega_FRC">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">numpise_omega_FRC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#numpise_omega_FRC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.numpise_omega_FRC" title="Link to this definition"></a></dt>
<dd><p>Numpise the forced response’s frequency <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mms</strong> (<a class="reference internal" href="#oscilate.MMS.Multiple_scales_system" title="oscilate.MMS.Multiple_scales_system"><em>Multiple_scales_system</em></a>)</p></li>
<li><p><strong>ss</strong> (<a class="reference internal" href="#oscilate.MMS.Steady_state" title="oscilate.MMS.Steady_state"><em>Steady_state</em></a>)</p></li>
<li><p><strong>param</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>) – See <code class="xref py py-func docutils literal notranslate"><span class="pre">sympy_to_numpy()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>omega</strong> – Numpised forced response’s frequency.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.numpise_omega_bbc">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">numpise_omega_bbc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#numpise_omega_bbc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.numpise_omega_bbc" title="Link to this definition"></a></dt>
<dd><p>Numpise the backbone curve’s frequency <span class="math notranslate nohighlight">\(\omega_{\textrm{bbc}}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mms</strong> (<a class="reference internal" href="#oscilate.MMS.Multiple_scales_system" title="oscilate.MMS.Multiple_scales_system"><em>Multiple_scales_system</em></a>)</p></li>
<li><p><strong>ss</strong> (<a class="reference internal" href="#oscilate.MMS.Steady_state" title="oscilate.MMS.Steady_state"><em>Steady_state</em></a>)</p></li>
<li><p><strong>param</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>) – See <code class="xref py py-func docutils literal notranslate"><span class="pre">sympy_to_numpy()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>omega_bbc</strong> – Numpised backbone curve’s frequency.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.numpise_omega_bif">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">numpise_omega_bif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#numpise_omega_bif"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.numpise_omega_bif" title="Link to this definition"></a></dt>
<dd><p>Numpise the bifurcation curves’ frequency <span class="math notranslate nohighlight">\(\omega_{\textrm{bif}}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mms</strong> (<a class="reference internal" href="#oscilate.MMS.Multiple_scales_system" title="oscilate.MMS.Multiple_scales_system"><em>Multiple_scales_system</em></a>)</p></li>
<li><p><strong>ss</strong> (<a class="reference internal" href="#oscilate.MMS.Steady_state" title="oscilate.MMS.Steady_state"><em>Steady_state</em></a>)</p></li>
<li><p><strong>param</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>) – See <code class="xref py py-func docutils literal notranslate"><span class="pre">sympy_to_numpy()</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>omega_bif</strong> – Numpised bifurcation curves’ frequency.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)">list</a> of numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.numpise_phase">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">numpise_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dyn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#numpise_phase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.numpise_phase" title="Link to this definition"></a></dt>
<dd><p>Numpise the phase <span class="math notranslate nohighlight">\(\beta_i\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mms</strong> (<a class="reference internal" href="#oscilate.MMS.Multiple_scales_system" title="oscilate.MMS.Multiple_scales_system"><em>Multiple_scales_system</em></a>)</p></li>
<li><p><strong>ss</strong> (<a class="reference internal" href="#oscilate.MMS.Steady_state" title="oscilate.MMS.Steady_state"><em>Steady_state</em></a>)</p></li>
<li><p><strong>dyn</strong> (<a class="reference internal" href="#oscilate.MMS.Dynamical_system" title="oscilate.MMS.Dynamical_system"><em>Dynamical_system</em></a>)</p></li>
<li><p><strong>param</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>) – See <code class="xref py py-func docutils literal notranslate"><span class="pre">sympy_to_numpy()</span></code>.</p></li>
<li><p><strong>omega</strong> (<em>numpy.ndarray</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>numpy.ndarray</em>) – The frequency array.</p></li>
<li><p><strong>F</strong> (<em>numpy.ndarray</em>) – The forcing amplitude array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>phase</strong> – Numpised phase.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)">list</a> of numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.rescale">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">rescale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mms</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#rescale"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.rescale" title="Link to this definition"></a></dt>
<dd><p>Rescales a scaled expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>sympy.Expr</em>) – An unscaled expression, i.e. an expression appearing at some order of <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p></li>
<li><p><strong>mms</strong> (<a class="reference internal" href="#oscilate.MMS.Multiple_scales_system" title="oscilate.MMS.Multiple_scales_system"><em>Multiple_scales_system</em></a>) – The mms system, containing substitutions to scale an expression.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>expr_scaled</strong> – The scaled expression.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.MMS.scale_parameters">
<span class="sig-prename descclassname"><span class="pre">oscilate.MMS.</span></span><span class="sig-name descname"><span class="pre">scale_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/MMS.html#scale_parameters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.MMS.scale_parameters" title="Link to this definition"></a></dt>
<dd><p>Scale parameters with the scaling parameter <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>sympy.Symbol and/or sympy.Function</em>) – Unscaled parameters.</p></li>
<li><p><strong>scaling</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>) – The scaling for each parameter.</p></li>
<li><p><strong>eps</strong> (<em>sympy.Symbol</em>) – Small parameter <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>param_scaled</strong> (<em>list of sympy.Symbol and/or sympy.Function</em>) – Scaled parameters.</p></li>
<li><p><strong>sub_scaling</strong> (<em>list of 2 lists of tuple</em>) – Substitutions from scaled to unscaled parameters and vice-versa.</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(1^{\text{st}}\)</span> list: The substitutions to do to introduce the scaled parameters in an expression.</p></li>
<li><p><span class="math notranslate nohighlight">\(2^{\text{nd}}\)</span> list: The substitutions to do to reintroduce the unscaled parameters in a scaled expression.</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For a given parameter <span class="math notranslate nohighlight">\(p\)</span> and a scaling order <span class="math notranslate nohighlight">\(\lambda\)</span>, the associated scaled parameter <span class="math notranslate nohighlight">\(\tilde{p}\)</span> is</p>
<div class="math notranslate nohighlight">
\[p = \epsilon^{\lambda} \tilde{p} .\]</div>
</dd></dl>

</section>
<section id="module-oscilate.sympy_functions">
<span id="sympy-functions-module"></span><h2>sympy_functions Module<a class="headerlink" href="#module-oscilate.sympy_functions" title="Link to this heading"></a></h2>
<p>Started on Wed Apr  9 13:39:41 2025</p>
<p>&#64;author: Vincent MAHE</p>
<p>Sympy functions useful to the use of MMS functions.</p>
<table class="autosummary longtable docutils align-default">
<tbody>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="oscilate.sympy_functions.check_solvability">
<span class="sig-prename descclassname"><span class="pre">oscilate.sympy_functions.</span></span><span class="sig-name descname"><span class="pre">check_solvability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/sympy_functions.html#check_solvability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.sympy_functions.check_solvability" title="Link to this definition"></a></dt>
<dd><p>Check the solvability of a polynomial <span class="math notranslate nohighlight">\(p(x)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poly</strong> (<em>sympy.Expr</em>) – The polynomial considered.</p></li>
<li><p><strong>x</strong> (<em>sympy.Symbol</em>) – The variable to solve for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>bool</strong> – True is solvable, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)">bool</a>,</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.sympy_functions.get_block_diagonal_indices">
<span class="sig-prename descclassname"><span class="pre">oscilate.sympy_functions.</span></span><span class="sig-name descname"><span class="pre">get_block_diagonal_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_sizes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/sympy_functions.html#get_block_diagonal_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.sympy_functions.get_block_diagonal_indices" title="Link to this definition"></a></dt>
<dd><p>Generate a list of <span class="math notranslate nohighlight">\((i, j)\)</span> indices for all elements in the diagonal blocks of a block-diagonal matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>sympy.Matrix</em>) – The matrix to check for block diagonality.</p></li>
<li><p><strong>block_sizes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – Size(s) of the diagonal blocks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>indices</strong> – A list of tuples <cite>(i, j)</cite> representing the indices of elements in the diagonal blocks.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)">list</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.sympy_functions.get_exponent">
<span class="sig-prename descclassname"><span class="pre">oscilate.sympy_functions.</span></span><span class="sig-name descname"><span class="pre">get_exponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/sympy_functions.html#get_exponent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.sympy_functions.get_exponent" title="Link to this definition"></a></dt>
<dd><p>Get the exponent of <span class="math notranslate nohighlight">\(x\)</span> in an expression of the type <span class="math notranslate nohighlight">\(\lambda x^n\)</span> where <span class="math notranslate nohighlight">\(\lambda\)</span> is a constant while <span class="math notranslate nohighlight">\(n\)</span> is an integer or rational.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>sympy.Expr</em>) – The expression in which one wants to identify the exponent of x.</p></li>
<li><p><strong>x</strong> (<em>sympy.Symbol</em>) – The variable whose exponent is to be known.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.sympy_functions.is_block_diagonal">
<span class="sig-prename descclassname"><span class="pre">oscilate.sympy_functions.</span></span><span class="sig-name descname"><span class="pre">is_block_diagonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_sizes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/sympy_functions.html#is_block_diagonal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.sympy_functions.is_block_diagonal" title="Link to this definition"></a></dt>
<dd><p>Check if a matrix is block-diagonal given block sizes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>sympy.Matrix</em>) – The matrix to check for block diagonality.</p></li>
<li><p><strong>block_sizes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – Size(s) of the diagonal blocks.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>bool</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><cite>True</cite> if the matrix is block-diagonal, <cite>False</cite> otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.sympy_functions.polynomial_terms">
<span class="sig-prename descclassname"><span class="pre">oscilate.sympy_functions.</span></span><span class="sig-name descname"><span class="pre">polynomial_terms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/sympy_functions.html#polynomial_terms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.sympy_functions.polynomial_terms" title="Link to this definition"></a></dt>
<dd><p>Identify the terms of a polynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poly</strong> (<em>sympy.Expr</em>) – The polynomial considered.</p></li>
<li><p><strong>x</strong> (<em>sympy.Symbol</em>) – The variable to solve for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dic_x</strong> – The polynomial terms.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)">dict</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the expression given for poly is of the form</p>
<div class="math notranslate nohighlight">
\[p(x) = q(x) x^{-n},\]</div>
<p>where the powers of <span class="math notranslate nohighlight">\(x\)</span> in <span class="math notranslate nohighlight">\(q(x)\)</span> are all superior or equal to <span class="math notranslate nohighlight">\(0\)</span>,
then an auxiliary polynomial</p>
<div class="math notranslate nohighlight">
\[P(x) = \dfrac{p(x)}{x^{-n}}\]</div>
<p>is constructed. It is the terms of that positive powers polynomial that are returned.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.sympy_functions.solve_poly2">
<span class="sig-prename descclassname"><span class="pre">oscilate.sympy_functions.</span></span><span class="sig-name descname"><span class="pre">solve_poly2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/sympy_functions.html#solve_poly2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.sympy_functions.solve_poly2" title="Link to this definition"></a></dt>
<dd><p>Finds the roots of a polynomial of degree 2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poly</strong> (<em>sympy.Expr</em>) – polynomial whose roots are to be computed</p></li>
<li><p><strong>x</strong> (<em>sympy.Symbol</em>) – Variable of the polynomial</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x_sol</strong> – list containing the two roots of the polynomial</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)">list</a> of sympy.Expr</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The polynomial of degree 2 takes the form</p>
<div class="math notranslate nohighlight">
\[p(x) = a x^2 + bx + c.\]</div>
<p>Note that <span class="math notranslate nohighlight">\(b\)</span> can be null but not <span class="math notranslate nohighlight">\(a\)</span> nor <span class="math notranslate nohighlight">\(c\)</span>.</p>
<p>It is a workaround to using <a class="reference external" href="https://docs.sympy.org/latest/modules/solvers/solvers.html#sympy.solvers.solvers.solve" title="(in SymPy v1.14.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve()</span></code></a> or <a class="reference external" href="https://docs.sympy.org/latest/modules/solvers/solveset.html#sympy.solvers.solveset.solveset" title="(in SymPy v1.14.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">solveset()</span></code></a>.
These two work but can be very long when coefficients <span class="math notranslate nohighlight">\(a,\; b,\; c\)</span> are expressions involving many parameters.
Note that <a class="reference external" href="https://docs.sympy.org/latest/modules/solvers/solvers.html#sympy.solvers.solvers.solve" title="(in SymPy v1.14.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve()</span></code></a> is significantly slower than <a class="reference external" href="https://docs.sympy.org/latest/modules/solvers/solveset.html#sympy.solvers.solveset.solveset" title="(in SymPy v1.14.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">solveset()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.sympy_functions.sub_deep">
<span class="sig-prename descclassname"><span class="pre">oscilate.sympy_functions.</span></span><span class="sig-name descname"><span class="pre">sub_deep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/sympy_functions.html#sub_deep"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.sympy_functions.sub_deep" title="Link to this definition"></a></dt>
<dd><p>Performs deep substitutions of an expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr</strong> (<em>sympy.Expr</em>) – Expression on which substitutions are to be performed.</p></li>
<li><p><strong>sub</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em> of </em><em>tuples</em>) – The substitutions to perform.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>expr_sub</strong> – The expression with substitutions performed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sympy.Expr</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Deep substitutions are needed when a substitution involves terms that can still be substituted.
For instance, one wants to substitute <span class="math notranslate nohighlight">\(a_1\)</span> and <span class="math notranslate nohighlight">\(a_2\)</span> by expressions, but <span class="math notranslate nohighlight">\(a_1\)</span> is actually a function of <span class="math notranslate nohighlight">\(a_2\)</span>, so at least 2 substitutions are required.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="oscilate.sympy_functions.sympy_to_numpy">
<span class="sig-prename descclassname"><span class="pre">oscilate.sympy_functions.</span></span><span class="sig-name descname"><span class="pre">sympy_to_numpy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr_sy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/oscilate/sympy_functions.html#sympy_to_numpy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#oscilate.sympy_functions.sympy_to_numpy" title="Link to this definition"></a></dt>
<dd><p>Transform a sympy expression into a numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expr_sy</strong> (<em>sympy.Expr</em>) – A sympy expression.</p></li>
<li><p><strong>param</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>) – <p>A dictionnary whose values are tuples with 2 elements:</p>
<ol class="arabic simple">
<li><p>The sympy symbol of a parameter</p></li>
<li><p>The numerical value(s) taken by that parameter</p></li>
</ol>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>expr_np</strong> – The numerical values taken by the sympy expression evaluated.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="OSCILATE documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="architecture.html" class="btn btn-neutral float-right" title="Package Architecture" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Vincent MAHE.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>